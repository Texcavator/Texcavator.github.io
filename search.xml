<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在前面的话</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<p>欢迎来到 Texcavator 的 Blog！</p>
<p>这里将记录下我学习过程中的笔记和心得</p>
<p>没想好这里还要写什么，之后再来补充啦~</p>
]]></content>
  </entry>
  <entry>
    <title>【C++】位运算</title>
    <url>/posts/4befabc3.html</url>
    <content><![CDATA[<p>因为对位运算实在是太太太太太不熟悉了！所以每次遇到位运算相关的题都要卡好久才能把题目意思转化成容易理解的样子，今晚又被卡了所以一怒之下总结一篇等下次被卡就来翻翻qwq</p>
<h1 id="与"><a href="#与" class="headerlink" title="与 &amp;"></a>与 &amp;</h1><p>翻译：同为1取1，只要有0就取0</p>
<ul>
<li>可以用&amp;来取每一位上的数，如果要判断n的第三位是否为1，就进行 $n$ &amp; $2^{3-1}$ 运算，如果结果为 $2^{3-1}$ ，就说明当前判断的位数上是1，结果是0，就说明当前判断的位数上是0</li>
<li><strong>判断奇偶</strong><br><code>a &amp; 1 == 1</code> a为奇数<br><code>a &amp; 1 == 0</code> a为偶数</li>
</ul>
<h1 id="或-（OR）"><a href="#或-（OR）" class="headerlink" title="或 | （OR）"></a>或 | （OR）</h1><p>翻译：有1取1，无1取0</p>
<ul>
<li>一个数对另一个数进行 | 操作，当前位上是0将不产生任何影响，<strong>当前位上是1将会把对应位上变成1</strong></li>
<li><strong>把一个数变成最接近的偶数</strong>：<code>a = a | 1 - 1</code></li>
</ul>
<h1 id="异或-（XOR）"><a href="#异或-（XOR）" class="headerlink" title="异或 ^ （XOR）"></a>异或 ^ （XOR）</h1><p>翻译：相同为0，不同为1</p>
<ul>
<li>一个数和本身进行异或运算得到结果为0</li>
<li>一个数和0进行异或运算得到结果为本身</li>
<li>上两条推出：<strong>奇数个相同的数异或运算得到结果为本身，偶数个相同的数异或运算得到结果为0</strong></li>
</ul>
<h1 id="左移"><a href="#左移" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h1><p>翻译：<code>a &lt;&lt; b = a x 2^b</code></p>
<h1 id="右移"><a href="#右移" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h1><p>翻译：<code>a &gt;&gt; b = a / 2^b</code></p>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>按位反（~）&gt; 位移运算（&lt;&lt;,&gt;&gt;）&gt; 按位与（&amp;）&gt; 按位异或（^）&gt; 按位或（|）</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>C++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>【图论】Floyd</title>
    <url>/posts/15c63d49.html</url>
    <content><![CDATA[<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="牛的旅行"><a href="#牛的旅行" class="headerlink" title="牛的旅行"></a>牛的旅行</h2><p><a href="https://www.acwing.com/problem/content/1127/">原题链接</a></p>
<p>农民John的农场里有很多牧区，有的路径连接一些特定的牧区。</p>
<p>一片所有连通的牧区称为一个牧场。</p>
<p>但是就目前而言，你能看到至少有两个牧区不连通。</p>
<p>现在，John想在农场里添加一条路径（注意，恰好一条）。</p>
<p>一个牧场的直径就是牧场中最远的两个牧区的距离（本题中所提到的所有距离指的都是最短的距离）。</p>
<p>考虑如下的两个牧场，每一个牧区都有自己的坐标：</p>
<img src="/posts/15c63d49/2.png" class>

<p>图 1 是有 5 个牧区的牧场，牧区用“*”表示，路径用直线表示。</p>
<p>图 1 所示的牧场的直径大约是 12.07106, 最远的两个牧区是 A 和 E，它们之间的最短路径是 A-B-E。</p>
<p>图 2 是另一个牧场。</p>
<p>这两个牧场都在John的农场上。</p>
<p>John将会在两个牧场中各选一个牧区，然后用一条路径连起来，使得连通后这个新的更大的牧场有最小的直径。</p>
<p>注意，如果两条路径中途相交，我们不认为它们是连通的。</p>
<p>只有两条路径在同一个牧区相交，我们才认为它们是连通的。</p>
<p>现在请你编程找出一条连接两个不同牧场的路径，使得连上这条路径后，所有牧场（生成的新牧场和原有牧场）中直径最大的牧场的直径尽可能小。</p>
<p>输出这个直径最小可能值。</p>
<p><strong>输入格式</strong></p>
<p>第 1 行：一个整数 N, 表示牧区数；</p>
<p>第 2 到 N+1 行：每行两个整数 X,Y， 表示 N 个牧区的坐标。每个牧区的坐标都是不一样的。</p>
<p>第 N+2 行到第 2*N+1 行：每行包括 N 个数字 ( 0或1 ) 表示一个对称邻接矩阵。</p>
<p>例如，题目描述中的两个牧场的矩阵描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  A B C D E F G H </span><br><span class="line">A 0 1 0 0 0 0 0 0 </span><br><span class="line">B 1 0 1 1 1 0 0 0 </span><br><span class="line">C 0 1 0 0 1 0 0 0 </span><br><span class="line">D 0 1 0 0 1 0 0 0 </span><br><span class="line">E 0 1 1 1 0 0 0 0 </span><br><span class="line">F 0 0 0 0 0 0 1 0 </span><br><span class="line">G 0 0 0 0 0 1 0 1 </span><br><span class="line">H 0 0 0 0 0 0 1 0</span><br></pre></td></tr></table></figure>
<p>输入数据中至少包括两个不连通的牧区。</p>
<p><strong>输出格式</strong></p>
<p>只有一行，包括一个实数，表示所求答案。</p>
<p>数字保留六位小数。</p>
<p><strong>数据范围</strong></p>
<p>$1≤N≤150,$<br>$0≤X,Y≤105$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span></span><br><span class="line"><span class="number">15</span> <span class="number">10</span></span><br><span class="line"><span class="number">20</span> <span class="number">10</span></span><br><span class="line"><span class="number">15</span> <span class="number">15</span></span><br><span class="line"><span class="number">20</span> <span class="number">15</span></span><br><span class="line"><span class="number">30</span> <span class="number">15</span></span><br><span class="line"><span class="number">25</span> <span class="number">10</span></span><br><span class="line"><span class="number">30</span> <span class="number">10</span></span><br><span class="line"><span class="number">01000000</span></span><br><span class="line"><span class="number">10111000</span></span><br><span class="line"><span class="number">01001000</span></span><br><span class="line"><span class="number">01001000</span></span><br><span class="line"><span class="number">01110000</span></span><br><span class="line"><span class="number">00000010</span></span><br><span class="line"><span class="number">00000101</span></span><br><span class="line"><span class="number">00000010</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">22.071068</span></span><br></pre></td></tr></table></figure>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一张图，连通的部分算作一个区域，每个区域的直径为区域中相隔最远的两个点的距离，问在不同区域中添加一条边，得到的最小直径是多少</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先建图，然后跑一遍floyd算出和每一个点相隔最远的点的距离</p>
<p>得到的最新直径一定大于等于原来的最大直径，因此可以先求出原来的最大直径<code>maxd[i]</code></p>
<p>加上一条边<code>[i, j]</code>得到的新直径是<code>maxd[i] + maxd[j] + dist[i][j]</code></p>
<p>二者取最大值即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; PDD;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">155</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> INF = <span class="number">1e20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> d[N][N];</span><br><span class="line"><span class="type">double</span> maxd[N];</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line">PDD q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_dist</span><span class="params">(PDD a, PDD b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx = a.first - b.first;</span><br><span class="line">    <span class="type">double</span> dy = a.second - b.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i].first &gt;&gt; q[i].second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span>) d[i][j] = <span class="built_in">get_dist</span>(q[i], q[j]); <span class="comment">// ij之间有边</span></span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF; <span class="comment">// ij之间无边</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// floyd更新最短路</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> r1 = <span class="number">0</span>; <span class="comment">// 两个牧场中最长的直径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (d[i][j] &lt; INF / <span class="number">2</span>) <span class="comment">// 说明ij之间有边</span></span><br><span class="line">                maxd[i] = <span class="built_in">max</span>(maxd[i], d[i][j]); <span class="comment">// 更新与i最远的点距离</span></span><br><span class="line">        r1 = <span class="built_in">max</span>(r1, maxd[i]); <span class="comment">// 更新直径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> r2 = INF; <span class="comment">// 加边之后的最长值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (d[i][j] &gt; INF / <span class="number">2</span>) <span class="comment">// 说明ij之间无边 可以加边</span></span><br><span class="line">                r2 = <span class="built_in">min</span>(r2, maxd[i] + maxd[j] + <span class="built_in">get_dist</span>(q[i], q[j]));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, <span class="built_in">max</span>(r1, r2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><a href="https://www.acwing.com/problem/content/345/">原题链接</a></p>
<p>给定 n 个变量和 m 个不等式。其中 n 小于等于 26，变量分别用前 n 的大写英文字母表示。</p>
<p>不等式之间具有传递性，即若 A&gt;B 且 B&gt;C，则 A&gt;C。</p>
<p>请从前往后遍历每对关系，每次遍历时判断：</p>
<p>如果能够确定全部关系且无矛盾，则结束循环，输出确定的次序；<br>如果发生矛盾，则结束循环，输出有矛盾；<br>如果循环结束时没有发生上述两种情况，则输出无定解。</p>
<p><strong>输入格式</strong></p>
<p>输入包含多组测试数据。</p>
<p>每组测试数据，第一行包含两个整数 n 和 m。</p>
<p>接下来 m 行，每行包含一个不等式，不等式全部为小于关系。</p>
<p>当输入一行 0 0 时，表示输入终止。</p>
<p><strong>输出格式</strong></p>
<p>每组数据输出一个占一行的结果。</p>
<p>结果可能为下列三种之一：</p>
<ul>
<li>如果可以确定两两之间的关系，则输出 <code>Sorted sequence determined after t relations: yyy...y.</code>,其中<code>t</code>指迭代次数，<code>yyy...y</code>是指升序排列的所有变量。</li>
<li>如果有矛盾，则输出： <code>Inconsistency found after t relations.</code>，其中<code>t</code>指迭代次数。</li>
<li>如果没有矛盾，且不能确定两两之间的关系，则输出 <code>Sorted sequence cannot be determined.</code>。</li>
</ul>
<p><strong>数据范围</strong></p>
<p>$2≤n≤26，变量只可能为大写字母 A∼Z。$</p>
<p><strong>输入样例1</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line">A&lt;B</span><br><span class="line">A&lt;C</span><br><span class="line">B&lt;C</span><br><span class="line">C&lt;D</span><br><span class="line">B&lt;D</span><br><span class="line">A&lt;B</span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line">A&lt;B</span><br><span class="line">B&lt;A</span><br><span class="line"><span class="number">26</span> <span class="number">1</span></span><br><span class="line">A&lt;Z</span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例1</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sorted sequence determined after <span class="number">4</span> relations: ABCD.</span><br><span class="line">Inconsistency found after <span class="number">2</span> relations.</span><br><span class="line">Sorted sequence cannot be determined.</span><br></pre></td></tr></table></figure>

<p><strong>输入样例2</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">6</span></span><br><span class="line">A&lt;F</span><br><span class="line">B&lt;D</span><br><span class="line">C&lt;E</span><br><span class="line">F&lt;D</span><br><span class="line">D&lt;E</span><br><span class="line">E&lt;F</span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>输出样例2</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Inconsistency found after <span class="number">6</span> relations.</span><br></pre></td></tr></table></figure>

<p><strong>输入样例3</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line">A&lt;B</span><br><span class="line">B&lt;C</span><br><span class="line">C&lt;D</span><br><span class="line">D&lt;E</span><br><span class="line">E&lt;A</span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>输出样例3</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sorted sequence determined after <span class="number">4</span> relations: ABCDE.</span><br></pre></td></tr></table></figure>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>从前到后遍历给出的关系，如果能确定所有关系就直接输出当前次数和关系，如果前后矛盾则输出矛盾，如果得不到最终关系就输出得不到最终关系</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><strong>&#x3D;&#x3D;传递闭包&#x3D;&#x3D;</strong></p>
<p>已知<code>a&gt;b</code> <code>b&gt;c</code> 一定可以推出 <code>a&gt;c</code>，根据这个性质，我们可以在得到每个新的判断时进行传递，看看是否不满足原先已知的结论，如果不满足就会出现<code>i</code>和<code>i</code>的关系确定的结果</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> g[N][N], d[N][N]; <span class="comment">// 表示两个字母之间关系（前一个字母小于后一个字母）是否确定</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                d[i][j] |= d[i][k] &amp;&amp; d[k][j]; <span class="comment">// 如果有i-&gt;k k-&gt;j的边 那就加上i-&gt;j的边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (d[i][i]) <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 出现矛盾返回2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!d[i][j] &amp;&amp; !d[j][i])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 遍历所有数对 没确定返回0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 确定就返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get_min</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (!st[j] &amp;&amp; d[j][i]) <span class="comment">// 如果有没出现过的j比i还小的话说明i不是最小值</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="comment">// 否则i就是当前没出现过的数中的最小值</span></span><br><span class="line">            &#123;</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="type">int</span> type = <span class="number">0</span>, t; <span class="comment">// type表示目前关系未确定/确定/矛盾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> str[<span class="number">5</span>];</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="type">int</span> a = str[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>, b = str[<span class="number">2</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!type)</span><br><span class="line">            &#123;</span><br><span class="line">                g[a][b] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">floyd</span>();</span><br><span class="line">                type = <span class="built_in">check</span>();</span><br><span class="line">                <span class="keyword">if</span> (type) t = i; <span class="comment">// t记录经过几次才确定所有关系</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!type) <span class="built_in">puts</span>(<span class="string">&quot;Sorted sequence cannot be determined.&quot;</span>); <span class="comment">// 关系不确定</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;Inconsistency found after &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; relations.\n&quot;</span>; <span class="comment">// 矛盾</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 确定</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Sorted sequence determined after &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; relations: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; <span class="built_in">get_min</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="观光之旅"><a href="#观光之旅" class="headerlink" title="观光之旅"></a>观光之旅</h2><p><a href="https://www.acwing.com/problem/content/346/">原题链接</a></p>
<p>给定一张无向图，求图中一个至少包含 3 个点的环，环上的节点不重复，并且环上的边的长度之和最小。</p>
<p>该问题称为无向图的最小环问题。</p>
<p>你需要输出最小环的方案，若最小环不唯一，输出任意一个均可。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 N 和 M，表示无向图有 N 个点，M 条边。</p>
<p>接下来 M 行，每行包含三个整数 u，v，l，表示点 u 和点 v 之间有一条边，边长为 l。</p>
<p><strong>输出格式</strong></p>
<p>输出占一行，包含最小环的所有节点（按顺序输出），如果不存在则输出 No solution.。</p>
<p><strong>数据范围</strong></p>
<p>$1≤N≤100,$<br>$1≤M≤10000,$<br>$1≤l&lt;500$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">300</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">16</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">100</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">15</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>无向图的最小环裸题</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>假设环的形式是这样的：（ij均小于k）</p>
<img src="/posts/15c63d49/1.png" class>
<p>那么环的长度就是<code>d[i][j] + g[j][k] + g[k][i]</code>（d代表ij在图上的最短距离，g表示两点之间有边的话 边的长度)</p>
<p>用<code>pos[i][j] = k</code>记录<code>i</code>和<code>j</code>的最短路由k的状态转移，k是路径中编号最大的点</p>
<p>在floyd中循环每个k，如果<code>d[i][j] + g[j][k] + g[k][i]</code>比当前的最小环长度更小就更新一下</p>
<p>使用类似中序遍历的算法求出环中的字母</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> d[N][N], g[N][N];</span><br><span class="line"><span class="type">int</span> pos[N][N];</span><br><span class="line"><span class="type">int</span> path[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_path</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos[i][j] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似于中序遍历</span></span><br><span class="line">    <span class="type">int</span> k = pos[i][j];</span><br><span class="line">    <span class="built_in">get_path</span>(i, k);</span><br><span class="line">    path[cnt ++ ] = k;</span><br><span class="line">    <span class="built_in">get_path</span>(k, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) g[i][i] = <span class="number">0</span>; <span class="comment">// 避免统计自环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = INF;</span><br><span class="line">    <span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; k; j ++ )</span><br><span class="line">                <span class="keyword">if</span> ((ll)d[i][j] + g[j][k] + g[k][i] &lt; res) <span class="comment">// 一旦发现比原来的最短路还要短的路径就更新</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res = d[i][j] + g[j][k] + g[k][i]; <span class="comment">// 最短路长度</span></span><br><span class="line">                    <span class="comment">// 更新最短路中的点</span></span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                    path[cnt ++ ] = k;</span><br><span class="line">                    path[cnt ++ ] = i;</span><br><span class="line">                    <span class="built_in">get_path</span>(i, j);</span><br><span class="line">                    path[cnt ++ ] = j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新两点之间的距离 在更新完最小环之后更新所以不会对最小环有影响</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &gt; d[i][k] + d[k][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">                    pos[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == INF) <span class="built_in">puts</span>(<span class="string">&quot;No solution.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ ) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Floyd</tag>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>【图论】二分图</title>
    <url>/posts/7d098920.html</url>
    <content><![CDATA[<p>二分图，即可以将图中的所有顶点分层两个点集，每个点集内部没有边</p>
<p><strong>判定图为二分图的充要条件：有向连通图不含奇数环</strong></p>
<h2 id="1、染色法"><a href="#1、染色法" class="headerlink" title="1、染色法"></a>1、染色法</h2><p>可以解决二分图判断的问题</p>
<h3 id="步骤与基本思路"><a href="#步骤与基本思路" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>遍历图中每一个点，若该点未被染色，则遍历该点所相邻的点，相邻的点中未被染色的进行染色操作，已被染色的判断颜色是否合法，合法继续遍历，不合法退出</p>
<h3 id="染色法板子"><a href="#染色法板子" class="headerlink" title="染色法板子"></a>染色法板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!color[i]) <span class="comment">// 未被染色则开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c; <span class="comment">// 对该点进行染色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j]) <span class="comment">// 未被染色的点进行染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已染色的点判断是否合法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="2、匈牙利算法"><a href="#2、匈牙利算法" class="headerlink" title="2、匈牙利算法"></a>2、匈牙利算法</h2><p>可以解决最大匹配数的问题，也就是二分图的两个点集可以连多少条一一对应的边</p>
<h3 id="步骤与基本思路-1"><a href="#步骤与基本思路-1" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>（1）遍历第一个点集的所有点，每个点遍历之前要记得把第二个点集的状态清空</p>
<p>（2）依次遍历这些点相邻的点，若该点未被遍历过，则判断该点是否满足未与前面的点匹配过或前面与它匹配的点有其他的匹配方案，若满足任意条件则让现在的两点匹配，不满足则说明当前第一个点集的这个点没有匹配对象</p>
<h3 id="匈牙利算法板子"><a href="#匈牙利算法板子" class="headerlink" title="匈牙利算法板子"></a>匈牙利算法板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st); <span class="comment">// 清空第二个点集的状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="comment">// 若该点未被遍历过</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 该点是否满足 未被匹配过 or 匹配的第一个点集的点有其他成功匹配方案</span></span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x; <span class="comment">// 匹配现在的这两点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>【图论】判环问题</title>
    <url>/posts/77f9f026.html</url>
    <content><![CDATA[<p>（未更新完、做到相关题再更新相关部分</p>
<h1 id="无向图判断有无环并输出环上点"><a href="#无向图判断有无环并输出环上点" class="headerlink" title="无向图判断有无环并输出环上点"></a>无向图判断有无环并输出环上点</h1><p>例题：<a href="https://codeforces.com/contest/1873/problem/H">H. Mad City</a></p>
<p>利用变种拓扑排序，先把度为1的点存入队中，每次取出队头，遍历邻接点，再将该条边删除也就是将邻接点度数减一，直至队空，然后所有度数不为0的点都是在环上的点，输出即可</p>
<p><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line"></span><br><span class="line">    ind[x] ++, ind[y] ++ ;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function&lt;<span class="type">void</span>()&gt; topsort = [&amp;]()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (ind[i] == <span class="number">1</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- ind[v] == <span class="number">1</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">topsort</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">	<span class="keyword">if</span> (ind[i] &gt; <span class="number">1</span>) ans = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h1 id="有向图找最小-大环"><a href="#有向图找最小-大环" class="headerlink" title="有向图找最小&#x2F;大环"></a>有向图找最小&#x2F;大环</h1><p>利用并查集，每加一条边，判断当前这两个端点是否连通，如果不连通就更新他们的长度和父结点情况，如果这两个端点已经连通，那么加上这一条边一定能使得形成一个环，环的长度就是两个端点距离祖先结点的和再加一</p>
<p><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> last = fa[x];</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">        dist[x] += dist[last];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> aa = <span class="built_in">find</span>(a), bb = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aa == bb) ans = <span class="built_in">min</span>(ans, dist[a] + dist[b] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fa[a] = bb;</span><br><span class="line">        dist[a] = dist[b] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">func</span>(i, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>环</tag>
      </tags>
  </entry>
  <entry>
    <title>【图论】SPFA求负环</title>
    <url>/posts/33ca34cf.html</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>负环</strong>：环上权值之和是负数</p>
<p>求负环的常用方法 <strong>基于SPFA</strong></p>
<ol>
<li>统计每个点入队次数，如果某个点入队n次，则说明存在负环（完全等价于Bellman-Ford算法）</li>
<li>统计当前每个点的最短路中所包含的边数，如果某点的最短路包含的边数大于等于n，则说明存在负环</li>
</ol>
<p>玄学结论：当所有点的入队次数超过2n时，就认为图中有很大肯存在负环</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="虫洞"><a href="#虫洞" class="headerlink" title="虫洞"></a>虫洞</h2><p><a href="https://www.acwing.com/problem/content/906/">原题链接</a></p>
<p>农夫约翰在巡视他的众多农场时，发现了很多令人惊叹的虫洞。</p>
<p>虫洞非常奇特，它可以看作是一条 单向 路径，通过它可以使你回到过去的某个时刻（相对于你进入虫洞之前）。</p>
<p>农夫约翰的每个农场中包含 N 片田地，M 条路径（双向）以及 W 个虫洞。</p>
<p>现在农夫约翰希望能够从农场中的某片田地出发，经过一些路径和虫洞回到过去，并在他的出发时刻之前赶到他的出发地。</p>
<p>他希望能够看到出发之前的自己。</p>
<p>请你判断一下约翰能否做到这一点。</p>
<p>下面我们将给你提供约翰拥有的农场数量 F，以及每个农场的完整信息。</p>
<p>已知走过任何一条路径所花费的时间都不超过 10000 秒，任何虫洞将他带回的时间都不会超过 10000 秒。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 F，表示约翰共有 F 个农场。</p>
<p>对于每个农场，第一行包含三个整数 N,M,W。</p>
<p>接下来 M 行，每行包含三个整数 S,E,T，表示田地 S 和 E 之间存在一条路径，经过这条路径所花的时间为 T。</p>
<p>再接下来 W 行，每行包含三个整数 S,E,T，表示存在一条从田地 S 走到田地 E 的虫洞，走过这条虫洞，可以回到 T 秒之前。</p>
<p><strong>输出格式</strong></p>
<p>输出共 F行，每行输出一个结果。</p>
<p>如果约翰能够在出发时刻之前回到出发地，则输出 YES，否则输出 NO。</p>
<p><strong>数据范围</strong></p>
<p>$1≤F≤5$<br>$1≤N≤500,$<br>$1≤M≤2500,$<br>$1≤W≤200,$<br>$1≤T≤10000,$<br>$1≤S,E≤N$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>负环板题</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>跑一遍spfa</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">5210</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m1, m2;</span><br><span class="line"><span class="type">int</span> h[N], ne[M], e[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 更新次数一旦超过n就说明有负环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m1; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m2; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(a, b, -c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="观光奶牛"><a href="#观光奶牛" class="headerlink" title="观光奶牛"></a>观光奶牛</h2><p><a href="https://www.acwing.com/problem/content/363/">原题链接</a></p>
<p>给定一张 L 个点、P 条边的有向图，每个点都有一个权值 f[i]，每条边都有一个权值 t[i]。</p>
<p>求图中的一个环，使“环上各点的权值之和”除以“环上各边的权值之和”最大。</p>
<p>输出这个最大值。</p>
<p>注意：数据保证至少存在一个环。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 L 和 P。</p>
<p>接下来 L 行每行一个整数，表示 f[i]。</p>
<p>再接下来 P 行，每行三个整数 a，b，t[i]，表示点 a 和 b 之间存在一条边，边的权值为 t[i]。</p>
<p><strong>输出格式</strong></p>
<p>输出一个数表示结果，保留两位小数。</p>
<p><strong>数据范围</strong></p>
<p>$2≤L≤1000,$<br>$2≤P≤5000,$<br>$1≤f[i],t[i]≤1000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6.00</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出点权和边权，求一个环使得点权之和除以边权之和最大</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>求比值最大的问题 -&gt; <strong>&#x3D;&#x3D;01分数规划&#x3D;&#x3D;</strong> -&gt; <strong>二分</strong></p>
<p>首先确定边界值，答案一定在<code>[0, 1000)</code> 之间</p>
<p>每次取中点mid，如果图中存在一个环使得比值大于mid，则答案在mid和r之间，反之亦然</p>
<p>现在问题变成了如何判断是否存在一个比值大于mid的环？</p>
<p>判断：$\frac{\sum f_i}{\sum t_i}&gt;Mid$<br>化简：$\sum f_i-Mid*\sum t_i&gt;0$</p>
<p>在环上的点权我们可以任意加到边权上，对环不会有影响，假设我们将所有点权加到出边上，化简：$\sum (f_i-Mid*t_i)&gt;0$</p>
<p>现在将边权全看成$f_i-Mid*t_i$</p>
<p>问题转换成了：图中是否存在一个正环</p>
<p>求最长路即可</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> wf[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], wt[M], idx;</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, wt[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 所有点存进队列</span></span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &lt; dist[t] + wf[t] - mid * wt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + wf[t] - mid * wt[i]; <span class="comment">// 更新最长距离</span></span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 更新次数超过n就说明有正环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; wf[i]; <span class="comment">// 记录点权</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-4</span>) <span class="comment">// 误差</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单词环"><a href="#单词环" class="headerlink" title="单词环"></a>单词环</h2><p><a href="https://www.acwing.com/problem/content/1167/">原题链接</a></p>
<p>我们有 n 个字符串，每个字符串都是由 a∼z 的小写英文字母组成的。</p>
<p>如果字符串 A 的结尾两个字符刚好与字符串 B 的开头两个字符相匹配，那么我们称 A 与 B 能够相连（注意：A 能与 B 相连不代表 B 能与 A 相连）。</p>
<p>我们希望从给定的字符串中找出一些，使得它们首尾相连形成一个环串（一个串首尾相连也算），我们想要使这个环串的平均长度最大。</p>
<p>如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ababc</span><br><span class="line">bckjaca</span><br><span class="line">caahoynaab</span><br></pre></td></tr></table></figure>
<p>第一个串能与第二个串相连，第二个串能与第三个串相连，第三个串能与第一个串相连，我们按照此顺序相连，便形成了一个环串，长度为 5+7+10&#x3D;22（重复部分算两次），总共使用了 3 个串，所以平均长度是 223≈7.33。</p>
<p><strong>输入格式</strong></p>
<p>本题有多组数据。</p>
<p>每组数据的第一行，一个整数 n，表示字符串数量；</p>
<p>接下来 n 行，每行一个长度小于等于 1000 的字符串。</p>
<p>读入以 n&#x3D;0 结束。</p>
<p><strong>输出格式</strong></p>
<p>若不存在环串，输出”No solution”，否则输出最长的环串的平均长度。</p>
<p>只要答案与标准答案的差不超过 0.01，就视为答案正确。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤105$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">intercommunicational</span><br><span class="line">alkylbenzenesulfonate</span><br><span class="line">tetraiodophenolphthalein</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">21.66</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>n个字符串，如果a的末尾两个字符和b的开头相同则能相连，求能构成的环的平均长度最大值</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>把每个字符串的首位两个字母看做一个点，比如说样例可以这样建图：</p>
<img src="/posts/33ca34cf/1.png" class>
<p>答案就变成了求$\frac{\sum w_i}{\sum 1}$的最大值</p>
<p>答案在<code>(0, 1000)</code>之内，二分做，类似观光奶牛</p>
<p>最终判断式为：$\sum w_i - Mid*\sum 1&gt;0$</p>
<p>判断有没有解直接把 <code>Mid = 0</code> 代入即可，因为如果等于0都不能满足的话大于0就更不会满足了</p>
<p>于是成功TLE，用一下玄学优化</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">700</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">676</span>; i ++ ) <span class="comment">// 所有点存入队列</span></span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &lt; dist[t] + w[i] - mid)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i] - mid;</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (++ count &gt; <span class="number">10000</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 次数过多直接返回（玄学可能失败</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= N) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这个是保证一定正确的</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1010</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">if</span> (len &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 用类似于26进制的方法存储</span></span><br><span class="line">                <span class="type">int</span> left = (str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> right = (str[len - <span class="number">2</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[len - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="built_in">add</span>(left, right, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(<span class="number">0</span>)) <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>); <span class="comment">// 判断是否有解</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">while</span> (r - l &gt; <span class="number">1e-4</span>) <span class="comment">// 误差</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>SPFA</tag>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>【图论】图的存储与搜索</title>
    <url>/posts/3f91b69e.html</url>
    <content><![CDATA[<h1 id="一、图的存储方式"><a href="#一、图的存储方式" class="headerlink" title="一、图的存储方式"></a>一、图的存储方式</h1><p>首先，树是一种特殊的图，因此树的存储类似，这里只记录图的存储。</p>
<p>其次，无向图又是一种特殊的有向图。</p>
<p>无向图中的 a—b 相当于有向图中的 a-&gt;b b-&gt;a，因此这里只记录有向图的存储。</p>
<h2 id="1、邻接矩阵"><a href="#1、邻接矩阵" class="headerlink" title="1、邻接矩阵"></a>1、邻接矩阵</h2><p>简单来说就是开个二维数组g[N][N]。</p>
<ul>
<li>无权图中，g就是个bool值，ab之间有边，则g[a][b] &#x3D; true， 否则为false。</li>
<li>有权图中，g为两条边之间的权重。</li>
</ul>
<p>出现重边时，邻接矩阵只保留一条边（一般是保留最短的那条）。</p>
<p>空间复杂度O(n^2)，经验来看1e5会爆，只适合存储稠密图，稀疏图用邻接表。</p>
<h2 id="2、邻接表"><a href="#2、邻接表" class="headerlink" title="2、邻接表"></a>2、邻接表</h2><h3 id="（1）链式前向星"><a href="#（1）链式前向星" class="headerlink" title="（1）链式前向星"></a>（1）链式前向星</h3><ul>
<li>h[N]：头结点</li>
<li>e[N]：头结点可以到达哪些点</li>
<li>ne[N]：起到指针的作用 表示e[i]的下一个结点是什么位置</li>
<li>idx：当前存储到了什么位置</li>
</ul>
<h3 id="链式前向星板子"><a href="#链式前向星板子" class="headerlink" title="链式前向星板子"></a><strong>链式前向星板子</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], w[N], idx;</span><br><span class="line"><span class="comment">// 首先一定要初始化h</span></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 加入 a -&gt; b 这条边，权重是w</span></span><br><span class="line">    e[idx] = b, w[idx] = w, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="（2）vector存二维数组"><a href="#（2）vector存二维数组" class="headerlink" title="（2）vector存二维数组"></a>（2）vector存二维数组</h3><p>vector<int> g[N] 的方式来存储。</int></p>
<h3 id="vector存二维数组板子"><a href="#vector存二维数组板子" class="headerlink" title="vector存二维数组板子"></a><strong>vector存二维数组板子</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 加入 a -&gt; b 这条边</span></span><br><span class="line">    g[a].<span class="built_in">pushforward</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 如果需要增加权重，可以考虑把vector<int>换成vector&lt;pair&lt;int, int&gt;&gt;</int></p>
<hr>
<h1 id="二、图的搜索与遍历"><a href="#二、图的搜索与遍历" class="headerlink" title="二、图的搜索与遍历"></a>二、图的搜索与遍历</h1><h2 id="1、深度优先搜索（DFS）"><a href="#1、深度优先搜索（DFS）" class="headerlink" title="1、深度优先搜索（DFS）"></a>1、深度优先搜索（DFS）</h2><p>尽可能往深搜，直到前面没有能继续搜索的点了才会回溯，回溯时也是一边回溯一边看目前回溯到的点有没有能接着往深搜的，直到遍历完整个图。</p>
<p>空间复杂度O(n)，相较于BFS有绝对优势。</p>
<h3 id="深度优先搜索BFS板子"><a href="#深度优先搜索BFS板子" class="headerlink" title="深度优先搜索BFS板子"></a><strong>深度优先搜索BFS板子</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ( 遍历完毕 )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; 打印所需结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( 遍历整个图 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) <span class="comment">// 当前结点未被遍历过</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i); <span class="comment">// 遍历下一层</span></span><br><span class="line">            <span class="comment">// 是否恢复现场依情况而定 如果遍历整个图就不需要恢复现场</span></span><br><span class="line">            st[i] = <span class="literal">false</span>; <span class="comment">// 恢复当前结点的遍历情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="2、宽度优先搜索（BFS）"><a href="#2、宽度优先搜索（BFS）" class="headerlink" title="2、宽度优先搜索（BFS）"></a>2、宽度优先搜索（BFS）</h2><p>按层搜索，每一轮搜索到的点和起始点的距离都是一样的。（比如说第一次搜索到的点距离起始点的长度都是1，第二次搜索到的点距离起始点的长度都是2，以此类推）</p>
<p>正是因为这个特性，BFS可以解决一部分权重为1的最短路问题。</p>
<p>空间复杂度O(2^n)。</p>
<h3 id="宽度优先搜索BFS板子"><a href="#宽度优先搜索BFS板子" class="headerlink" title="宽度优先搜索BFS板子"></a><strong>宽度优先搜索BFS板子</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>( 第一个数 );</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) <span class="comment">// q不空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取出队头并删去</span></span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> ( 遍历与t相邻的点 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[i])</span><br><span class="line">            &#123;</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(i); <span class="comment">// 该点没遍历过就把它加到队列中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="BFS应用实例-—-拓补序列"><a href="#BFS应用实例-—-拓补序列" class="headerlink" title="BFS应用实例 — 拓补序列"></a>BFS应用实例 — 拓补序列</h3><p>拓补序列：对于所有有向边 x-&gt;y，序列中总存在x在y前面，该序列为拓补序列</p>
<p>换句话说序列中所有边都是从前指向后。</p>
<p>如果一个图存在环，就一定不存在拓补序列。</p>
<p><strong>一个有向无环图一定存在拓补序列，有向无换图又被称作拓补图。</strong></p>
<p>任何一个入度为0的点都可以作为拓补序列的起点</p>
<p>任何一个出度为0的点都可以作为拓补序列的终点</p>
<h3 id="拓补序列板子"><a href="#拓补序列板子" class="headerlink" title="拓补序列板子"></a>拓补序列板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> ( 找到所有入度为<span class="number">0</span>的点i ) q.<span class="built_in">push</span>(i); <span class="comment">// 把入度为0的点存进q</span></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>(); <span class="comment">// 指向队头</span></span><br><span class="line">        <span class="keyword">for</span> ( 枚举t的所有出边 t-&gt;j )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 删掉t-&gt;j这条边 也就是让j的入度-1</span></span><br><span class="line">            d[j] -- ;</span><br><span class="line">            <span class="keyword">if</span> (d[j] == <span class="number">0</span>) q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>【图论】单源最短路</title>
    <url>/posts/24fd3c3d.html</url>
    <content><![CDATA[<h1 id="单源最短路的建图方式"><a href="#单源最短路的建图方式" class="headerlink" title="单源最短路的建图方式"></a>单源最短路的建图方式</h1><p>最短路问题可以分为以下两类：</p>
<ul>
<li>边权非负——朴素Dijkstra、堆优化Dijkstra</li>
<li>有负权边——Bellman-Ford、SPFA</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="热浪"><a href="#热浪" class="headerlink" title="热浪"></a>热浪</h3><p><a href="https://www.acwing.com/problem/content/1131/">原题链接</a>   </p>
<p>德克萨斯纯朴的民众们这个夏天正在遭受巨大的热浪！！！</p>
<p>他们的德克萨斯长角牛吃起来不错，可是它们并不是很擅长生产富含奶油的乳制品。</p>
<p>农夫John此时身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。</p>
<p>John已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。</p>
<p>这些路线包括起始点和终点一共有 T 个城镇，为了方便标号为 1 到 T。</p>
<p>除了起点和终点外的每个城镇都由 双向道路 连向至少两个其它的城镇。</p>
<p>每条道路有一个通过费用（包括油费，过路费等等）。</p>
<p>给定一个地图，包含 C 条直接连接 2 个城镇的道路。</p>
<p>每条道路由道路的起点 Rs，终点 Re 和花费 Ci 组成。</p>
<p>求从起始的城镇 Ts 到终点的城镇 Te 最小的总费用。</p>
<p><strong>输入格式</strong></p>
<p>第一行: 4 个由空格隔开的整数: T,C,Ts,Te;</p>
<p>第 2 到第 C+1 行: 第 i+1 行描述第 i 条道路，包含 3 个由空格隔开的整数: Rs,Re,Ci。</p>
<p><strong>输出格式</strong></p>
<p>一个单独的整数表示从 Ts 到 Te 的最小总费用。</p>
<p>数据保证至少存在一条道路。</p>
<p><strong>数据范围</strong></p>
<p>$1≤T≤2500$,<br>$1≤C≤6200$,<br>$1≤Ts,Te,Rs,Re≤T$,<br>$1≤Ci≤1000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">11</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">7</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">6</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p><del>板题</del></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>写了个SPFA和堆优化的Dijkstra，详见代码</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2510</span>, M = <span class="number">6200</span> * <span class="number">2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], q[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span> <span class="comment">// SPFA算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(S);</span><br><span class="line">    st[S] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> <span class="comment">// 堆优化Dijkstra</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, S&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> distance = t.first, ver = t.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo 下面的选一个就可以 //</span></span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dist[T] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信使"><a href="#信使" class="headerlink" title="信使"></a>信使</h3><p><a href="https://www.acwing.com/problem/content/1130/">原题链接</a></p>
<p>战争时期，前线有 n 个哨所，每个哨所可能会与其他若干个哨所之间有通信联系。</p>
<p>信使负责在哨所之间传递信息，当然，这是要花费一定时间的（以天为单位）。</p>
<p>指挥部设在第一个哨所。</p>
<p>当指挥部下达一个命令后，指挥部就派出若干个信使向与指挥部相连的哨所送信。</p>
<p>当一个哨所接到信后，这个哨所内的信使们也以同样的方式向其他哨所送信。信在一个哨所内停留的时间可以忽略不计。</p>
<p>直至所有 n 个哨所全部接到命令后，送信才算成功。</p>
<p>因为准备充足，每个哨所内都安排了足够的信使（如果一个哨所与其他 k 个哨所有通信联系的话，这个哨所内至少会配备 k 个信使）。</p>
<p>现在总指挥请你编一个程序，计算出完成整个送信过程最短需要多少时间。</p>
<p><strong>输入格式</strong></p>
<p>第 1 行有两个整数 n 和 m，中间用 1 个空格隔开，分别表示有 n 个哨所和 m 条通信线路。</p>
<p>第 2 至 m+1 行：每行三个整数 i、j、k，中间用 1 个空格隔开，表示第 i 个和第 j 个哨所之间存在 双向 通信线路，且这条线路要花费 k 天。</p>
<p><strong>输出格式</strong></p>
<p>一个整数，表示完成整个送信过程的最短时间。</p>
<p>如果不是所有的哨所都能收到信，就输出-1。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤100,$<br>$1≤m≤200,$<br>$1≤k≤1000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>建图，指挥部在1</p>
<p>每个点可以给相邻点送信，求所有点都收到信的最短时间</p>
<p>如果有收不到信的，输出-1</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>对于每个点来说：接收到信的时间等于他到指挥部的最短距离</p>
<p>因此可以分别求每个点的最短路径，求所有最短路径的最大值</p>
<p>如果有最短路径是正无穷，说明不能传过去，输出-1</p>
<p>下方代码使用Floyd算法</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) d[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        d[a][b] = d[b][a] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxx = *<span class="built_in">max_element</span>(d[<span class="number">1</span>] + <span class="number">1</span>, d[<span class="number">1</span>] + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (maxx == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="香甜的黄油"><a href="#香甜的黄油" class="headerlink" title="香甜的黄油"></a>香甜的黄油</h3><p><a href="https://www.acwing.com/problem/content/1129/">原题链接</a></p>
<p>农夫John发现了做出全威斯康辛州最甜的黄油的方法：糖。</p>
<p>把糖放在一片牧场上，他知道 N 只奶牛会过来舔它，这样就能做出能卖好价钱的超甜黄油。</p>
<p>当然，他将付出额外的费用在奶牛上。</p>
<p>农夫John很狡猾，就像以前的巴甫洛夫，他知道他可以训练这些奶牛，让它们在听到铃声时去一个特定的牧场。</p>
<p>他打算将糖放在那里然后下午发出铃声，以至他可以在晚上挤奶。</p>
<p>农夫John知道每只奶牛都在各自喜欢的牧场（一个牧场不一定只有一头牛）。</p>
<p>给出各头牛在的牧场和牧场间的路线，找出使所有牛到达的路程和最短的牧场（他将把糖放在那）。</p>
<p>数据保证至少存在一个牧场和所有牛所在的牧场连通。</p>
<p><strong>输入格式</strong></p>
<p>第一行: 三个数：奶牛数 N，牧场数 P，牧场间道路数 C。</p>
<p>第二行到第 N+1 行: 1 到 N 头奶牛所在的牧场号。</p>
<p>第 N+2 行到第 N+C+1 行：每行有三个数：相连的牧场A、B，两牧场间距 D，当然，连接是双向的。</p>
<p><strong>输出格式</strong></p>
<p>共一行，输出奶牛必须行走的最小的距离和。</p>
<p><strong>数据范围</strong></p>
<p>$1≤N≤500,$<br>$2≤P≤800,$<br>$1≤C≤1450,$<br>$1≤D≤255$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>若干头牛分别在不同牧场，找到一个牧场使所有牛到该牧场的总距离之和最小</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>求以每个点为起点，其余点到该点的最短路之和</p>
<p>输出最小值</p>
<p>以下代码为堆优化Dijkstra</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">810</span>, M = <span class="number">3000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, p;</span><br><span class="line"><span class="type">int</span> id[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, start&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> distance = t.first, ver = t.second;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历奶牛不是遍历牧场</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = id[i];</span><br><span class="line">        <span class="keyword">if</span> (dist[j] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        res += dist[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; id[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存图</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取所有res中的最小值</span></span><br><span class="line">    <span class="type">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; i ++ ) res = <span class="built_in">min</span>(res, <span class="built_in">dijkstra</span>(i));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小花费"><a href="#最小花费" class="headerlink" title="最小花费"></a>最小花费</h3><p><a href="https://www.acwing.com/problem/content/1128/">原题链接</a></p>
<p>在 n 个人中，某些人的银行账号之间可以互相转账。</p>
<p>这些人之间转账的手续费各不相同。</p>
<p>给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 A 最少需要多少钱使得转账后 B 收到 100 元。</p>
<p><strong>输入格式</strong></p>
<p>第一行输入两个正整数 n,m，分别表示总人数和可以互相转账的人的对数。</p>
<p>以下 m 行每行输入三个正整数 x,y,z，表示标号为 x 的人和标号为 y 的人之间互相转账需要扣除 z% 的手续费 ( z&lt;100 )。</p>
<p>最后一行输入两个正整数 A,B。</p>
<p>数据保证 A 与 B 之间可以直接或间接地转账。</p>
<p><strong>输出格式</strong></p>
<p>输出 A 使得 B 到账 100 元最少需要的总费用。</p>
<p>精确到小数点后 8 位。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤2000,$<br>$m≤105$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">103.07153164</span></span><br></pre></td></tr></table></figure>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>n个人互相转账，给出每两个人转账的手续费，询问A最少发出去多少钱使得B可以收到100</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>将每个人看做点，权重是能传过去的百分比（比如说手续费3%，这条边的权重就是0.97），问题就变成了<br>$100&#x3D;d(A)<em>w_1</em>w_2<em>…</em>w_n$<br>想让 $d(A)$ 最小，就要让 $w_i$ 最大<br>所以就是求最短路算法（但是是让权重之积最大）</p>
<p>下方代码为朴素版Dijkstra</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">double</span> g[N][N];</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &lt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">max</span>(dist[j], dist[t] * g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="type">double</span> z = (<span class="number">100.0</span> - c) / <span class="number">100</span>;</span><br><span class="line">        g[a][b] = g[b][a] = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; S &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; <span class="number">100</span> / dist[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最优乘车"><a href="#最优乘车" class="headerlink" title="最优乘车"></a>最优乘车</h3><p><a href="https://www.acwing.com/problem/content/922/">原题链接</a></p>
<p>H 城是一个旅游胜地，每年都有成千上万的人前来观光。</p>
<p>为方便游客，巴士公司在各个旅游景点及宾馆，饭店等地都设置了巴士站并开通了一些单程巴士线路。</p>
<p>每条单程巴士线路从某个巴士站出发，依次途经若干个巴士站，最终到达终点巴士站。</p>
<p>一名旅客最近到 H 城旅游，他很想去 S 公园游玩，但如果从他所在的饭店没有一路巴士可以直接到达 S 公园，则他可能要先乘某一路巴士坐几站，再下来换乘同一站台的另一路巴士，这样换乘几次后到达 S 公园。</p>
<p>现在用整数 1,2,…N 给 H 城的所有的巴士站编号，约定这名旅客所在饭店的巴士站编号为 1，S 公园巴士站的编号为 N。</p>
<p>写一个程序，帮助这名旅客寻找一个最优乘车方案，使他在从饭店乘车到 S 公园的过程中换乘的次数最少。</p>
<p><strong>输入格式</strong></p>
<p>第一行有两个数字 M 和 N，表示开通了 M 条单程巴士线路，总共有 N 个车站。</p>
<p>从第二行到第 M+1 行依次给出了第 1 条到第 M 条巴士线路的信息，其中第 i+1 行给出的是第 i 条巴士线路的信息，从左至右按运行顺序依次给出了该线路上的所有站号，相邻两个站号之间用一个空格隔开。</p>
<p><strong>输出格式</strong></p>
<p>共一行，如果无法乘巴士从饭店到达 S 公园，则输出 NO，否则输出最少换乘次数，换乘次数为 0 表示不需换车即可到达。</p>
<p><strong>数据范围</strong></p>
<p>$1≤M≤100,$<br>$2≤N≤500$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给出多条公交车线路，求从起点到终点最少的换乘次数是多少</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>这题的难度在建图上，如果有一条线路是 1-&gt;3-&gt;5-&gt;7，从1开始坐，不管做到3还是5还是7，都不需要换乘，因此可以将1向后面的所有点都连一条边</p>
<p>建完图直接BFS即可</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">bool</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> stop[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[t][i] &amp;&amp; dist[i] &gt; dist[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, line);</span><br><span class="line">        <span class="function">stringstream <span class="title">ssin</span><span class="params">(line)</span></span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, p;</span><br><span class="line">        <span class="keyword">while</span> (ssin &gt;&gt; p) stop[cnt ++ ] = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; cnt; k ++ )</span><br><span class="line">                g[stop[j]][stop[k]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">max</span>(dist[n] - <span class="number">1</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="昂贵的聘礼"><a href="#昂贵的聘礼" class="headerlink" title="昂贵的聘礼"></a>昂贵的聘礼</h3><p><a href="https://www.acwing.com/problem/content/905/">原题链接</a></p>
<p>年轻的探险家来到了一个印第安部落里。</p>
<p>在那里他和酋长的女儿相爱了，于是便向酋长去求亲。</p>
<p>酋长要他用 10000 个金币作为聘礼才答应把女儿嫁给他。</p>
<p>探险家拿不出这么多金币，便请求酋长降低要求。</p>
<p>酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要 8000 金币。如果你能够弄来他的水晶球，那么只要 5000 金币就行了。”</p>
<p>探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。</p>
<p>探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。</p>
<p>不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。</p>
<p>探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。</p>
<p>另外他要告诉你的是，在这个部落里，等级观念十分森严。</p>
<p>地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。</p>
<p>他是一个外来人，所以可以不受这些限制。</p>
<p>但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。</p>
<p>因此你需要在考虑所有的情况以后给他提供一个最好的方案。</p>
<p>为了方便起见，我们把所有的物品从 1 开始进行编号，酋长的允诺也看作一个物品，并且编号总是 1。</p>
<p>每个物品都有对应的价格 P，主人的地位等级 L，以及一系列的替代品 Ti 和该替代品所对应的”优惠” Vi。</p>
<p>如果两人地位等级差距超过了 M，就不能”间接交易”。</p>
<p>你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p>
<p><strong>输入格式</strong></p>
<p>输入第一行是两个整数 M，N，依次表示地位等级差距限制和物品的总数。</p>
<p>接下来按照编号从小到大依次给出了 N 个物品的描述。</p>
<p>每个物品的描述开头是三个非负整数 P、L、X，依次表示该物品的价格、主人的地位等级和替代品总数。</p>
<p>接下来 X 行每行包括两个整数 T 和 V，分别表示替代品的编号和”优惠价格”。</p>
<p><strong>输出格式</strong></p>
<p>输出最少需要的金币数。</p>
<p><strong>数据范围</strong></p>
<p>$1≤N≤100,$<br>$1≤P≤10000,$<br>$1≤L,M≤N,$<br>$0≤X&lt;N$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">10000</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">8000</span></span><br><span class="line"><span class="number">3</span> <span class="number">5000</span></span><br><span class="line"><span class="number">1000</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">200</span></span><br><span class="line"><span class="number">3000</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">200</span></span><br><span class="line"><span class="number">50</span> <span class="number">2</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5250</span></span><br></pre></td></tr></table></figure>
<h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>有个人想娶酋长的女儿，酋长需要指定数量金钱的聘礼，或者拿一样东西和少一点的金钱替代，这样东西的所有者需要指定的金钱换这样东西，或者拿另一样东西和少一点的金钱代替，以此类推…同时，所有者阶级超过指定数字的不能间接交易，现在给出所有东西的价值、替代方式和所有者阶级，求这个人最少用多少钱能娶到酋长的女儿</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>题目很难读懂，读懂后发现难点还是在建图上，我们把每样物品看作一个点，根据样例可以建出以下图：</p>
<img src="/posts/24fd3c3d/1.png" class>
<p>此时设置一个<strong>虚拟源点</strong>，所有情况都从虚拟源点开始，得到以下图：</p>
<img src="/posts/24fd3c3d/2.png" class>
<p>从虚拟源点开始求到点1的最短路即可</p>
<p>那么阶级问题怎么考虑呢？</p>
<p>注意到阶级最高只有100，如果阶级限制是1的话，最多也只有100种划分情况，所以直接枚举所有的阶级划分就可以了</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N][N], level[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> down, <span class="type">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) <span class="comment">// 更新所有在阶级区间范围内且与t有邻边的点</span></span><br><span class="line">            <span class="keyword">if</span> (w[t][j] != <span class="number">0x3f3f3f3f</span> &amp;&amp; level[j] &gt;= down &amp;&amp; level[j] &lt;= up)</span><br><span class="line">                dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + w[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存图</span></span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) w[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> price, cnt;</span><br><span class="line">        cin &gt;&gt; price &gt;&gt; level[i] &gt;&gt; cnt;</span><br><span class="line">        w[<span class="number">0</span>][i] = <span class="built_in">min</span>(price, w[<span class="number">0</span>][i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cnt -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> id, cost;</span><br><span class="line">            cin &gt;&gt; id &gt;&gt; cost;</span><br><span class="line">            w[id][i] = <span class="built_in">min</span>(w[id][i], cost);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = level[<span class="number">1</span>] - m; i &lt;= level[<span class="number">1</span>]; i ++ )</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">dijkstra</span>(i, i + m));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="单源最短路的综合应用"><a href="#单源最短路的综合应用" class="headerlink" title="单源最短路的综合应用"></a>单源最短路的综合应用</h1><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="新年好"><a href="#新年好" class="headerlink" title="新年好"></a>新年好</h3><p><a href="https://www.acwing.com/problem/content/1137/">原题链接</a></p>
<p>重庆城里有 n 个车站，m 条 双向 公路连接其中的某些车站。</p>
<p>每两个车站最多用一条公路连接，从任何一个车站出发都可以经过一条或者多条公路到达其他车站，但不同的路径需要花费的时间可能不同。</p>
<p>在一条路径上花费的时间等于路径上所有公路需要的时间之和。</p>
<p>佳佳的家在车站 1，他有五个亲戚，分别住在车站 a,b,c,d,e。</p>
<p>过年了，他需要从自己的家出发，拜访每个亲戚（顺序任意），给他们送去节日的祝福。</p>
<p>怎样走，才需要最少的时间？</p>
<p><strong>输入格式</strong></p>
<p>第一行：包含两个整数 n,m，分别表示车站数目和公路数目。</p>
<p>第二行：包含五个整数 a,b,c,d,e，分别表示五个亲戚所在车站编号。</p>
<p>以下 m 行，每行三个整数 x,y,t，表示公路连接的两个车站编号和时间。</p>
<p><strong>输出格式</strong></p>
<p>输出仅一行，包含一个整数 T，表示最少的总时间。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤50000,$<br>$1≤m≤105,$<br>$1&lt;a,b,c,d,e≤n,$<br>$1≤x,y≤n,$<br>$1≤t≤100$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>
<h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><p>找到一条至少经过指定五个点的最短路径</p>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>我们只关心必须要经过的五个点，其他点有没有经过不重要</p>
<p>先用Dijkstra算出每两个点之间的最短距离，然后枚举五个点的所有情况取最小值即可</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[<span class="number">6</span>][N];</span><br><span class="line"><span class="type">int</span> source[<span class="number">6</span>];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> dist[])</span> <span class="comment">// 堆优化Dijkstra</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, N * <span class="number">4</span>); <span class="comment">// 因为dist大小不固定所以不能用sizeof</span></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, start&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> start, <span class="type">int</span> distance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; <span class="number">5</span>) <span class="keyword">return</span> distance;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> next = source[i];</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(u + <span class="number">1</span>, i, distance + dist[start][next]));</span><br><span class="line">            st[i] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    source[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++ ) cin &gt;&gt; source[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>; i ++ ) <span class="built_in">dijkstra</span>(source[i], dist[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通信线路"><a href="#通信线路" class="headerlink" title="通信线路"></a>通信线路</h3><p><a href="https://www.acwing.com/problem/content/342/">原题链接</a></p>
<p>在郊区有 N 座通信基站，P 条 双向 电缆，第 i 条电缆连接基站 Ai 和 Bi。</p>
<p>特别地，1 号基站是通信公司的总站，N 号基站位于一座农场中。</p>
<p>现在，农场主希望对通信线路进行升级，其中升级第 i 条电缆需要花费 Li。</p>
<p>电话公司正在举行优惠活动。</p>
<p>农产主可以指定一条从 1 号基站到 N 号基站的路径，并指定路径上不超过 K 条电缆，由电话公司免费提供升级服务。</p>
<p>农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。</p>
<p>求至少用多少钱可以完成升级。</p>
<p><strong>输入格式</strong></p>
<p>第 1 行：三个整数 N，P，K。</p>
<p>第 2..P+1 行：第 i+1 行包含三个整数 Ai,Bi,Li。</p>
<p><strong>输出格式</strong></p>
<p>包含一个整数表示最少花费。</p>
<p>若 1 号基站与 N 号基站之间不存在路径，则输出 −1。</p>
<p><strong>数据范围</strong></p>
<p>$0≤K&lt;N≤1000,$<br>$1≤P≤10000,$<br>$1≤Li≤1000000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h4><p>任选一条从 1 到 N 的路径，公司可以免费升级k条路线，只需要支付除了这k条路线之外的最大值，求这个值的最小值</p>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>一条路线的权重可以直接理解成第k+1长的边权，如果边数小于等于k，则该路线的权重是0</p>
<p>于是想到 **&#x3D;&#x3D;二分&#x3D;&#x3D;**（使用二分的条件是所求的答案是某个分界点，分界点的一边满足性质，另一边不满足性质）</p>
<p>对于我们所求的答案x，性质为从1到N的路线上大于x的边数小于等于k，大于x的情况满足性质，小于x的情况不满足性质</p>
<p>如何来判断呢？</p>
<p>将大于x的边权设为1，其余设为0，那么大于x的边数就等于路径长度</p>
<p>于是问题就转化成了边权为0&#x2F;1的最短路问题 -&gt; <strong>&#x3D;&#x3D;双端队列&#x3D;&#x3D;</strong></p>
<p>（细节问题：注意二分边界是0到1e6+1，因为如果定为1e6的话，无解和解为1e6的情况都会返回1e6）</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[t]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i], x = w[i] &gt; bound;</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + x)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + x;</span><br><span class="line">                <span class="keyword">if</span> (!x) q.<span class="built_in">push_front</span>(j);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[n] &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">1e6</span> + <span class="number">1</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="道路与航线"><a href="#道路与航线" class="headerlink" title="道路与航线"></a>道路与航线</h3><p><a href="https://www.acwing.com/problem/content/344/">原题链接</a></p>
<p>农夫约翰正在一个新的销售区域对他的牛奶销售方案进行调查。</p>
<p>他想把牛奶送到 T 个城镇，编号为 1∼T。</p>
<p>这些城镇之间通过 R 条道路 (编号为 1 到 R) 和 P 条航线 (编号为 1 到 P) 连接。</p>
<p>每条道路 i 或者航线 i 连接城镇 Ai 到 Bi，花费为 Ci。</p>
<p>对于道路，$0≤C_i≤10000$；然而航线的花费很神奇，花费 $C_i$ 可能是负数$(−10,000≤C_i≤10000)$。</p>
<p>道路是双向的，可以从 $A_i$ 到 $B_i$，也可以从 $B_i$ 到 $A_i$，花费都是 $C_i$。</p>
<p>然而航线与之不同，只可以从 $A_i$ 到 $B_i$。</p>
<p>事实上，由于最近恐怖主义太嚣张，为了社会和谐，出台了一些政策：保证如果有一条航线可以从 $A_i$ 到 $B_i$，那么保证不可能通过一些道路和航线从 $B_i$ 回到 $A_i$。</p>
<p>由于约翰的奶牛世界公认十分给力，他需要运送奶牛到每一个城镇。</p>
<p>他想找到从发送中心城镇 S 把奶牛送到每个城镇的最便宜的方案。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含四个整数 T,R,P,S。</p>
<p>接下来 R 行，每行包含三个整数（表示一个道路）Ai,Bi,Ci。</p>
<p>接下来 P 行，每行包含三个整数（表示一条航线）Ai,Bi,Ci。</p>
<p><strong>输出格式</strong></p>
<p>第 1..T 行：第 i 行输出从 S 到达城镇 i 的最小花费，如果不存在，则输出 NO PATH。</p>
<p><strong>数据范围</strong></p>
<p>$1≤T≤25000,$<br>$1≤R,P≤50000,$<br>$1≤Ai,Bi,S≤T$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">-100</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">-100</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">-10</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NO PATH</span><br><span class="line">NO PATH</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">-95</span></span><br><span class="line"><span class="number">-100</span></span><br></pre></td></tr></table></figure>
<h4 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h4><p>图中有两种路线：</p>
<ul>
<li>道路：无向边，边权为正</li>
<li>航线：有向边，边权可正可负</li>
</ul>
<p>问把牛奶送到每个点的最短路径</p>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>首先看到边权有负会想到spfa，但是这个做法会被卡</p>
<p>由题意可知，如果 a 到 b 有航线，那 b 就不可能到 a ，说明 a b 间也不存在道路</p>
<p>根据这个特点可以用 <strong>&#x3D;&#x3D;DFS&#x3D;&#x3D;</strong> 把整张图分成几个块，两个不同的块之间只有航线相连，每个块均连通（因此每个块中都不存在航线，因为航线连接的两个点是单向的），因为每个块中只有道路也就是只有正向边，所以每个块内可以用 <strong>&#x3D;&#x3D;Dijkstra&#x3D;&#x3D;</strong> ，块与块之间是有向边，所以可以用 <strong>&#x3D;&#x3D;拓扑序列&#x3D;&#x3D;</strong> 做</p>
<p>具体步骤：</p>
<ol>
<li>先输入所有双向道路，然后DFS出所有连通块，记录两个数组：<ul>
<li><code>id[]</code>存储每个点属于哪个连通块</li>
<li><code>vector&lt;int&gt; block[]</code>存储每个连通块有哪些点</li>
</ul>
</li>
<li>输入所有航线，统计出每个连通块入度</li>
<li>按照拓扑序列依次出了每个连通块，先将所有入度为0的连通块编号加入队列中</li>
<li>每次从队头取出一个连通块的编号bid</li>
<li>将该block[bid]中的所有点加入堆中，然后对堆中所有点做Dijkstra</li>
<li>每次取出堆中距离最小的点ver</li>
<li>遍历ver的所有邻点j，如果id[j]&#x3D;&#x3D;id[ver]，如果j能被更新，就将j插入堆中，如果不相等，就说明该边是航线，则将id[j]这个连通块的入度减1，如果入度减为0，就将其插入拓扑序列的队列中</li>
</ol>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25010</span>, M = <span class="number">150010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, mr, mp, S;</span><br><span class="line"><span class="type">int</span> id[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], din[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; block[N];</span><br><span class="line"><span class="type">int</span> bcnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> bid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[u] = bid, block[bid].<span class="built_in">push_back</span>(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!id[j]) <span class="built_in">dfs</span>(j, bid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> bid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : block[bid]) heap.<span class="built_in">push</span>(&#123;dist[u], u&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (id[ver] != id[j] &amp;&amp; -- din[id[j]] == <span class="number">0</span>) q.<span class="built_in">push</span>(id[j]);</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (id[j] == id[ver]) heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bcnt; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!din[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">dijkstra</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mr &gt;&gt; mp &gt;&gt; S;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mr -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!id[i])</span><br><span class="line">        &#123;</span><br><span class="line">            bcnt ++ ;</span><br><span class="line">            <span class="built_in">dfs</span>(i, bcnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mp -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        din[id[b]] ++ ;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (dist[i] &gt; INF / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;NO PATH&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; dist[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最优贸易"><a href="#最优贸易" class="headerlink" title="最优贸易"></a>最优贸易</h3><p><a href="https://www.acwing.com/problem/content/343/">原题链接</a></p>
<p>C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。</p>
<p>任意两个城市之间最多只有一条道路直接相连。</p>
<p>这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。</p>
<p>C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。</p>
<p>但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。</p>
<p>商人阿龙来到 C 国旅游。</p>
<p>当他得知“同一种商品在不同城市的价格可能会不同”这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚一点旅费。</p>
<p>设 C 国 n 个城市的标号从 1∼n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。</p>
<p>在旅游的过程中，任何城市可以被重复经过多次，但不要求经过所有 n 个城市。</p>
<p>阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。</p>
<p>因为阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。</p>
<p>现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。</p>
<p>请你告诉阿龙，他最多能赚取多少旅费。</p>
<p>注意：本题数据有加强。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。</p>
<p>第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。</p>
<p>接下来 m 行，每行有 3 个正整数，x，y，z，每两个整数之间用一个空格隔开。</p>
<p>如果 z&#x3D;1，表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z&#x3D;2，表示这条道路为城市 x 和城市 y 之间的双向道路。</p>
<p><strong>输出格式</strong></p>
<p>一个整数，表示答案。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤100000,$<br>$1≤m≤500000,$<br>$1≤各城市水晶球价格≤100$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h4><p>有n个城市，每个城市水晶球的价值不一样，两个城市之间的道路可能是有向边可能是无向边，一个人要从1到n，在一个城市买水晶球另一个城市卖出，每个点可以经过多次且不一定要经过所有点，问最多赚多少</p>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p><strong>&#x3D;&#x3D;dp&#x3D;&#x3D;</strong></p>
<p>由题目可知，会在1-n的一条路径上先买入水晶球再卖出水晶球</p>
<p>我们设一个点x为分界点，在x前面（包括x）买入水晶球，在x后面（包括x）卖出水晶球，现在问题就转换成了在x前用最低的价格买入，在x后用最高的价格卖出</p>
<p>用 <strong>&#x3D;&#x3D;spfa&#x3D;&#x3D;</strong> 算出所有点前面的最低价格和后面的最高价格，然后依次遍历每一个点为分界点，用该点后面的最高价格减去前面的最低价格，输出这个值的最大值即可</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">2000010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> hs[N], ht[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dmin[N], dmax[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> dist[], <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dmin);</span><br><span class="line">        dist[<span class="number">1</span>] = w[<span class="number">1</span>];</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">-0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dmax);</span><br><span class="line">        dist[n] = w[n];</span><br><span class="line">        q.<span class="built_in">push</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> ((type == <span class="number">0</span> &amp;&amp; dist[j] &gt; <span class="built_in">min</span>(dist[t], w[j])) || (type == <span class="number">1</span> &amp;&amp; dist[j] &lt; <span class="built_in">max</span>(dist[t], w[j])))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == <span class="number">0</span>) dist[j] = <span class="built_in">min</span>(dist[t], w[j]);</span><br><span class="line">                <span class="keyword">else</span> dist[j] = <span class="built_in">max</span>(dist[t], w[j]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(hs, <span class="number">-1</span>, <span class="keyword">sizeof</span> hs);</span><br><span class="line">    <span class="built_in">memset</span>(ht, <span class="number">-1</span>, <span class="keyword">sizeof</span> ht);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(hs, a, b), <span class="built_in">add</span>(ht, b, a);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">2</span>) <span class="built_in">add</span>(hs, b, a), <span class="built_in">add</span>(ht, a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spfa</span>(hs, dmin, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">spfa</span>(ht, dmax, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, dmax[i] - dmin[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="单源最短路的扩展应用"><a href="#单源最短路的扩展应用" class="headerlink" title="单源最短路的扩展应用"></a>单源最短路的扩展应用</h1><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><h3 id="选择最佳线路"><a href="#选择最佳线路" class="headerlink" title="选择最佳线路"></a>选择最佳线路</h3><p><a href="https://www.acwing.com/problem/content/1139/">原题链接</a></p>
<p>有一天，琪琪想乘坐公交车去拜访她的一位朋友。</p>
<p>由于琪琪非常容易晕车，所以她想尽快到达朋友家。</p>
<p>现在给定你一张城市交通路线图，上面包含城市的公交站台以及公交线路的具体分布。</p>
<p>已知城市中共包含 n 个车站（编号1~n）以及 m 条公交线路。</p>
<p>每条公交线路都是 单向的，从一个车站出发直接到达另一个车站，两个车站之间可能存在多条公交线路。</p>
<p>琪琪的朋友住在 s 号车站附近。</p>
<p>琪琪可以在任何车站选择换乘其它公共汽车。</p>
<p>请找出琪琪到达她的朋友家（附近的公交车站）需要花费的最少时间。</p>
<p><strong>输入格式</strong></p>
<p>输入包含多组测试数据。</p>
<p>每组测试数据第一行包含三个整数 n,m,s，分别表示车站数量，公交线路数量以及朋友家附近车站的编号。</p>
<p>接下来 m 行，每行包含三个整数 p,q,t，表示存在一条线路从车站 p 到达车站 q，用时为 t。</p>
<p>接下来一行，包含一个整数 w，表示琪琪家附近共有 w 个车站，她可以在这 w 个车站中选择一个车站作为始发站。</p>
<p>再一行，包含 w 个整数，表示琪琪家附近的 w 个车站的编号。</p>
<p><strong>输出格式</strong></p>
<p>每个测试数据输出一个整数作为结果，表示所需花费的最少时间。</p>
<p>如果无法达到朋友家的车站，则输出 -1。</p>
<p>每个结果占一行。</p>
<p><strong>数据范围</strong></p>
<p>$n≤1000,m≤20000,$<br>$1≤s≤n,$<br>$0&lt;w&lt;n,$<br>$0&lt;t≤1000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">8</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h3><p>给出一张图，琪琪可以从指定多个点的任意一个点出发，到达指定的一个点，问最短路</p>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p><strong>&#x3D;&#x3D;多个起点-&gt;虚拟源点&#x3D;&#x3D;</strong></p>
<p>起初将所有起点入队即可</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> scnt; <span class="comment">// 琪琪家旁边车站的个数</span></span><br><span class="line">    cin &gt;&gt; scnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (scnt -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u;</span><br><span class="line">        cin &gt;&gt; u;</span><br><span class="line">        dist[u] = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(u); <span class="comment">// 先将所有真实起点都入队</span></span><br><span class="line">        st[u] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;T) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">spfa</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist[T] == INF) dist[T] = <span class="number">-1</span>;</span><br><span class="line">        cout &lt;&lt; dist[T] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拯救大兵瑞恩"><a href="#拯救大兵瑞恩" class="headerlink" title="拯救大兵瑞恩"></a>拯救大兵瑞恩</h3><p><a href="https://www.acwing.com/problem/content/1133/">原题链接</a></p>
<p>1944 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。</p>
<p>瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。</p>
<p>迷宫的外形是一个长方形，其南北方向被划分为 N 行，东西方向被划分为 M 列， 于是整个迷宫被划分为 N×M 个单元。</p>
<p>每一个单元的位置可用一个有序数对 (单元的行号, 单元的列号) 来表示。</p>
<p>南北或东西方向相邻的 2 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。</p>
<p>注意： 门可以从两个方向穿过，即可以看成一条无向边。</p>
<p>迷宫中有一些单元存放着钥匙，同一个单元可能存放 多把钥匙，并且所有的门被分成 P 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。</p>
<p>大兵瑞恩被关押在迷宫的东南角，即 (N,M) 单元里，并已经昏迷。</p>
<p>迷宫只有一个入口，在西北角。</p>
<p>也就是说，麦克可以直接进入 (1,1) 单元。</p>
<p>另外，麦克从一个单元移动到另一个相邻单元的时间为 1，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。</p>
<p>试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。</p>
<p><strong>输入格式</strong></p>
<p>第一行有三个整数,分别表示 N,M,P 的值。</p>
<p>第二行是一个整数 k，表示迷宫中门和墙的总数。</p>
<p>接下来 k 行，每行包含五个整数，$X_{i1},Y_{i1},X_{i2},Y_{i2},G_{i}$：当 $G_i≥1$ 时，表示 $(X-{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一扇第 $G_i$ 类的门，当 $G_i&#x3D;0$ 时，表示 $(X_{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一面不可逾越的墙。</p>
<p>接下来一行，包含一个整数 S，表示迷宫中存放的钥匙的总数。</p>
<p>接下来 $S$ 行，每行包含三个整数 $X_{i1},Y_{i1},Q_i$，表示 $(X_{i1},Y_{i1}) $单元里存在一个能开启第 $Q_i$ 类门的钥匙。</p>
<p><strong>输出格式</strong></p>
<p>输出麦克营救到大兵瑞恩的最短时间。</p>
<p>如果问题无解，则输出 -1。</p>
<p><strong>数据范围</strong></p>
<p>$|Xi1−Xi2|+|Yi1−Yi2|&#x3D;1,$<br>$0≤Gi≤P,$<br>$1≤Qi≤P,$<br>$1≤N,M,P≤10,$<br>$1≤k≤150$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h3><p>给出迷宫，其中有不能穿过的墙， 能穿过的路和需要钥匙才能穿过的门，有一些格子上有钥匙，每移动一格消耗时间1，求从左上到右下的最短路</p>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>把迷宫的每一格看做一个点，每两个点之间能走就说明有边，先建图</p>
<p>用二进制的01表示当前身上有没有每一把钥匙的状态</p>
<p><code>dist[i][j]</code>表示在第i个点，身上钥匙的状态是j时的最短路</p>
<p>然后跑一遍 <strong>&#x3D;&#x3D;双端队列BFS&#x3D;&#x3D;</strong></p>
<p>如果该点有钥匙，就捡起来，更新dist的状态，新状态加入队头</p>
<p>然后看这个点的所有邻边：</p>
<ul>
<li>有门没钥匙</li>
<li>没有门，可更新的话新状态加入队尾</li>
</ul>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11</span>, M = <span class="number">360</span>, P = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k, p;</span><br><span class="line"><span class="type">int</span> h[N * N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> g[N][N], key[N * N];</span><br><span class="line"><span class="type">int</span> dist[N * N][P]; <span class="comment">// dist[i][j]表示在i位置有j钥匙的最短路距离</span></span><br><span class="line"><span class="type">bool</span> st[N * N][P];</span><br><span class="line"></span><br><span class="line">set&lt;PII&gt; edges;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = i + dx[u], y = j + dy[u];</span><br><span class="line">                <span class="keyword">if</span> (!x || x &gt; n || !y || y &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> a = g[i][j], b = g[x][y];</span><br><span class="line">                <span class="keyword">if</span> (!edges.<span class="built_in">count</span>(&#123;a, b&#125;)) <span class="built_in">add</span>(a, b, <span class="number">0</span>); <span class="comment">// 之前没处理过就在这两点之间加边</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    deque&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[t.first][t.second]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.first == n * m) <span class="keyword">return</span> dist[t.first][t.second];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key[t.first]) <span class="comment">// 该点有钥匙</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> state = t.second | key[t.first]; <span class="comment">// 状态加上该钥匙</span></span><br><span class="line">            <span class="keyword">if</span> (dist[t.first][state] &gt; dist[t.first][t.second]) <span class="comment">// 可以更新</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[t.first][state] = dist[t.first][t.second];</span><br><span class="line">                q.<span class="built_in">push_front</span>(&#123;t.first, state&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t.first]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (w[i] &amp;&amp; !(t.second &gt;&gt; w[i] - <span class="number">1</span> &amp; <span class="number">1</span>)) <span class="keyword">continue</span>; <span class="comment">// 有门没钥匙</span></span><br><span class="line">            <span class="keyword">if</span> (dist[j][t.second] &gt; dist[t.first][t.second] + <span class="number">1</span>) <span class="comment">// 没有阻碍的路</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j][t.second] = dist[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push_back</span>(&#123;j, t.second&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, t = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            g[i][j] = t ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (k -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, x2, y1, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="type">int</span> a = g[x1][y1], b = g[x2][y2];</span><br><span class="line"></span><br><span class="line">        edges.<span class="built_in">insert</span>(&#123;a, b&#125;), edges.<span class="built_in">insert</span>(&#123;b, a&#125;); <span class="comment">// 记录哪些边加过了</span></span><br><span class="line">        <span class="keyword">if</span> (c) <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c); <span class="comment">// 有钥匙就在这两点之间连边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (s -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        key[g[x][y]] |= <span class="number">1</span> &lt;&lt; c - <span class="number">1</span>; <span class="comment">// 钥匙加到该点上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路计数"><a href="#最短路计数" class="headerlink" title="最短路计数"></a>最短路计数</h3><p><a href="https://www.acwing.com/problem/content/1136/">原题链接</a></p>
<p>给出一个 N 个顶点 M 条边的无向无权图，顶点编号为 1 到 N。</p>
<p>问从顶点 1 开始，到其他每个点的最短路有几条。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含 2 个正整数 N,M，为图的顶点数与边数。</p>
<p>接下来 M 行，每行两个正整数 x,y，表示有一条顶点 x 连向顶点 y 的边，请注意可能有自环与重边。</p>
<p><strong>输出格式</strong></p>
<p>输出 N 行，每行一个非负整数，第 i 行输出从顶点 1 到顶点 i 有多少条不同的最短路，由于答案有可能会很大，你只需要输出对 100003 取模后的结果即可。</p>
<p>如果无法到达顶点 i 则输出 0。</p>
<p><strong>数据范围</strong></p>
<p>$1≤N≤105,$<br>$1≤M≤2×105$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4 id="题意-12"><a href="#题意-12" class="headerlink" title="题意"></a>题意</h4><p>给出一张图，问从1到每个点的最短路条数</p>
<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>这题求最短路的数量而不是最短路</p>
<p>bfs和Dijkstra每个点都只入一次队，出队时即为最短路，但spfa不能保证出队时是最短路，本题选用bfs &#x2F; Dijkstra</p>
<p>当新的点最短路可以更新到比当前值小，那么最短路的数量就是新的点的源点的最短路数量</p>
<p>当新的点最短路可以更新到和当前值一样，那最短路的数量就加上新的点的源点的最短路数量</p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">400010</span>, mod = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                cnt[j] = cnt[t];</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dist[j] == dist[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[j] = (cnt[j] + cnt[t]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cout &lt;&lt; cnt[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="观光"><a href="#观光" class="headerlink" title="观光"></a>观光</h3><p><a href="https://www.acwing.com/problem/content/385/">原题链接</a></p>
<p>“您的个人假期”旅行社组织了一次比荷卢经济联盟的巴士之旅。</p>
<p>比荷卢经济联盟有很多公交线路。</p>
<p>每天公共汽车都会从一座城市开往另一座城市。</p>
<p>沿途汽车可能会在一些城市（零或更多）停靠。</p>
<p>旅行社计划旅途从 S 城市出发，到 F 城市结束。</p>
<p>由于不同旅客的景点偏好不同，所以为了迎合更多旅客，旅行社将为客户提供多种不同线路。</p>
<p>游客可以选择的行进路线有所限制，要么满足所选路线总路程为 S 到 F 的最小路程，要么满足所选路线总路程仅比最小路程多一个单位长度。</p>
<img src="/posts/24fd3c3d/3.png" class>
<p>如上图所示，如果 S&#x3D;1，F&#x3D;5，则这里有两条最短路线 1→2→5,1→3→5，长度为 6；有一条比最短路程多一个单位长度的路线 1→3→4→5，长度为 7。</p>
<p>现在给定比荷卢经济联盟的公交路线图以及两个城市 S 和 F，请你求出旅行社最多可以为旅客提供多少种不同的满足限制条件的线路。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 T，表示共有 T 组测试数据。</p>
<p>每组数据第一行包含两个整数 N 和 M，分别表示总城市数量和道路数量。</p>
<p>接下来 M 行，每行包含三个整数 A,B,L，表示有一条线路从城市 A 通往城市 B，长度为 L。</p>
<p>需注意，线路是 单向的，存在从 A 到 B 的线路不代表一定存在从 B 到 A 的线路，另外从城市 A 到城市 B 可能存在多个不同的线路。</p>
<p>接下来一行，包含两个整数 S 和 F，数据保证 S 和 F 不同，并且 S、F 之间至少存在一条线路。</p>
<p><strong>输出格式</strong></p>
<p>每组数据输出一个结果，每个结果占一行。</p>
<p>数据保证结果不超过 109。</p>
<p><strong>数据范围</strong></p>
<p>$2≤N≤1000,$<br>$1≤M≤10000,$<br>$1≤L≤1000，$<br>$1≤A,B,S,F≤N$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">7</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="题意-13"><a href="#题意-13" class="headerlink" title="题意"></a>题意</h4><p>给出一张图，求给定两个点之间的最短路和次短路条数之和（次短路需要比最短路长度严格多1，不满足该条件就没有次短路）</p>
<h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>用堆优化Dijkstra求出最短路次短路数量（同时记录具体值）</p>
<p>详细看下方代码注释</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id, type, dist; <span class="comment">// 第id个点，最or次短路，具体值</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Ver &amp;W) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dist &gt; W.dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N][<span class="number">2</span>], cnt[N][<span class="number">2</span>]; <span class="comment">// dist表示最/次短路值 cnt表示最/次短路条数</span></span><br><span class="line"><span class="type">bool</span> st[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line"></span><br><span class="line">    dist[S][<span class="number">0</span>] = <span class="number">0</span>, cnt[S][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    priority_queue&lt;Ver, vector&lt;Ver&gt;, greater&lt;Ver&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;S, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.id, type = t.type, distance = t.dist, count = cnt[ver][type];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver][type]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver][type] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j][<span class="number">0</span>] &gt; distance + w[i]) <span class="comment">// 可以更新最短路</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j][<span class="number">1</span>] = dist[j][<span class="number">0</span>], cnt[j][<span class="number">1</span>] = cnt[j][<span class="number">0</span>]; <span class="comment">// 更新次短路</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, dist[j][<span class="number">1</span>]&#125;);</span><br><span class="line">                dist[j][<span class="number">0</span>] = distance + w[i], cnt[j][<span class="number">0</span>] = count; <span class="comment">// 更新最短路</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;j, <span class="number">0</span>, dist[j][<span class="number">0</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dist[j][<span class="number">0</span>] == distance + w[i]) cnt[j][<span class="number">0</span>] += count; <span class="comment">// 更新最短路条数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dist[j][<span class="number">1</span>] &gt; distance + w[i]) <span class="comment">// 可以更新次短路</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j][<span class="number">1</span>] = distance + w[i], cnt[j][<span class="number">1</span>] = count; <span class="comment">// 更新次短路</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, dist[j][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dist[j][<span class="number">1</span>] == distance + w[i]) cnt[j][<span class="number">1</span>] += count; <span class="comment">// 更新次短路条数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = cnt[T][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (dist[T][<span class="number">0</span>] + <span class="number">1</span> == dist[T][<span class="number">1</span>]) res += cnt[T][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cases;</span><br><span class="line">    cin &gt;&gt; cases;</span><br><span class="line">    <span class="keyword">while</span> (cases -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; S &gt;&gt; T;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>【图论】最小生成树</title>
    <url>/posts/a428212b.html</url>
    <content><![CDATA[<h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><h3 id="步骤与基本思路"><a href="#步骤与基本思路" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>（1）初始化所有点，每个点单独在一个点集。把所有边按权重排序</p>
<p>（2）按边权重从小到大遍历每一条边，如果这条边的两个顶点不在同一个点集，就将它们加到同一点集，也就是选中这条边，以此类推</p>
<p>（3）如果最后加入同一个点集的点个数小于n个说明这个图不是连通图，无法生成最小生成树</p>
<h3 id="Kruskal板子"><a href="#Kruskal板子" class="headerlink" title="Kruskal板子"></a>Kruskal板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 判断x属于哪一个点集</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m); <span class="comment">// 所有边按权重排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i; <span class="comment">// 所有点单独占一个点集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="comment">// 从小到大遍历每条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b) <span class="comment">// 判断ab在不在同一个点集</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b; <span class="comment">// 合并到同一点集</span></span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF; <span class="comment">// 不是连通图</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><h3 id="步骤与基本思路-1"><a href="#步骤与基本思路-1" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>（1）初始化距离数组dist[N]，将其所有值赋为0x3f</p>
<p>（2）从第一个点开始循环n次（因为最小生成树有n个点），每次循环中遍历所有点，选择还没有加入最小生成树且与生成树集合距离最短的点加入生成树，然后更新所有点到生成树集合的距离</p>
<p>（3）如果不是第一个点且距离生成树集合为无穷大时，说明不能形成最小生成树</p>
<h3 id="Prim板子"><a href="#Prim板子" class="headerlink" title="Prim板子"></a>Prim板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> <span class="comment">// 返回最小生成树的权重和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) <span class="comment">// 找到距离生成树集合距离最短的点</span></span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF; <span class="comment">// 距离最短的点距离时INF</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]); <span class="comment">// 更新所有点到生成树集合的距离</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>求最小生成树的基本算法有两个：</p>
<ul>
<li>Prim 时间复杂度O(n^2^)</li>
<li>Kruskal 时间复杂度O(mlogn) <strong>一般都用这个</strong></li>
</ul>
<p>上两个算法的证明思路：</p>
<p>假设不选当前边，最终得到了一棵树，然后将这条边加上，必然会出现一个环，在环上一定可以找到一条长度不小于当前边的边，那么用当前边替换，结果一定不会变差</p>
<p>同时还需要掌握：</p>
<ul>
<li>任意一棵最小生成树一定 <strong>&#x3D;&#x3D;可以&#x3D;&#x3D;</strong> 包含无向图中权值最小的边</li>
<li>给定一张无向图<code>G = (V, E)</code>，<code>n = |V|</code>，<code>m = |E|</code>，从 E 中选出 <code>k &lt; n - 1</code> 条边构成 G 的一个生成森林，若再从剩余的 <code>m -  k</code> 条边中选 <code>n - 1 - k</code> 条边添加到生成森林中，使其成为 G 的生成树，并且选出的边的权值之和最小，则该生成树一定 <strong>&#x3D;&#x3D;可以&#x3D;&#x3D;</strong> 包含 <code>m - k</code> 条边中连接生成森林的两个不连通节点的权值最小的边</li>
</ul>
<p>（证明思路还是同上）</p>
<h2 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h2><p>定义：给定一个带权图，把图的所有生成树权值从大到小排序，第二小的称为次小生成树</p>
<p>严格的次小生成树权值和不能等于最小生成树</p>
<p>求法：</p>
<p>方法一：先求最小生成树，再枚举删去最小生成树中的边求解<br><strong>只能求出非严格最小生成树</strong><br>时间复杂度：O(mlogn + mn)</p>
<p>方法二：先求最小生成树，然后依次枚举非树边，将该边加入树中，同时从形成的环的其余边中去掉最大边，使得最终图依然是一棵树，一定可以求出次小生成树<br>时间复杂度：O(m + n^2^ + mlogn)</p>
<h1 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h1><h2 id="最短网络"><a href="#最短网络" class="headerlink" title="最短网络"></a>最短网络</h2><p><a href="https://www.acwing.com/problem/content/1142/">原题链接</a></p>
<p>农夫约翰被选为他们镇的镇长！</p>
<p>他其中一个竞选承诺就是在镇上建立起互联网，并连接到所有的农场。</p>
<p>约翰已经给他的农场安排了一条高速的网络线路，他想把这条线路共享给其他农场。</p>
<p>约翰的农场的编号是1，其他农场的编号是 2∼n。</p>
<p>为了使花费最少，他希望用于连接所有的农场的光纤总长度尽可能短。</p>
<p>你将得到一份各农场之间连接距离的列表，你必须找出能连接所有农场并使所用光纤最短的方案。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含一个整数 n，表示农场个数。</p>
<p>接下来 n 行，每行包含 n 个整数，输入一个对角线上全是0的对称矩阵。<br>其中第 x+1 行 y 列的整数表示连接农场 x 和农场 y 所需要的光纤长度。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示所需的最小光纤长度。</p>
<p><strong>数据范围</strong></p>
<p>$3≤n≤100$<br>每两个农场间的距离均是非负整数且不超过100000。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span>  <span class="number">4</span>  <span class="number">9</span>  <span class="number">21</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0</span>  <span class="number">8</span>  <span class="number">17</span></span><br><span class="line"><span class="number">9</span>  <span class="number">8</span>  <span class="number">0</span>  <span class="number">16</span></span><br><span class="line"><span class="number">21</span> <span class="number">17</span> <span class="number">16</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>最小生成树裸题</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>跑一遍prim</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N][N]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// dist[i]表示i点距离当前连通块最短的一条边的长度</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 需要加入n个点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) t = j; <span class="comment">// 找到距离当前连通块最短的一条边</span></span><br><span class="line">        </span><br><span class="line">        res += dist[t]; <span class="comment">// 把最短的边连接的点加到连通块中</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], w[t][j]); <span class="comment">// 更新dist</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">prim</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p><a href="https://www.acwing.com/problem/content/1143/">原题链接</a></p>
<p>某个局域网内有 n 台计算机和 k 条 双向 网线，计算机的编号是 1∼n。由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。</p>
<p>注意：<br>对于某一个连接，虽然它是双向的，但我们不将其当做回路。本题中所描述的回路至少要包含两条不同的连接。<br>两台计算机之间最多只会存在一条连接。<br>不存在一条连接，它所连接的两端是同一台计算机。<br>因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用 <code>f(i,j)</code> 表示 <code>i</code>,<code>j</code> 之间连接的畅通程度，<code>f(i,j)</code> 值越小表示 <code>i</code>,<code>j</code> 之间连接越通畅。</p>
<p>现在我们需要解决回路问题，我们将除去一些连线，使得网络中没有回路且不影响连通性（即如果之前某两个点是连通的，去完之后也必须是连通的），并且被除去网线的 <code>Σf(i,j)</code> 最大，请求出这个最大值。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个正整数 n,k。</p>
<p>接下来的 k 行每行三个正整数 i,j,m 表示 i,j 两台计算机之间有网线联通，通畅程度为 m。</p>
<p><strong>输出格式</strong></p>
<p>一个正整数，表示被除去网线的 Σf(i,j) 的最大值。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤100$<br>$0≤k≤200$<br>$1≤f(i,j)≤1000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p><code>f[i][j]</code>表示ij间网络通畅度，越大流畅度越差，现在给出一张图，删掉任意条边使得原来连通的点对还连通，问删去后的图的最小权重</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>题意可转换成寻找一个“森林”的“最小生成森林”，跑一遍Kruskal即可</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        e[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b), w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span> (a != b) p[a] = b;</span><br><span class="line">        <span class="keyword">else</span> res += w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="繁忙的都市"><a href="#繁忙的都市" class="headerlink" title="繁忙的都市"></a>繁忙的都市</h2><p><a href="https://www.acwing.com/problem/content/1144/">原题链接</a></p>
<p>城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。</p>
<p>城市C的道路是这样分布的：</p>
<p>城市中有 n 个交叉路口，编号是 1∼n，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。</p>
<p>这些道路是 双向 的，且把所有的交叉路口直接或间接的连接起来了。</p>
<p>每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。</p>
<p>但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：</p>
<p>1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。</p>
<p>2．在满足要求1的情况下，改造的道路尽量少。</p>
<p>3．在满足要求1、2的情况下，改造的那些道路中分值最大值尽量小。</p>
<p>作为市规划局的你，应当作出最佳的决策，选择哪些道路应当被修建。</p>
<p><strong>输入格式</strong></p>
<p>第一行有两个整数 n,m 表示城市有 n 个交叉路口，m 条道路。</p>
<p>接下来 m 行是对每条道路的描述，每行包含三个整数u,v,c 表示交叉路口 u 和 v 之间有道路相连，分值为 c。</p>
<p><strong>输出格式</strong></p>
<p>两个整数 s,max，表示你选出了几条道路，分值最大的那条道路的分值是多少。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤300,$<br>$1≤m≤8000,$<br>$1≤c≤10000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出一张图，问最小生成树的最大边</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>跑一遍Kruskal即可</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        e[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b), w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; n - <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连接格点"><a href="#连接格点" class="headerlink" title="连接格点"></a>连接格点</h2><p><a href="https://www.acwing.com/problem/content/1146/">原题链接</a></p>
<p>有一个 m 行 n 列的点阵，相邻两点可以相连。</p>
<p>一条纵向的连线花费一个单位，一条横向的连线花费两个单位。</p>
<p>某些点之间已经有连线了，试问至少还需要花费多少个单位才能使所有的点全部连通。</p>
<p><strong>输入格式</strong></p>
<p>第一行输入两个正整数 m 和 n。</p>
<p>以下若干行每行四个正整数 x1,y1,x2,y2，表示第 x1 行第 y1 列的点和第 x2 行第 y2 列的点已经有连线。</p>
<p>输入保证|x1−x2|+|y1−y2|&#x3D;1。</p>
<p><strong>输出格式</strong></p>
<p>输出使得连通所有点还需要的最小花费。</p>
<p><strong>数据范围</strong></p>
<p>$1≤m,n≤1000$<br>$0≤已经存在的连线数≤10000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个点阵，相邻两点可连接，竖着连权重1，横着连权重二，已经连了一些边，求最小生成树</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>首先还是将已经连的边存进去，然后由于竖着的比横着的权重小，我们先将竖着的边存进去再存横着的边（避免对边的集合进行排序），之后跑一遍kruskal即可</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N, K = <span class="number">2</span> * N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> ids[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;e[K];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_edges</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dw[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; z &lt; <span class="number">2</span>; z ++ ) <span class="comment">// 先竖再横 确保边权有序 使无需对边排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u ++ )</span><br><span class="line">                    <span class="keyword">if</span> (u % <span class="number">2</span> == z)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> x = i + dx[u], y = j + dy[u], w = dw[u];</span><br><span class="line">                        <span class="keyword">if</span> (x &amp;&amp; x &lt;= n &amp;&amp; y &amp;&amp; y &lt;= m) <span class="comment">// 确定位置合法</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="type">int</span> a = ids[i][j], b = ids[x][y];</span><br><span class="line">                            <span class="keyword">if</span> (a &lt; b) e[k ++ ] = &#123;a, b, w&#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, t = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++, t ++ )</span><br><span class="line">            ids[i][j] = t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x1, x2, y1, y2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = ids[x1][y1], b = ids[x2][y2];</span><br><span class="line">        p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_edges</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跑一遍Kruskal</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b), w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="拓展应用"><a href="#拓展应用" class="headerlink" title="拓展应用"></a>拓展应用</h1><h2 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h2><p><a href="https://www.acwing.com/problem/content/1148/">原题链接</a></p>
<p>发展采矿业当然首先得有矿井，小 FF 花了上次探险获得的千分之一的财富请人在岛上挖了 n 口矿井，但他似乎忘记了考虑矿井供电问题。</p>
<p>为了保证电力的供应，小 FF 想到了两种办法：</p>
<p>在矿井 i 上建立一个发电站，费用为 vi（发电站的输出功率可以供给任意多个矿井）。将这口矿井 i 与另外的已经有电力供应的矿井 j 之间建立电网，费用为 pi,j。</p>
<p>小 FF 希望你帮他想出一个保证所有矿井电力供应的最小花费方案。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含一个整数 n，表示矿井总数。</p>
<p>接下来 n 行，每行一个整数，第 i 个数 vi 表示在第 i 口矿井上建立发电站的费用。</p>
<p>接下来为一个 n×n 的矩阵 P，其中 pi,j 表示在第 i 口矿井和第 j 口矿井之间建立电网的费用。</p>
<p>数据保证 <code>p[i,j]=p[j,i]</code>，且 <code>p[i,i]=0</code>。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示让所有矿井获得充足电能的最小花费。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤300,$<br>$0≤vi,pi,j≤105$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>多个矿井需要通电，可以在矿井处建发电站也可以将该矿井和其他有点的地方连起来，这两个操作都需要一定花费，求最少花费</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p><strong>&#x3D;&#x3D;虚拟源点&#x3D;&#x3D;</strong></p>
<p>建立虚拟源点，在某点建立发电站转化成在该点和虚拟源点之间连边，边的权值是在该点建立发电站的花费，求最小生成树跑一遍Prim即可</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) t = j;</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], w[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 连接虚拟源点和各个点</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w[<span class="number">0</span>][i];</span><br><span class="line">        w[i][<span class="number">0</span>] = w[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">prim</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="北极通讯网络"><a href="#北极通讯网络" class="headerlink" title="北极通讯网络"></a>北极通讯网络</h2><p><a href="https://www.acwing.com/problem/content/1147/">原题链接</a></p>
<p>北极的某区域共有 n 座村庄，每座村庄的坐标用一对整数 (x,y) 表示。</p>
<p>为了加强联系，决定在村庄之间建立通讯网络，使每两座村庄之间都可以直接或间接通讯。</p>
<p>通讯工具可以是无线电收发机，也可以是卫星设备。</p>
<p>无线电收发机有多种不同型号，不同型号的无线电收发机有一个不同的参数 d，两座村庄之间的距离如果不超过 d，就可以用该型号的无线电收发机直接通讯，d 值越大的型号价格越贵。现在要先选择某一种型号的无线电收发机，然后统一给所有村庄配备，数量不限，但型号都是 相同的。</p>
<p>配备卫星设备的两座村庄无论相距多远都可以直接通讯，但卫星设备是 有限的，只能给一部分村庄配备。</p>
<p>现在有 k 台卫星设备，请你编一个程序，计算出应该如何分配这 k 台卫星设备，才能使所配备的无线电收发机的 d 值最小。</p>
<p>例如，对于下面三座村庄：</p>
<img src="/posts/a428212b/7.png" class>


<p>其中，<code>|AB|=10,|BC|=20,|AC|=105√≈22.36</code>。</p>
<p>如果没有任何卫星设备或只有 1 台卫星设备 (k&#x3D;0 或 k&#x3D;1)，则满足条件的最小的 d&#x3D;20，因为 A 和 B，B 和 C 可以用无线电直接通讯；而 A 和 C 可以用 B 中转实现间接通讯 (即消息从 A 传到 B，再从 B 传到 C)；</p>
<p>如果有 2 台卫星设备 (k&#x3D;2)，则可以把这两台设备分别分配给 B 和 C ，这样最小的 d 可取10，因为 A 和 B 之间可以用无线电直接通讯；B 和 C 之间可以用卫星直接通讯；A 和 C<br> 可以用 B 中转实现间接通讯。</p>
<p>如果有 3 台卫星设备，则 A,B,C 两两之间都可以直接用卫星通讯，最小的 d 可取 0。</p>
<p><strong>输入格式</strong></p>
<p>第一行为由空格隔开的两个整数 n,k;</p>
<p>接下来 n 行，每行两个整数，第 i 行的 xi,yi 表示第 i 座村庄的坐标 (xi,yi)。</p>
<p><strong>输出格式</strong></p>
<p>一个实数，表示最小的 d 值，结果保留 2 位小数。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤500,$<br>$0≤x,y≤104,$<br>$0≤k≤100$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">0</span></span><br><span class="line"><span class="number">30</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10.00</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>有无线电和卫星设备两种方式，无线电的参数d表示在d之内的都可以直接传输，卫星设备不管离多远都可以传输，现有k个卫星设备，求问最小的d</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>Kruskal的基本思路是，假设已经遍历完前i条边，那么就已经求出了连接前i条边的连通块个数，本题给出k个卫星设备，意思就是我们需要求出一个d，使得距离比d小的两个点之间都靠无线电传输（这些靠无线电传输的构成了多个连通块），在所有连通块之间建立卫星设备，卫星设备的个数是k</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = N * N / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">double</span> w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line">PII q[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_dist</span><span class="params">(PII a, PII b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx = a.first - b.first;</span><br><span class="line">    <span class="type">int</span> dy = a.second - b.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i].first &gt;&gt; q[i].second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line">            e[m ++ ] = &#123;i, j, <span class="built_in">get_dist</span>(q[i], q[j])&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = n;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == k) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">        <span class="type">double</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            cnt -- ;</span><br><span class="line">            res = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="走廊泼水节"><a href="#走廊泼水节" class="headerlink" title="走廊泼水节"></a>走廊泼水节</h2><p><a href="https://www.acwing.com/problem/content/348/">原题链接</a></p>
<p>给定一棵 N 个节点的树，要求增加若干条边，把这棵树扩充为完全图，并满足图的唯一最小生成树仍然是这棵树。</p>
<p>求增加的边的权值总和最小是多少。</p>
<p>注意： 树中的所有边权均为整数，且新加的所有边权也必须为整数。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 t，表示共有 t 组测试数据。</p>
<p>对于每组测试数据，第一行包含整数 N。</p>
<p>接下来 N−1 行，每行三个整数 X,Y,Z，表示 X 节点与 Y 节点之间存在一条边，长度为 Z。</p>
<p><strong>输出格式</strong></p>
<p>每组数据输出一个整数，表示权值总和最小值。</p>
<p>每个结果占一行。</p>
<p><strong>数据范围</strong></p>
<p>$1≤N≤6000$<br>$1≤Z≤100$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>将一棵树扩展为一个完全图，要求图的最小生成树还是原来的那棵树，求添加的边权总和最小是多少</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p><strong>&#x3D;&#x3D;扩展应用&#x3D;&#x3D;</strong></p>
<p>将图中每个点看做一个连通块</p>
<p>每两个连通块之间构成完全图就是连接两个连通块的所有点对，也就是<code>(sized[a] * sized[b] - 1)</code></p>
<p>因为我们要让起初的树是完全图的最小生成树，我们将边权从小到大排序，每次选择当前边所连接的两个连通块，加上的新边必须要大于当前边权（才能使其为最小生成树），也就是新加的边权是<code>w + 1</code></p>
<p>记得维护<code>size</code>和<code>p</code></p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 并查集</span></span><br><span class="line"><span class="type">int</span> sized[N]; <span class="comment">// 只有根结点的数据正确 表示这个连通块的结点个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            e[i] = &#123;a, b, c&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(e, e + n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i, sized[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b), w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span> (a != b)</span><br><span class="line">            &#123;</span><br><span class="line">                res += (sized[a] * sized[b] - <span class="number">1</span>) * (w + <span class="number">1</span>);</span><br><span class="line">                sized[b] += sized[a];</span><br><span class="line">                p[a] = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="秘密的牛奶运输"><a href="#秘密的牛奶运输" class="headerlink" title="秘密的牛奶运输"></a>秘密的牛奶运输</h2><p><a href="https://www.acwing.com/problem/content/1150/">原题链接</a></p>
<p>农夫约翰要把他的牛奶运输到各个销售点。</p>
<p>运输过程中，可以先把牛奶运输到一些销售点，再由这些销售点分别运输到其他销售点。</p>
<p>运输的总距离越小，运输的成本也就越低。</p>
<p>低成本的运输是农夫约翰所希望的。</p>
<p>不过，他并不想让他的竞争对手知道他具体的运输方案，所以他希望采用费用第二小的运输方案而不是最小的。</p>
<p>现在请你帮忙找到该运输方案。</p>
<p>注意：</p>
<p>如果两个方案至少有一条边不同，则我们认为是不同方案；<br>费用第二小的方案在数值上一定要严格大于费用最小的方案；<br>答案保证一定有解；</p>
<p><strong>输入格式</strong></p>
<p>第一行是两个整数 N,M，表示销售点数和交通线路数；</p>
<p>接下来 M 行每行 3 个整数 x,y,z，表示销售点 x 和销售点 y 之间存在线路，长度为 z。</p>
<p><strong>输出格式</strong></p>
<p>输出费用第二小的运输方案的运输总距离。</p>
<p><strong>数据范围</strong></p>
<p>$1≤N≤500,$<br>$1≤M≤104,$<br>$1≤z≤109,$<br>数据中可能包含重边。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">100</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">200</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">250</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">450</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p>次小生成树板题</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p><strong>&#x3D;&#x3D;次小生成树&#x3D;&#x3D;</strong></p>
<p>使用方法二，具体步骤：</p>
<ol>
<li>求最小生成树，统计每条边是树边还是非树边，同时建立最小生成树</li>
<li>预处理任意两点间边权最大值<code>dist1[a][b]</code>和次大值<code>dist2[a][b]</code></li>
<li>依次枚举所有非树边，求<code>min(sum + w - dist[a][b])</code>，满足<code>w &gt; dist1[a][b]</code>或<code>w &gt; dist2[a][b]</code>（这样才能保证求出的是严格次小生成树）</li>
</ol>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> f; <span class="comment">// 记录该边是否为树边</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> dist1[N][N], dist2[N][N];</span><br><span class="line"><span class="type">int</span> h[N], e[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], w[N * <span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// u当前结点 fa父结点 maxd1 maxd2 d1:和u形成的路径上的最大边 d2:和u形成的路径上的次大边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> maxd1, <span class="type">int</span> maxd2, <span class="type">int</span> d1[], <span class="type">int</span> d2[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d1[u] = maxd1, d2[u] = maxd2; <span class="comment">// 记录最大边次大边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != fa) <span class="comment">// 不是连到父结点的边再继续</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 更新当前最大边和次大边</span></span><br><span class="line">            <span class="type">int</span> td1 = maxd1, td2 = maxd2;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; td1) td2 = td1, td1 = w[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w[i] &lt; td1 &amp;&amp; w[i] &gt; td2) td2 = w[i];</span><br><span class="line">            <span class="built_in">dfs</span>(j, u, td1, td2, d1, d2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        edge[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(edge, edge + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先跑一遍最小生成树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">            sum += w;</span><br><span class="line">            <span class="built_in">add</span>(a, b, w), <span class="built_in">add</span>(b, a, w);</span><br><span class="line">            edge[i].f = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理两点之间路径上的最大边和次大边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">dfs</span>(i, <span class="number">-1</span>, <span class="number">-1e9</span>, <span class="number">-1e9</span>, dist1[i], dist2[i]);</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!edge[i].f) <span class="comment">// 非树边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            ll t;</span><br><span class="line">            <span class="keyword">if</span> (w &gt; dist1[a][b]) t = sum + w - dist1[a][b]; <span class="comment">// 大于当前最大边直接替换最大边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w &gt; dist2[a][b]) t = sum + w - dist2[a][b]; <span class="comment">// 不大于最大边但大于次大边替换次大边</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>【图论】最短路算法</title>
    <url>/posts/6874ac4d.html</url>
    <content><![CDATA[<h2 id="1、Dijkstra算法"><a href="#1、Dijkstra算法" class="headerlink" title="1、Dijkstra算法"></a>1、Dijkstra算法</h2><p>不能处理边权为负的情况，<strong>复杂度O(nlogn)</strong></p>
<h3 id="步骤与基本思路"><a href="#步骤与基本思路" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>（1）初始化距离数组dist[N]，将其所有值赋为0x3f，并将起点1的dist初始化为0，存入优先队列heap中</p>
<p>（2）从所有<strong>未被遍历</strong>的点中找到与起点1的<strong>距离dist[i]最小</strong>的点，并将该点标记为已遍历</p>
<p>（3）利用刚刚遍历的这个点 i <strong>更新</strong>所有 i 的出边所连的点与起点1的距离，更新后存入heap中</p>
<p>（4）重复操作（2）（3）直至heap空</p>
<h3 id="Dijkstra板子"><a href="#Dijkstra板子" class="headerlink" title="Dijkstra板子"></a>Dijkstra板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> <span class="comment">// 返回起点到终点的距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// first为dist second为具体的点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>(); <span class="comment">// 即取出与起始距离最短点</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> distance = t.first, ver = t.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有与ver相邻的点 更新他们的dist</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 说明起点到不了终点</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="2、Bellman-Ford算法"><a href="#2、Bellman-Ford算法" class="headerlink" title="2、Bellman-Ford算法"></a>2、Bellman-Ford算法</h2><p>可以解决<strong>对边数有要求</strong>的最短路问题，<strong>复杂度O(n^2)</strong></p>
<h3 id="步骤与基本思路-1"><a href="#步骤与基本思路-1" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>（1）初始化距离数组dist[N]，将其所有值赋为0x3f，并将起点1的dist初始化为0</p>
<p>（2）遍历 k 次，第 i 次表示这一轮的最短路最多经过 i 条边：每轮先复制上一轮的dist（防止本轮前面的dist更新对后面的更新有影响），然后遍历所有边，更新dist为最小值</p>
<h3 id="Bellman-Ford板子"><a href="#Bellman-Ford板子" class="headerlink" title="Bellman-Ford板子"></a>Bellman-Ford板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(last, dist, <span class="keyword">sizeof</span> dist); <span class="comment">// 将本轮还没有更新的dist值赋给last</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], last[e.a] + e.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="3、SPFA算法"><a href="#3、SPFA算法" class="headerlink" title="3、SPFA算法"></a>3、SPFA算法</h2><p>可以解决有负权边的情况，还可以判断负环，<strong>复杂度O(n^2)</strong></p>
<h3 id="步骤与基本思路-2"><a href="#步骤与基本思路-2" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>（1）初始化距离数组dist[N]，将其所有值赋为0x3f，并将起点1的dist初始化为0</p>
<p>（2）建立队列q，将起点1存入队列中。同时建立st数组记录哪些点入队</p>
<p>（3）每轮取出队头，遍历与队头相连的所有点，更新这些点的dist，并将不在队中的点入队</p>
<p>（4）重复（3），直到队空</p>
<h3 id="SPFA板子"><a href="#SPFA板子" class="headerlink" title="SPFA板子"></a>SPFA板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span> <span class="comment">// 返回起点到终点的最短距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 记录队中现在有哪些点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>(); <span class="comment">// 取出队头</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>; <span class="comment">// 取出的点不在队中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j]) <span class="comment">// 更新的点不在队中就入队</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="4、Floyd算法"><a href="#4、Floyd算法" class="headerlink" title="4、Floyd算法"></a>4、Floyd算法</h2><p>数据范围小时用该方法合适，可以处理负权边，<strong>时间复杂度O(n^3)</strong></p>
<h3 id="步骤与基本思路-3"><a href="#步骤与基本思路-3" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>设置 k 为中转站，每轮更新 i -&gt; j 距离为 i -&gt; j 和 i -&gt; k k -&gt; j 的最小值</p>
<h3 id="Floyd板子"><a href="#Floyd板子" class="headerlink" title="Floyd板子"></a>Floyd板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ ) <span class="comment">// k为中转站</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>【图论】最近公共祖先LCA</title>
    <url>/posts/b33f183d.html</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>什么是最近公共祖先？</p>
<p>在一棵树中（也就是有向无环图中），从根结点遍历到每个结点，路径上所经过的所有结点都叫做该结点的祖先结点</p>
<p>两个结点的祖先结点中重复的部分叫做公共祖先</p>
<p>公共祖先中层数最大的一个点叫做<strong>最近公共祖先（LCA）</strong></p>
<h1 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h1><h2 id="向上标记法"><a href="#向上标记法" class="headerlink" title="向上标记法"></a>向上标记法</h2><p>要求的两个结点依次向上遍历，找到的第一个公共祖先就是最近公共祖先</p>
<p>但是这个做法比较暴力，时间复杂度<strong>O(n)</strong></p>
<h2 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h2><p>首先需要预处理<code>f[i][j]</code>：从结点 i 向上走 2^j^ 步走到的结点，j 的范围是<code>0 &lt;= j &lt;= logn</code><br>比如说，当 j &#x3D; 0 时，<code>f[i][j]</code>表示的就是 i 向上走一步到达的结点，其实也就是 i 的父结点</p>
<p>（如果从 i 开始跳 2^j^ 跳出了根结点，那么规定<code>f[i][j] = 0</code>且<code>dist[0] = 0</code>）</p>
<p>怎么实现这个算法呢？</p>
<p>我们发现，从结点 i 向上走 2^j^ 步，相当于结点 i 先向上走 2 ^j-1^ 步，再向上走 2 ^j-1^ 步<br>据此，我们可以利用<strong>递归</strong>来解决这个问题</p>
<p>用式子可以表示为：<code>f[i][j] = f[f[i][j - 1]][j - 1]</code></p>
<p>然后，我们需要预处理另一个数组<code>depth[i]</code>：表示 i 结点的深度</p>
<p>上面的两个数组都可以利用 DFS &#x2F; BFS 求出</p>
<p>当我们知道了<code>f[i][j]</code> 和<code>depth[i]</code>，应该怎么求LCA呢？</p>
<p><strong>步骤：</strong></p>
<ul>
<li>&#x3D;&#x3D;<strong>先将两个结点跳到同一层</strong>&#x3D;&#x3D;<br>具体怎么做呢？<br>首先我们需要了解<strong>二进制拼凑</strong>：所有整数都可以由2的整次幂的和来表示（因为所有数都可以表示为二进制）<br>当我们需要拼出一个 n ，从大到小开始枚举，当找到第一个数 k 满足<code>2^k &lt;= n</code>时，表示我们需要选择 2 ^k^，之后用 n - 2 ^k^ 再根据一样的步骤求出下一个满足条件的 k，以此类推<br>了解了这个知识之后，回到<strong>怎么将两个不同深度的结点跳到同一层</strong>这个问题<br>我们已经知道了<code>depth[i]</code>和<code>depth[j]</code>（假设要求的两个结点是 i 和 j，i 的深度比 j 大）<br>当<code>depth[f[i][k]] &gt;= depth[j]</code>时，说明结点 i 向上跳了 2 ^k^ 步后的祖先结点还是比结点 j 深度大，那就说明可以跳，根据这个方法，我们可以将深度较大的结点跳到和深度较小的结点的同一层</li>
<li>&#x3D;&#x3D;<strong>让两个结点同时往上跳，直到跳到最近公共祖先的下一层</strong>&#x3D;&#x3D;<br>为什么要让这两个结点跳到LCA的下一层而不是直接跳到LCA呢？<br>因为如果这两个结点跳到的祖先是同一个结点，我们只能说这个相同的结点是公共祖先祖先，而无法保证是最近公共祖先。当我们跳到LCA的下一层，只要他们的父结点是同一个结点，那这个结点就一定是它们的最近公共祖先了<br>那该怎么实现这一步呢？<br>还是从大到小枚举 k，当<code>f[i][k] != f[j][k]</code>时，说明 i 和 j 还没有跳到公共祖先，当<code>f[i][k] == f[j][k]</code>时，跳到了公共祖先，此时 k - 1 就是不能跳到公共祖先的最大的 k，于是我们将 i 和 j 同时往上跳 2 ^k-1^步，以此类推</li>
</ul>
<p>预处理的时间复杂度是<strong>O(nlogn)</strong><br>查询的时间复杂度是<strong>O(logn)</strong></p>
<h3 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h3><p><strong>题目 <a href="https://www.acwing.com/problem/content/1174/">祖孙询问</a></strong></p>
<p>给定一棵包含 n 个节点的有根无向树，节点编号互不相同，但不一定是 1∼n。</p>
<p>有 m 个询问，每个询问给出了一对节点的编号 x 和 y，询问 x 与 y 的祖孙关系。</p>
<p><strong>输入格式</strong></p>
<p>输入第一行包括一个整数 表示节点个数；</p>
<p>接下来 n 行每行一对整数 a 和 b，表示 a 和 b 之间有一条无向边。如果 b 是 −1，那么 a 就是树的根；</p>
<p>第 n+2 行是一个整数 m 表示询问个数；</p>
<p>接下来 m 行，每行两个不同的正整数 x 和 y，表示一个询问。</p>
<p><strong>输出格式</strong></p>
<p>对于每一个询问，若 x 是 y 的祖先则输出 1，若 y 是 x 的祖先则输出 2，否则输出 0。</p>
<p><strong>数据范围</strong></p>
<p><code>1 ≤ n, m ≤ 4 × 10^4</code>,<br><code>1 ≤ 每个节点的编号 ≤ 4 × 10^4</code></p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">234</span> <span class="number">-1</span></span><br><span class="line"><span class="number">12</span> <span class="number">234</span></span><br><span class="line"><span class="number">13</span> <span class="number">234</span></span><br><span class="line"><span class="number">14</span> <span class="number">234</span></span><br><span class="line"><span class="number">15</span> <span class="number">234</span></span><br><span class="line"><span class="number">16</span> <span class="number">234</span></span><br><span class="line"><span class="number">17</span> <span class="number">234</span></span><br><span class="line"><span class="number">18</span> <span class="number">234</span></span><br><span class="line"><span class="number">19</span> <span class="number">234</span></span><br><span class="line"><span class="number">233</span> <span class="number">19</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">234</span> <span class="number">233</span></span><br><span class="line"><span class="number">233</span> <span class="number">12</span></span><br><span class="line"><span class="number">233</span> <span class="number">13</span></span><br><span class="line"><span class="number">233</span> <span class="number">15</span></span><br><span class="line"><span class="number">233</span> <span class="number">19</span></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>代码</strong>（加了注释^^）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">16</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span> <span class="comment">// 预处理depth和fa</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f3f3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[root] = <span class="number">1</span>; <span class="comment">// 设置哨兵</span></span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>; <span class="comment">// 更新depth</span></span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">                fa[j][<span class="number">0</span>] = t; <span class="comment">// 记录父结点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>]; <span class="comment">// 更新fa</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// 返回最近公共祖先</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b); <span class="comment">// 把深度大的调到a</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- ) <span class="comment">// 把两个结点调到同一层</span></span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- ) <span class="comment">// 两个点同时往上跳</span></span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 构图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">-1</span>) root = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>(root); <span class="comment">// 预处理</span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span> (p == a) cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == b) cout &lt;&lt; <span class="string">&quot;2\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Tarjan法"><a href="#Tarjan法" class="headerlink" title="Tarjan法"></a>Tarjan法</h2><p>本质是对向上标记法的优化，这是一种离线做法（意思是读入所有询问后统一计算统一输出），时间复杂度<strong>O(n + m)</strong></p>
<p>在DFS中，把所有的点分成三大类：<strong>已经遍历过且回溯过的点</strong>（意思是它的所有子树都被遍历了，换句话说就是经过了该点两次）、<strong>正在遍历的分支</strong>（遍历过一次还没有回溯的点，换句话说就是经过了该点一次）、<strong>还没搜索到的点</strong>（经过了该点0次）</p>
<p>以下面这张图为例，设红色的路线使我们正在遍历的点，红色左边的所有点都是已经遍历完的，右边的所有点都是还没有被遍历的<br>可以发现，黄色区域内的所有点与 j 的最近公共祖先就是黄色区域的父结点，蓝色区域和绿色区域也一样，因此我们可以通过并查集的方式求得两个结点的lca</p>
<img src="/posts/b33f183d/1.png" class>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><strong>题目 <a href="https://www.acwing.com/problem/content/1173/">距离</a></strong></p>
<p>给出 n 个点的一棵树，多次询问两点之间的最短距离。</p>
<p>注意：</p>
<ul>
<li>边是无向的。</li>
<li>所有节点的编号是 1,2,…,n。</li>
</ul>
<p><strong>输入格式</strong></p>
<p>第一行为两个整数 n 和 m。n 表示点数，m 表示询问次数；</p>
<p>下来 n−1 行，每行三个整数 x,y,k，表示点 x 和点 y 之间存在一条边长度为 k；</p>
<p>再接下来 m 行，每行两个整数 x,y，表示询问点 x 到点 y 的最短距离。</p>
<p>树中结点编号从 1 到 n。</p>
<p><strong>输出格式</strong><br>共 m 行，对于每次询问，输出一行询问结果。</p>
<p><strong>数据范围</strong><br>2 ≤ n ≤ 10^4^, 1 ≤ m ≤ 2 × 10^4^, 0 &lt; k ≤ 100, 1 ≤ x, y ≤ n</p>
<p><strong>输入样例1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">100</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>输出样例1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<p><strong>输入样例2：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">10</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>输出样例2：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>只需要知道，求两个点的路径长度，就是用<strong>第一个点到根结点的距离</strong>加上<strong>第二个点到根结点的距离</strong>减去<strong>两倍的最近公共祖先到根节点的距离</strong>，所以问题还是转化成求lca的问题</p>
<img src="/posts/b33f183d/2.png" class>

<p><strong>代码</strong>（加了注释）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20010</span>, M = <span class="number">2</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;  </span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储每个点到根结点的距离</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 每个点的祖宗结点</span></span><br><span class="line"><span class="type">int</span> res[N]; <span class="comment">// 存储输出结果</span></span><br><span class="line"><span class="type">int</span> st[N]; <span class="comment">// 表示每个点的遍历状态 1:正在搜索 2:已经搜完 0:还没搜</span></span><br><span class="line">vector&lt;PII&gt; query[N]; <span class="comment">// 存储查询的点，first存另一个点，second存查询编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>; <span class="comment">// 需要记录父结点防止遍历到上面去（因为这是一个图我们把它看成树而已）</span></span><br><span class="line">        dist[j] = dist[u] + w[i]; <span class="comment">// dist[j]是点 w[i]是边 更新距离dist</span></span><br><span class="line">        <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="number">1</span>; <span class="comment">// 修改当前点状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="comment">// 如果当前点未被遍历过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            p[j] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query[u]) <span class="comment">// 处理和当前点相关的所有询问</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = item.first, id = item.second; <span class="comment">// y是另一个点 id是询问编号</span></span><br><span class="line">        <span class="keyword">if</span> (st[y] == <span class="number">2</span>) <span class="comment">// 另一个点已经搜完才处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> anc = <span class="built_in">find</span>(y); <span class="comment">// anc为最近公共祖先</span></span><br><span class="line">            res[id] = dist[u] + dist[y] - <span class="number">2</span> * dist[anc];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st[u] = <span class="number">2</span>; <span class="comment">// 修改当前点状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) <span class="comment">// 构图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        query[a].<span class="built_in">push_back</span>(&#123;b, i&#125;);</span><br><span class="line">        query[b].<span class="built_in">push_back</span>(&#123;a, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i; <span class="comment">// 并查集初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>); <span class="comment">// -1表示1是根结点</span></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) cout &lt;&lt; res[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h1><h2 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a><a href="https://www.acwing.com/problem/content/description/358/">次小生成树</a></h2><p>给定一张 N 个点 M 条边的无向图，求无向图的严格次小生成树。</p>
<p>设最小生成树的边权之和为 sum，严格次小生成树就是指边权之和大于 sum 的生成树中最小的一个。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 N 和 M。</p>
<p>接下来 M 行，每行包含三个整数 x，y，z，表示点 x 和点 y 之前存在一条边，边的权值为 z。</p>
<p><strong>输出格式</strong></p>
<p>包含一行，仅一个数，表示严格次小生成树的边权和。(数据保证必定存在严格次小生成树)</p>
<p><strong>数据范围</strong></p>
<p>N ≤ 10^5^, M ≤ 3 × 10^5^,<br>1 ≤ x, y ≤ N,<br>0 ≤ z ≤ 106</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>总体思路是：先利用Kruskal算法求出最小生成树，然后看其余不在最小生成树中的每条边能不能替换最小生成树中的一条边使得其变成次小生成树<br>不在最小生成树的边加到最小生成树里，（比如说加了a-b这条边），那ab在最小生成树中的路径一定会和加的这条边构成环（这点很重要，理解了就很清楚），那我们就需要在这个环里去掉一条边让a-b这条边来代替它，设新加的边权重w，去掉的边权重wi，最小生成树边权和sum，那么新生成的树边权和<code>sum - wi + w</code>，要让新生成的树权重尽可能小，我们就要让减掉的边权重尽可能大，因此减掉的边只可能是最小生成树中的最大边或者次大边（因为要求生成严格的次小生成树，那么次小生成树的边权和就不能和最小生成树一样大，如果新加入的边和最小生成树中的最大边权重一样，就不能用这条边替换最大边（否则最终权重还是一样），就应该用这条边替换次大边）</p>
<p>代码中的 lca 函数利用最近公共祖先求出环中除了新加的边之外的最大边和次大边，bfs 函数更新 d1 和 d2 的值<br>具体看代码注释（ 受不了了好难qaq</p>
<p><strong>代码</strong>（写了注释）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">// 存边信息</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> used;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 并查集</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N]; <span class="comment">// 每个点的层数</span></span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">17</span>]; <span class="comment">// 每个点向上走2^j到达的点</span></span><br><span class="line"><span class="type">int</span> d1[N][<span class="number">17</span>]; <span class="comment">// d1[i][j] 表示从i点向上走2^j步这段路径中最大边</span></span><br><span class="line"><span class="type">int</span> d2[N][<span class="number">17</span>]; <span class="comment">// d2[i][j] 表示从i点向上走2^j步这段路径中（严格）次大边</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">kruskal</span><span class="params">()</span> <span class="comment">// 构建最小生成树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(edge, edge + m); <span class="comment">// 按边权从小到大排序</span></span><br><span class="line">    i64 res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(edge[i].a), b = <span class="built_in">find</span>(edge[i].b), w = edge[i].w;</span><br><span class="line">        <span class="keyword">if</span> (a != b) <span class="comment">// ab不属于同一集合</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b; <span class="comment">// 将a加到b所在集合</span></span><br><span class="line">            res += w; <span class="comment">// 更新最小生成树边权</span></span><br><span class="line">            edge[i].used = <span class="literal">true</span>; <span class="comment">// 标记i这条边已被使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> <span class="comment">// 构图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (edge[i].used) <span class="comment">// 这条边在最小生成树里才加到图里</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            <span class="built_in">add</span>(a, b, w), <span class="built_in">add</span>(b, a, w);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="comment">// 更新depth和fa和d1和d2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f3f3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 设置哨兵和初始化</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>) <span class="comment">// 说明j没被遍历过，更新j相关信息</span></span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">                fa[j][<span class="number">0</span>] = t; <span class="comment">// 更新j父结点</span></span><br><span class="line">                d1[j][<span class="number">0</span>] = w[i], d2[j][<span class="number">0</span>] = -inf; <span class="comment">// 初始化</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; <span class="number">16</span>; k ++ )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> anc = fa[j][k - <span class="number">1</span>]; <span class="comment">// j向上走2^(k-1)所到达点</span></span><br><span class="line">                    fa[j][k] = fa[anc][k - <span class="number">1</span>]; <span class="comment">// 递归思想</span></span><br><span class="line">                    <span class="comment">// 最大边和次大边一定是下方四个值中的一个</span></span><br><span class="line">                    <span class="type">int</span> distance[<span class="number">4</span>] = &#123;d1[j][k - <span class="number">1</span>], d2[j][k - <span class="number">1</span>], d1[anc][k - <span class="number">1</span>], d2[anc][k - <span class="number">1</span>]&#125;;</span><br><span class="line">                    d1[j][k] = d2[j][k] = -inf; <span class="comment">// 初始化最大边和次大边的值</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u ++ ) <span class="comment">// 更新最大边和次大边</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> d = distance[u];</span><br><span class="line">                        <span class="keyword">if</span> (d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (d != d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> distance[N * <span class="number">2</span>]; <span class="comment">// 存储所有跳的路径中的最大边和次大边</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// distance大小</span></span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b); <span class="comment">// 把深度大的调给a</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b]) <span class="comment">// 把ab调到同一层，a往上跳2^k还是比b深度大，说明可以跳</span></span><br><span class="line">        &#123;</span><br><span class="line">            distance[cnt ++ ] = d1[a][k];</span><br><span class="line">            distance[cnt ++ ] = d2[a][k];</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != b) <span class="comment">// 把ab同时跳到最近公共祖先的下一层</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">            <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">            &#123;</span><br><span class="line">                distance[cnt ++ ] = d1[a][k];</span><br><span class="line">                distance[cnt ++ ] = d2[a][k];</span><br><span class="line">                distance[cnt ++ ] = d1[b][k];</span><br><span class="line">                distance[cnt ++ ] = d2[b][k];</span><br><span class="line">                a = fa[a][k], b = fa[b][k];</span><br><span class="line">            &#125;</span><br><span class="line">        distance[cnt ++ ] = d1[a][<span class="number">0</span>];</span><br><span class="line">        distance[cnt ++ ] = d1[b][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在distance中找到最大边和次大边赋给dist1 dist2</span></span><br><span class="line">    <span class="type">int</span> dist1 = -inf, dist2 = -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = distance[i];</span><br><span class="line">        <span class="keyword">if</span> (d &gt; dist1) dist2 = dist1, dist1 = d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d != dist1 &amp;&amp; d &gt; dist2) dist2 = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w &gt; dist1) <span class="keyword">return</span> w - dist1; <span class="comment">// w替换最大边</span></span><br><span class="line">    <span class="keyword">if</span> (w &gt; dist2) <span class="keyword">return</span> w - dist2; <span class="comment">// w替换次大边</span></span><br><span class="line">    <span class="keyword">return</span> inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        edge[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i64 sum = <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    i64 res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!edge[i].used) <span class="comment">// 在没选的所有边中找到要替换的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            res = <span class="built_in">min</span>(res, sum + <span class="built_in">lca</span>(a, b, w));</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闇の連鎖"><a href="#闇の連鎖" class="headerlink" title="闇の連鎖"></a><a href="https://www.acwing.com/problem/content/description/354/">闇の連鎖</a></h2><p>传说中的暗之连锁被人们称为 Dark。</p>
<p>Dark 是人类内心的黑暗的产物，古今中外的勇者们都试图打倒它。</p>
<p>经过研究，你发现 Dark 呈现无向图的结构，图中有 N 个节点和两类边，一类边被称为主要边，而另一类被称为附加边。</p>
<p>Dark 有 N–1 条主要边，并且 Dark 的任意两个节点之间都存在一条只由主要边构成的路径。</p>
<p>另外，Dark 还有 M 条附加边。</p>
<p>你的任务是把 Dark 斩为不连通的两部分。</p>
<p>一开始 Dark 的附加边都处于无敌状态，你只能选择一条主要边切断。</p>
<p>一旦你切断了一条主要边，Dark 就会进入防御模式，主要边会变为无敌的而附加边可以被切断。</p>
<p>但是你的能力只能再切断 Dark 的一条附加边。</p>
<p>现在你想要知道，一共有多少种方案可以击败 Dark。</p>
<p>注意，就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 N 和 M。</p>
<p>之后 N–1 行，每行包括两个整数 A 和 B，表示 A 和 B 之间有一条主要边。</p>
<p>之后 M 行以同样的格式给出附加边。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数表示答案。</p>
<p><strong>数据范围</strong></p>
<p>N ≤ 100000, M ≤ 200000，数据保证答案不超过 2^31^−1</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>这一题转换一下语言，意思就是有一棵树上还有一些边，属于树的边叫做树边，另外的边叫做非树边，现在要求切断一条树边一条非树边，把这个图分成两个部分</p>
<p>首先明确一点，每个非树边连接的两个点都可由唯一的一条由树边组成的路径连接，这条路径和该非树边组成一个环</p>
<p>我们想要断开这个环，把这个环分成两部分，首先需要切断那一条非树边，然后需要切断任意一条环上的树边，所以我们遍历每一条非树边，然后把这个环上的所有树边标记一次</p>
<ul>
<li>对于没有被标记过的树边，说明只要切断这条树边就可以将图分成两部分，此时再任意切一条非树边就可以了，答案加上非树边的条数</li>
<li>对于只标记过一次的树边，说明需要切断这条树边和另一条对应的非树边，答案加上1</li>
<li>对于标记过两次及以上的树边，此时切断这条树边，会导致原来的两个环合并成一个环，但此时只能再切一条边了，不可能断开形成的新环，所以答案不变</li>
</ul>
<p>于是这一题的问题就转换成了在每一条树边上标记的问题</p>
<p>怎样快速的对图中的边进行标记呢？</p>
<p>这里我们利用<strong>树上差分</strong> 的思路</p>
<p>我们学习过一维数组的差分，将<code>[l, r]</code>上的每个元素都加上相同的元素 c，可以直接将差分数组的 l 加上 c，r + 1 项减去 c</p>
<p>那么在树中，我们要将路径<code>(a, b)</code>上的每条边都加上 c，需要将差分数组的 a，b 项分别加 c，将 ab 的 lca 项减去 2c （差分数组的每一项表示该项编号对应的点与父结点连接的边）</p>
<p><strong>代码</strong>（加了注释）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">2</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N]; <span class="comment">// 存每个结点深度</span></span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">17</span>]; <span class="comment">// f[i][j]：i往上走2^j步所到达的结点</span></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 差分数组</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="comment">// 定义depth和fa</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f3f3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 哨兵和初始化</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">16</span>; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b); <span class="comment">// 先调顺序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k -- ) <span class="comment">// 再调同一层</span></span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b]) a = fa[a][k];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k -- ) <span class="comment">// 再同时往上跳</span></span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span> <span class="comment">// 返回以u为根的子树的d之和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = d[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j, u);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">0</span>) ans += m;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">1</span>) ans ++ ;</span><br><span class="line">            res += s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">        d[a] ++, d[b] ++, d[p] -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最近公共祖先</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>【图论】有向图的强连通分量</title>
    <url>/posts/545a0610.html</url>
    <content><![CDATA[<h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><p><strong>什么是连通分量？</strong></p>
<p>对于一个有向图，分量中任意两点u，v，必然可以从u走到v，且从v走到u，这样的分量叫做连通分量</p>
<p>如果一个连通分量加上任意一个点都不是连通分量了，就把它叫做 <strong>强连通分量</strong></p>
<p>强连通分量的主要作用：将任意一个有向图转化成一个有向无环图即拓扑图（通过缩点的方式），缩点就是将所有连通分量缩成一个点</p>
<p><strong>如何求强连通分量呢？</strong></p>
<p>按照DFS的顺序搜，我们可以将边分为以下四类：</p>
<ol>
<li>树枝边：<code>(x, y)</code>，x是y的父结点</li>
<li>前向边：<code>(x, y)</code>，x是y的祖先结点</li>
<li>后向边：<code>(x, y)</code>，y是x的祖先结点</li>
<li>横叉边：往之前搜过的其他点搜<img src="/posts/545a0610/2.png" class>
<strong>怎么判断一个点是否在强连通分量中？</strong></li>
</ol>
<ul>
<li>情况一：存在后向边指向祖先结点</li>
<li>情况二：先走到横叉边，横叉边再走到祖先结点</li>
</ul>
<p>（反正一定可以走到某个祖先）</p>
<p>基于这个想法—— <strong>&#x3D;&#x3D;Tarjan&#x3D;&#x3D;</strong> 算法求强连通分量（SCC）</p>
<p>先给每个结点按照 DFS 访问顺序确定一个时间戳，时间戳越小说明越先访问到</p>
<p><code>dfn[u]</code>：遍历到 u 的时间戳<br><code>low[u]</code>：从 u 开始走，能遍历到的最小时间戳<br><code>id[i]</code>：i 所在连通分量的编号</p>
<p><strong>u是其所在强连通分量的最高点 &lt;-&gt; <code>dfb[u] == low[u]</code></strong></p>
<h2 id="SCC板子"><a href="#SCC板子" class="headerlink" title="SCC板子"></a>SCC板子</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp; <span class="comment">// 先将dfn和low都初始化为时间戳</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u), in_stk[u] = <span class="literal">true</span>; <span class="comment">// u加入栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 取出u的所有邻点j</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[j]) <span class="comment">// 如果j还没被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]); <span class="comment">// 用low[j]更新low[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]); <span class="comment">// 如果j已入栈 则用dfn[j]更新low[u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) <span class="comment">// 如果该点是所在强连通分量的最高点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt; <span class="comment">// 强连通分量数量加一</span></span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>(); <span class="comment">// 取出栈顶元素</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            id[y] = scc_cnt; <span class="comment">// 标记每个点所在的连通分量编号</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (y != u); <span class="comment">// 直到取到此连通分量的最高点为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缩点的步骤：</strong></p>
<ol>
<li>遍历所有点 i</li>
<li>遍历 i 的所有邻点 j</li>
<li>如果 i 和 j 不在同一个连通分量中，就加一条新边 <code>id[i]-&gt;id[j]</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j]; <span class="comment">// 遍历i的所有邻点k</span></span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[k]; <span class="comment">// 记录ik所在连通分量编号</span></span><br><span class="line">            <span class="keyword">if</span> (a != b) dout[a] ++ ; <span class="comment">// 如果ik不在同一个连通分量 就在两个连通分量之间连一条i指向k的边</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>做完tarjon后，连通分量编号递减的顺序一定就是拓扑序</strong></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="受欢迎的牛"><a href="#受欢迎的牛" class="headerlink" title="受欢迎的牛"></a>受欢迎的牛</h2><p><a href="https://www.acwing.com/problem/content/1176/">原题链接</a></p>
<p>每一头牛的愿望就是变成一头最受欢迎的牛。</p>
<p>现在有 N 头牛，编号从 1 到 N，给你 M 对整数 (A,B)，表示牛 A 认为牛 B 受欢迎。</p>
<p>这种关系是具有传递性的，如果 A 认为 B 受欢迎，B 认为 C 受欢迎，那么牛 A 也认为牛 C 受欢迎。</p>
<p>你的任务是求出有多少头牛被除自己之外的所有牛认为是受欢迎的。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个数 N,M；</p>
<p>接下来 M 行，每行两个数 A,B，意思是 A 认为 B 是受欢迎的（给出的信息有可能重复，即有可能出现多个 A,B）。</p>
<p><strong>输出格式</strong></p>
<p>输出被除自己之外的所有牛认为是受欢迎的牛的数量。</p>
<p><strong>数据范围</strong></p>
<p>$1≤N≤104,$<br>$1≤M≤5×104$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>样例解释</strong></p>
<p>只有第三头牛被除自己之外的所有牛认为是受欢迎的。</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一头牛会欢迎另一头牛，这种欢迎是有传递性的，现给出多对欢迎关系，问有几头牛是被其余所有牛欢迎的</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先对连通分量进行缩点操作</p>
<p>之后分析，如果有唯一一个连通分量满足出度为0，那么这个连通分量内的所有点都可以由其余任意点到达，答案就是这个连通分量内点的个数，如果这样的连通分量超过一个就不满足条件</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">10010</span>, M = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], ne[M], e[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">bool</span> in_stk[N]; <span class="comment">// 存储点是否入栈</span></span><br><span class="line"><span class="type">int</span> id[N], scc_cnt, Size[N];</span><br><span class="line"><span class="type">int</span> dout[N]; <span class="comment">// 连通分量的出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp; <span class="comment">// 先将dfn和low都初始化为时间戳</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u), in_stk[u] = <span class="literal">true</span>; <span class="comment">// u加入栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 取出u的所有邻点j</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[j]) <span class="comment">// 如果j还没被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]); <span class="comment">// 用low[j]更新low[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]); <span class="comment">// 如果j已入栈 则用dfn[j]更新low[u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) <span class="comment">// 如果该点是所在强连通分量的最高点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt; <span class="comment">// 强连通分量数量加一</span></span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>(); <span class="comment">// 取出栈顶元素</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            id[y] = scc_cnt; <span class="comment">// 标记每个点所在的连通分量编号</span></span><br><span class="line">            Size[scc_cnt] ++ ; <span class="comment">// 更新此连通分量中的点个数</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (y != u); <span class="comment">// 直到取到此连通分量的最高点为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j]; <span class="comment">// 遍历i的所有邻点k</span></span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[k]; <span class="comment">// 记录ik所在连通分量编号</span></span><br><span class="line">            <span class="keyword">if</span> (a != b) dout[a] ++ ; <span class="comment">// 如果ik不在同一个连通分量 就在两个连通分量之间连一条i指向k的边</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> zeros = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!dout[i]) <span class="comment">// 如果当前连通分量出度为0</span></span><br><span class="line">        &#123;</span><br><span class="line">            zeros ++ ; <span class="comment">// 出度为0的连通分量个数加一</span></span><br><span class="line">            sum += Size[i]; <span class="comment">// 更新出度为0的连通分量中点的个数</span></span><br><span class="line">            <span class="keyword">if</span> (zeros &gt; <span class="number">1</span>) <span class="comment">// 如果出度为0的连通分量个数超过一个 说明没有一头牛被所有牛喜欢</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="学校网络"><a href="#学校网络" class="headerlink" title="学校网络"></a>学校网络</h2><p><a href="https://www.acwing.com/problem/content/369/">原题链接</a></p>
<p>一些学校连接在一个计算机网络上，学校之间存在软件支援协议，每个学校都有它应支援的学校名单（学校 A 支援学校 B，并不表示学校 B 一定要支援学校 A）。</p>
<p>当某校获得一个新软件时，无论是直接获得还是通过网络获得，该校都应立即将这个软件通过网络传送给它应支援的学校。</p>
<p>因此，一个新软件若想让所有学校都能使用，只需将其提供给一些学校即可。</p>
<p>现在请问最少需要将一个新软件直接提供给多少个学校，才能使软件能够通过网络被传送到所有学校？</p>
<p>最少需要添加几条新的支援关系，使得将一个新软件提供给任何一个学校，其他所有学校就都可以通过网络获得该软件？</p>
<p><strong>输入格式</strong></p>
<p>第 1 行包含整数 N，表示学校数量。</p>
<p>第 2..N+1 行，每行包含一个或多个整数，第 i+1 行表示学校 i 应该支援的学校名单，每行最后都有一个 0 表示名单结束（只有一个 0 即表示该学校没有需要支援的学校）。</p>
<p><strong>输出格式</strong></p>
<p>输出两个问题的结果，每个结果占一行。</p>
<p><strong>数据范围</strong></p>
<p>$2≤N≤100$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一张图：</p>
<ul>
<li>问题一：至少从多少个点出发能够遍历完图上所有点</li>
<li>问题二：至少加多少条边能让图的强连通分量就是自身</li>
</ul>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>设入度为0的连通分量个数为a，出度为0的连通分量个数为b</p>
<p>问题一就是问a的大小</p>
<p>问题二就是问ab中较大的值（需要特判一下如果只有一个强连通分量，就不需要加边，输出0即可 ）<br>举个栗子 不具体证明了：</p>
<img src="/posts/545a0610/1.jpeg" class>

<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">110</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], ne[M], e[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">bool</span> in_stk[N]; <span class="comment">// 存储点是否入栈</span></span><br><span class="line"><span class="type">int</span> id[N], scc_cnt;</span><br><span class="line"><span class="type">int</span> din[N], dout[N]; <span class="comment">// 连通分量的入度和出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp; <span class="comment">// 先将dfn和low都初始化为时间戳</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u), in_stk[u] = <span class="literal">true</span>; <span class="comment">// u加入栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 取出u的所有邻点j</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[j]) <span class="comment">// 如果j还没被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]); <span class="comment">// 用low[j]更新low[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]); <span class="comment">// 如果j已入栈 则用dfn[j]更新low[u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) <span class="comment">// 如果该点是所在强连通分量的最高点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt; <span class="comment">// 强连通分量数量加一</span></span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>(); <span class="comment">// 取出栈顶元素</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            id[y] = scc_cnt; <span class="comment">// 标记每个点所在的连通分量编号</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (y != u); <span class="comment">// 直到取到此连通分量的最高点为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 建图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; t, t) <span class="built_in">add</span>(i, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j]; <span class="comment">// 遍历i的所有邻点k</span></span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[k]; <span class="comment">// 记录ik所在连通分量编号</span></span><br><span class="line">            <span class="keyword">if</span> (a != b) <span class="comment">// 如果ik不在同一个连通分量 就在两个连通分量之间连一条i指向k的边</span></span><br><span class="line">            &#123;</span><br><span class="line">                dout[a] ++ ;</span><br><span class="line">                din[b] ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!din[i]) a ++ ; <span class="comment">// 记录入度为0的点个数</span></span><br><span class="line">        <span class="keyword">if</span> (!dout[i]) b ++ ; <span class="comment">// 记录出度为0的点个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (scc_cnt == <span class="number">1</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大半连通子图"><a href="#最大半连通子图" class="headerlink" title="最大半连通子图"></a>最大半连通子图</h2><p><a href="https://www.acwing.com/problem/content/1177/">原题链接</a></p>
<p>一个有向图 G&#x3D;(V,E) 称为半连通的 (Semi-Connected)，如果满足：∀u,v∈V，满足 u→v 或 v→u，即对于图中任意两点 u,v，存在一条 u 到 v 的有向路径或者从 v 到 u 的有向路径。</p>
<p>若 G′&#x3D;(V′,E′) 满足，E′ 是 E 中所有和 V′ 有关的边，则称 G′ 是 G 的一个导出子图。</p>
<p>若 G′ 是 G 的导出子图，且 G′ 半连通，则称 G′ 为 G 的半连通子图。</p>
<p>若 G′ 是 G 所有半连通子图中包含节点数最多的，则称 G′ 是 G 的最大半连通子图。</p>
<p>给定一个有向图 G，请求出 G 的最大半连通子图拥有的节点数 K，以及不同的最大半连通子图的数目 C。</p>
<p>由于 C 可能比较大，仅要求输出 C 对 X 的余数。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含三个整数 N,M,X。N,M 分别表示图 G 的点数与边数，X 的意义如上文所述；</p>
<p>接下来 M 行，每行两个正整数 a,b，表示一条有向边 (a,b)。</p>
<p>图中的每个点将编号为 1 到 N，保证输入中同一个 (a,b) 不会出现两次。</p>
<p><strong>输出格式</strong></p>
<p>应包含两行。</p>
<p>第一行包含一个整数 K，第二行包含整数 C mod X。</p>
<p><strong>数据范围</strong></p>
<p>$1≤N≤105,$<br>$1≤M≤106,$<br>$1≤X≤108$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">20070603</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">6</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>找出最大的半连通子图，输出节点数和子图个数</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>最大半连通子图就是图上最长的一条链，所以按照以下思路：</p>
<ol>
<li>tarjan</li>
<li>缩点、建图、给边判重</li>
<li>按拓扑序递推</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">100010</span>, M = <span class="number">2000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, mod;</span><br><span class="line"><span class="type">int</span> h[N], hs[N], ne[M], e[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">bool</span> in_stk[N]; <span class="comment">// 存储点是否入栈</span></span><br><span class="line"><span class="type">int</span> id[N], scc_cnt, scc_size[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N]; <span class="comment">// 连通分量的入度和出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp; <span class="comment">// 先将dfn和low都初始化为时间戳</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u), in_stk[u] = <span class="literal">true</span>; <span class="comment">// u加入栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 取出u的所有邻点j</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[j]) <span class="comment">// 如果j还没被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]); <span class="comment">// 用low[j]更新low[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]); <span class="comment">// 如果j已入栈 则用dfn[j]更新low[u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) <span class="comment">// 如果该点是所在强连通分量的最高点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt; <span class="comment">// 强连通分量数量加一</span></span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>(); <span class="comment">// 取出栈顶元素</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            id[y] = scc_cnt; <span class="comment">// 标记每个点所在的连通分量编号</span></span><br><span class="line">            scc_size[scc_cnt] ++ ;</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != u); <span class="comment">// 直到取到此连通分量的最高点为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(hs, <span class="number">-1</span>, <span class="keyword">sizeof</span> hs);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(h, a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;ll&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j]; <span class="comment">// 遍历i的所有邻点k</span></span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[k]; <span class="comment">// 记录ik所在连通分量编号</span></span><br><span class="line">            ll hash = a * <span class="number">1000000ll</span> + b;</span><br><span class="line">            <span class="keyword">if</span> (a != b &amp;&amp; !S.<span class="built_in">count</span>(hash)) <span class="comment">// 如果ik不在同一个连通分量 就在两个连通分量之间连一条i指向k的边</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(hs, a, b);</span><br><span class="line">                S.<span class="built_in">insert</span>(hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = scc_cnt; i; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!f[i]) <span class="comment">// 起点</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = scc_size[i]; <span class="comment">// 更新最大半连通子图内元素个数</span></span><br><span class="line">            g[i] = <span class="number">1</span>; <span class="comment">// 更新最大半连通子图个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = hs[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j];</span><br><span class="line">            <span class="keyword">if</span> (f[k] &lt; f[i] + scc_size[k]) <span class="comment">// 有更优解</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[k] = f[i] + scc_size[k];</span><br><span class="line">                g[k] = g[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f[k] == f[i] + scc_size[k]) <span class="comment">// 有结果一样的解</span></span><br><span class="line">                g[k] = (g[k] + g[i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxf = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (f[i] &gt; maxf)</span><br><span class="line">        &#123;</span><br><span class="line">            maxf = f[i];</span><br><span class="line">            sum = g[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f[i] == maxf) sum = (sum + g[i]) % mod;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; maxf &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="银河"><a href="#银河" class="headerlink" title="银河"></a>银河</h2><p><a href="https://www.acwing.com/problem/content/370/">原题链接</a></p>
<p>银河中的恒星浩如烟海，但是我们只关注那些最亮的恒星。</p>
<p>我们用一个正整数来表示恒星的亮度，数值越大则恒星就越亮，恒星的亮度最暗是 1。</p>
<p>现在对于 N 颗我们关注的恒星，有 M 对亮度之间的相对关系已经判明。</p>
<p>你的任务就是求出这 N 颗恒星的亮度值总和至少有多大。</p>
<p><strong>输入格式</strong></p>
<p>第一行给出两个整数 N 和 M。</p>
<p>之后 M 行，每行三个整数 T,A,B，表示一对恒星 (A,B) 之间的亮度关系。恒星的编号从 1 开始。</p>
<ul>
<li>如果 T&#x3D;1，说明 A 和 B 亮度相等。</li>
<li>如果 T&#x3D;2，说明 A 的亮度小于 B 的亮度。</li>
<li>如果 T&#x3D;3，说明 A 的亮度不小于 B 的亮度。</li>
<li>如果 T&#x3D;4，说明 A 的亮度大于 B 的亮度。</li>
<li>如果 T&#x3D;5，说明 A 的亮度不大于 B 的亮度。</li>
</ul>
<p><strong>输出格式</strong></p>
<p>输出一个整数表示结果。</p>
<p>若无解，则输出 −1。</p>
<p><strong>数据范围</strong></p>
<p>$N≤100000,M≤100000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">1</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> </span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>

<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>求图中有无正环的问题</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>用tarjan求强连通分量</li>
<li>缩点、根据差分约束建图</li>
<li>依据拓扑序递推</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">100010</span>, M = <span class="number">600010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], hs[N], w[M], ne[M], e[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">bool</span> in_stk[N]; <span class="comment">// 存储点是否入栈</span></span><br><span class="line"><span class="type">int</span> id[N], scc_cnt, scc_size[N];</span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 连通分量的入度和出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp; <span class="comment">// 先将dfn和low都初始化为时间戳</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u), in_stk[u] = <span class="literal">true</span>; <span class="comment">// u加入栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 取出u的所有邻点j</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[j]) <span class="comment">// 如果j还没被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]); <span class="comment">// 用low[j]更新low[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]); <span class="comment">// 如果j已入栈 则用dfn[j]更新low[u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) <span class="comment">// 如果该点是所在强连通分量的最高点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt; <span class="comment">// 强连通分量数量加一</span></span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>(); <span class="comment">// 取出栈顶元素</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            id[y] = scc_cnt; <span class="comment">// 标记每个点所在的连通分量编号</span></span><br><span class="line">            scc_size[scc_cnt] ++ ;</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != u); <span class="comment">// 直到取到此连通分量的最高点为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(hs, <span class="number">-1</span>, <span class="keyword">sizeof</span> hs);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">add</span>(h, <span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t, a, b;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="built_in">add</span>(h, b, a, <span class="number">0</span>), <span class="built_in">add</span>(h, a, b, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) <span class="built_in">add</span>(h, a, b, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">3</span>) <span class="built_in">add</span>(h, b, a, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">4</span>) <span class="built_in">add</span>(h, b, a, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(h, a, b, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j]; <span class="comment">// 遍历i的所有邻点k</span></span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[k]; <span class="comment">// 记录ik所在连通分量编号</span></span><br><span class="line">            <span class="keyword">if</span> (a == b) <span class="comment">// ik在同一个强连通分量</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (w[j] &gt; <span class="number">0</span>) <span class="comment">// ik间有权值为正的路径</span></span><br><span class="line">                &#123;</span><br><span class="line">                    success = <span class="literal">false</span>; <span class="comment">// 无解</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">add</span>(hs, a, b, w[j]);<span class="comment">// 如果ik不在同一个连通分量 就在两个连通分量之间连一条i指向k的边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!success) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 有解则求最长路</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = scc_cnt; i; i -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = hs[i]; ~j; j = ne[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k = e[j];</span><br><span class="line">                dist[k] = <span class="built_in">max</span>(dist[k], dist[i] + w[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i ++ ) res += (ll)dist[i] * scc_size[i];</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础算法】二分</title>
    <url>/posts/91181467.html</url>
    <content><![CDATA[<p>二分适用于满足二段性的序列，当一个序列中一段满足条件，另一段不满足条件时可以考虑使用二分来加快查找速度</p>
<h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x 是需要查找的数</span></span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q[mid] &gt;= x) r = mid; <span class="comment">// 符号按需要更改</span></span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure>
<h2 id="符号判断"><a href="#符号判断" class="headerlink" title="符号判断"></a>符号判断</h2><p>二分中使用什么符号曾经困扰了我很久，现总结如下：<br>大原则：<strong>搞不清就带等号</strong>，带等号的时候和字面理解意思相同<br>其中，以下两个式子表示含义相同：</p>
<ul>
<li><strong>&gt;&#x3D;</strong> 会输出满足大于等于条件的第一个数</li>
<li><strong>&lt;</strong> 会输出从后往前看不满足小于条件的第一个数</li>
</ul>
<p>以下两个式子表示含义相同：</p>
<ul>
<li><strong>&lt;&#x3D;</strong> 会输出从后往前看满足小于等于条件的第一个数</li>
<li><strong>&gt;</strong>  会输出不满足条件的最后一个数</li>
</ul>
<p>举个栗子</p>
<blockquote>
<p>现有如下序列：1 2 3 4 5 5 5 6 7 8 9</p>
</blockquote>
<p>现需查找 “5” ——</p>
<ul>
<li>当使用 <strong>&gt;&#x3D;</strong> 时，找到的是第 1 个 5</li>
<li>当使用 <strong>&lt;&#x3D;</strong> 时，找到的是第 3 个 5</li>
<li>当使用 <strong>&gt;</strong> 时，找到的是第 1 个 5</li>
<li>当使用 <strong>&lt;</strong> 时，找到的是第 3 个 5</li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础算法】前缀和与差分</title>
    <url>/posts/470a5ef6.html</url>
    <content><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><p>一维数组中，计算出所有前 n 个数的和，存储在一个单独的数组里，便于后续计算</p>
<h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s[i] 计算的就是前 i 个数的和<br>当我们需要计算第 l 个数到第 r 个数的和时，只需要用 s[r] - s[l - 1] 即可</p>
<h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><p>二维数组中，计算出长为 0 - l， 宽为 0 - r 的矩阵和<br>这个值等于长为 0 - (l - 1) 宽为 0 - r 的矩阵加上 长为 0 - l 宽为 0 - (r - 1) 的矩阵减去 长为 0 - (l - 1) 宽为 0 - (r - 1)的矩阵 最后加上该位置的值</p>
<h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们需要计算左上角坐标为 (x1, y1)， 右下角坐标为 (x2, y2) 的矩阵时，只需要用 s[x2][y2] - s[x1 - 1][y1] - s[x1][y1 - 1] + s[x1 - 1][y1 - 1] 即可</p>
<h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>差分与前缀和是逆运算，数组 a 是数组 b 的前缀和，数组 b 就是数组 a 的差分<br>即<br>a[i] &#x3D; b[0] + b[1] + … + b[i]<br>b[i] &#x3D; a[i] - a[i - 1]</p>
<h2 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h2><p>在一维数组中，将从 l 到 r 的每一个数都加上给定值 c<br>因为在给定区间内的每一个数都加了 c ，所以它们之间的差值不变，只有第 l - 1 与第 i 个数、第 r 与第 r + 1 个数的差值发生了改变，因此修改差分数组时只需要修改两个值，极大提高计算速度<br>适用于需要多次修改数组的情况</p>
<h3 id="板子-2"><a href="#板子-2" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">insert</span>(i, i, a[i]); <span class="comment">// 差分数组的建立</span></span><br><span class="line"><span class="type">int</span> l, r, c;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="built_in">insert</span>(l, r, c); <span class="comment">// 差分数组的修改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) b[i] += b[i - <span class="number">1</span>]; <span class="comment">// 将差分数组恢复成原数组</span></span><br></pre></td></tr></table></figure>
<h2 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h2><p>二维数组中，将长为 0 - l， 宽为 0 - r 的矩阵中每一个元素都加上一个给定值 c<br>对于差分矩阵，需要进行如下操作：</p>
<ul>
<li>b[x1][y1] +&#x3D; c</li>
<li>b[x2 + 1][y2 + 1] +&#x3D; c</li>
<li>b[x2 + 1][y1] -&#x3D; c</li>
<li>b[x1][y2 + 1] -&#x3D; c</li>
</ul>
<h3 id="板子-3"><a href="#板子-3" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        cin &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        <span class="built_in">insert</span>(i, j, i, j, a[i][j]); <span class="comment">// 构造差分数组</span></span><br><span class="line"><span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line"><span class="built_in">insert</span>(x1, y1, x2, y2, c); <span class="comment">// 修改差分数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 恢复原数组</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>前缀和</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础算法】逆序对</title>
    <url>/posts/5ccba1a0.html</url>
    <content><![CDATA[<p><strong>逆序对</strong>，简单来说，就是<code>i &gt; j</code>*，但<code>a[i] &lt; a[j]</code>，那么<code>a[i] 和 a[j]</code>就是一组逆序对</p>
<p>求逆序对有三种方式——</p>
<ul>
<li>暴力 复杂度 O(n^2^) 谁用谁T 不多赘述了</li>
<li>归并排序 复杂度 O(nlogn)</li>
<li>树状数组 复杂度 O(nlogn)</li>
</ul>
<p><strong>归并排序</strong></p>
<p>首先看一下归并排序的原理，就是将一个序列无限二分，直到每一部分都只有一个元素，这时每一部分都有序，然后逐次合并相邻部分，让合并后的各个部分有序<br>举个栗子<br>现在我们要合并两个部分：1 3 5 7 9 | 2 4 6 8 10<br>先比较 1、2，发现 1 &lt; 2，所以把 1 先放到合并后的数组里<br>现在剩下的两部分是：3 5 7 9 | 2 4 6 8 10<br>现在比较3、2，发现 3 &gt; 2，所以把 2 放到合并后的数组，由于左半部分是有序的，所以 2 小于左半部分剩下的所有数，但 2 又在左半边剩下的所有数后面，所以 2 和这些数都构成逆序对，逆序对的数量就是<code>mid - i</code><br>每一次右半部分的第一个数小于左半部分的第一个数时，右半部分的第一个数和左半部分剩下的所有数都构成逆序对，因此在原来的基础上加上<code>mid - i</code>即可</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> a[N], temp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_pai</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = l, j = mid, p = l;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; a[j]) temp[p ++ ] = a[i ++ ];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			temp[p ++ ] = a[j ++ ];</span><br><span class="line">			ans += mid - i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; mid) temp[p ++ ] = a[i ++ ];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r) temp[p ++ ] = a[j ++ ];</span><br><span class="line">	p = l;</span><br><span class="line">	<span class="keyword">while</span> (p &lt; mid) a[p ++ ] = temp[p ++ ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">merge_sort</span>(l, mid);</span><br><span class="line">		<span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">		<span class="built_in">merge_pai</span>(l, r, mid + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">merge_sort</span>(<span class="number">1</span>, n);</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>树状数组</strong></p>
<p>树状数组的原理在这里就不多说啦，如果有不懂的同学可以去看看<a href="https://blog.csdn.net/dhxbshbdjzxy/article/details/131718607?spm=1001.2014.3001.5502">这篇</a></p>
<p>建立一个数组<code>c[i]</code>，表示元素 i 出现的次数，起初每一项都为0<br>同时我们也可以得到<code>c[i]</code>的树状数组<code>tree[i]</code><br>每次插入一个数 x ，我们都将利用树状数组单点修改的性质更新<code>tree[i]</code>的值，此时区间查询<code>c[i - 1]</code>的前缀和，我们就可以得到在 x 前输出，比 x 的值小的元素个数，用总共输入的元素个数和它相减，就可以得到<strong>在 x 前输出，且比 x 大的元素个数</strong>，这也就是逆序对的个数了<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= N)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[i] += x;</span><br><span class="line">		i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefix_sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		presum += tree[i];</span><br><span class="line">		i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> presum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> a[n + <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		<span class="built_in">add</span>(a[i], <span class="number">1</span>);</span><br><span class="line">		ans += (i - <span class="built_in">prefix_sum</span>(a[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础算法】高精度</title>
    <url>/posts/40a4a6dc.html</url>
    <content><![CDATA[<p>当比赛中给定数字位数过多，无法直接进行加减乘除运算时，使用高精度计算</p>
<h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p>高精度加法相当于一个列竖式计算的过程，从最低位开始（因此所有数都要倒着存），遇十进位</p>
<h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">//记录进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i ++ ) <span class="comment">// 就是一个竖式计算的过程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="comment">// 将a、b倒着存进去，便于从低位开始进行运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B); <span class="comment">// C 也是倒着存储的 所以下面倒着输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><p>高精度减法也是相当于一个列竖式计算的过程，用大数减小数，从最低位开始（因此所有数都要倒着存），不够减就借位</p>
<h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较AB大小 用大数减小数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 位数不等，位数多的大</span></span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 位数相等，从高位开始判断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- )</span><br><span class="line">    	<span class="keyword">if</span> (A[i] != B[i]) <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 存储计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t; <span class="comment">// 先处理借位情况</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i]; <span class="comment">// B还没减完时</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>); <span class="comment">// 防止t小于0</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>; <span class="comment">// 说明不够减要借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>; <span class="comment">// 无需借位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 除去前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先判断AB大小，确保大数减小数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B, A);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><p>高精度乘法要求其中的一个数是 int 类型，同样是列竖式计算的过程</p>
<h3 id="板子-2"><a href="#板子-2" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 存储计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">// 低位开始，每次取结果的个位存进C中</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 删去前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><p>同样是竖式计算的过程，要求除数是 int 类型</p>
<h3 id="板子-3"><a href="#板子-3" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>; <span class="comment">// 记录余数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i]; <span class="comment">// 余数乘10加新一位</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b; <span class="comment">// 更新余数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>()); <span class="comment">// 翻转C便于删去前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> r; <span class="comment">// 余数</span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>【搜索】BFS中的最短路模型</title>
    <url>/posts/922f99a.html</url>
    <content><![CDATA[<p>BFS可以解决边权为1的最短路问题，下面是相关例题</p>
<h1 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h1><p>将源点在开始时存进队列</p>
<h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><p><a href="https://www.acwing.com/problem/content/1078/">原题链接</a></p>
<p>给定一个 n×n 的二维数组，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maze[5][5] = &#123;</span><br><span class="line"></span><br><span class="line">0, 1, 0, 0, 0,</span><br><span class="line"></span><br><span class="line">0, 1, 0, 1, 0,</span><br><span class="line"></span><br><span class="line">0, 0, 0, 0, 0,</span><br><span class="line"></span><br><span class="line">0, 1, 1, 1, 0,</span><br><span class="line"></span><br><span class="line">0, 0, 0, 1, 0,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。</p>
<p>数据保证至少存在一条从左上角走到右下角的路径。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 n。</p>
<p>接下来 n 行，每行包含 n 个整数 0 或 1，表示迷宫。</p>
<p><strong>输出格式</strong></p>
<p>输出从左上角到右下角的最短路线，如果答案不唯一，输出任意一条路径均可。</p>
<p>按顺序，每行输出一个路径中经过的单元格的坐标，左上角坐标为 (0,0)，右下角坐标为 (n−1,n−1)。</p>
<p><strong>数据范围</strong></p>
<p>0 ≤ n ≤ 1000</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个矩阵，0代表有路1代表没有路，问从左上角走到右下角的最短路径</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为边权均为1，所以利用BFS可以求出从起点到终点的最短路，同时利用一个小技巧从终点往起点走，即可在后续输出路径时正向输出</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line">PII pre[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 代表上下左右四个移动方向</span></span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            <span class="keyword">if</span> (g[a][b]) <span class="keyword">continue</span>; <span class="comment">// 没路</span></span><br><span class="line">            <span class="keyword">if</span> (pre[a][b].ft != <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 走过了</span></span><br><span class="line">            </span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">            pre[a][b] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>(n - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">PII <span class="title">end</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; end.ft &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; end.sd &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (end.ft == n - <span class="number">1</span> &amp;&amp; end.sd == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        end = pre[end.ft][end.sd];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="武士风度的牛"><a href="#武士风度的牛" class="headerlink" title="武士风度的牛"></a>武士风度的牛</h2><p><a href="https://www.acwing.com/problem/content/190/">原题链接</a></p>
<p>农民 John 有很多牛，他想交易其中一头被 Don 称为 The Knight 的牛。</p>
<p>这头牛有一个独一无二的超能力，在农场里像 Knight 一样地跳（就是我们熟悉的象棋中马的走法）。</p>
<p>虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个 x，y 的坐标图来表示。</p>
<p>这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了 The Knight 的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。</p>
<p>现在你的任务是，确定 The Knight 要想吃到草，至少需要跳多少次。</p>
<p>The Knight 的位置用 K 来标记，障碍的位置用 * 来标记，草的位置用 H 来标记。</p>
<p>这里有一个地图的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11 | . . . . . . . . . .</span><br><span class="line">10 | . . . . * . . . . . </span><br><span class="line"> 9 | . . . . . . . . . . </span><br><span class="line"> 8 | . . . * . * . . . . </span><br><span class="line"> 7 | . . . . . . . * . . </span><br><span class="line"> 6 | . . * . . * . . . H </span><br><span class="line"> 5 | * . . . . . . . . . </span><br><span class="line"> 4 | . . . * . . . * . . </span><br><span class="line"> 3 | . K . . . . . . . . </span><br><span class="line"> 2 | . . . * . . . . . * </span><br><span class="line"> 1 | . . * . . . . * . . </span><br><span class="line"> 0 ----------------------</span><br><span class="line">                       1 </span><br><span class="line">   0 1 2 3 4 5 6 7 8 9 0 </span><br></pre></td></tr></table></figure>
<p>The Knight 可以按照下图中的 A,B,C,D… 这条路径用 5 次跳到草的地方（有可能其它路线的长度也是 5）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11 | . . . . . . . . . .</span><br><span class="line">10 | . . . . * . . . . .</span><br><span class="line"> 9 | . . . . . . . . . .</span><br><span class="line"> 8 | . . . * . * . . . .</span><br><span class="line"> 7 | . . . . . . . * . .</span><br><span class="line"> 6 | . . * . . * . . . F&lt;</span><br><span class="line"> 5 | * . B . . . . . . .</span><br><span class="line"> 4 | . . . * C . . * E .</span><br><span class="line"> 3 | .&gt;A . . . . D . . .</span><br><span class="line"> 2 | . . . * . . . . . *</span><br><span class="line"> 1 | . . * . . . . * . .</span><br><span class="line"> 0 ----------------------</span><br><span class="line">                       1</span><br><span class="line">   0 1 2 3 4 5 6 7 8 9 0</span><br></pre></td></tr></table></figure>
<p>注意： 数据保证一定有解。</p>
<p><strong>输入格式</strong></p>
<p>第 1 行： 两个数，表示农场的列数 C 和行数 R。</p>
<p>第 2..R+1 行: 每行一个由 C 个字符组成的字符串，共同描绘出牧场地图。</p>
<p><strong>输出格式</strong></p>
<p>一个整数，表示跳跃的最小次数。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ R , C ≤ 150</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">11</span></span><br><span class="line">..........</span><br><span class="line">....*.....</span><br><span class="line">..........</span><br><span class="line">...*.*....</span><br><span class="line">.......*..</span><br><span class="line">..*..*...H</span><br><span class="line">*.........</span><br><span class="line">...*...*..</span><br><span class="line">.K........</span><br><span class="line">...*.....*</span><br><span class="line">..*....*..</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>图中<code>*</code>代表没有路，<code>.</code>代表有路，求以日字型从K走到H的最短路</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>dx dy改成向八个不同方向移，其余思路一样，第一次遍历到H时输出即可</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">155</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// 记录距离+判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">                x = i, y = j;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[x][y] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>; <span class="comment">// 没路</span></span><br><span class="line">            <span class="keyword">if</span> (dist[a][b] != <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;H&#x27;</span>) <span class="keyword">return</span> dist[t.ft][t.sd] + <span class="number">1</span>; <span class="comment">// 走到终点</span></span><br><span class="line"></span><br><span class="line">            dist[a][b] = dist[t.ft][t.sd] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抓住那头牛"><a href="#抓住那头牛" class="headerlink" title="抓住那头牛"></a>抓住那头牛</h2><p><a href="https://www.acwing.com/problem/content/1102/">原题链接</a></p>
<p>农夫知道一头牛的位置，想要抓住它。</p>
<p>农夫和牛都位于数轴上，农夫起始位于点 N，牛位于点 K。</p>
<p>农夫有两种移动方式：</p>
<ol>
<li>从 X 移动到 X−1 或 X+1，每次移动花费一分钟</li>
<li>从 X 移动到 2∗X，每次移动花费一分钟</li>
</ol>
<p>假设牛没有意识到农夫的行动，站在原地不动。</p>
<p>农夫最少要花多少时间才能抓住牛？</p>
<p><strong>输入格式</strong></p>
<p>共一行，包含两个整数N和K。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示抓到牛所花费的最少时间。</p>
<p><strong>数据范围</strong></p>
<p>0 ≤ N , K ≤ 105</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">17</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>要求从N到K，每次只能进行一个操作：向右一步 &#x2F; 向左一步 &#x2F; 坐标变为现在的两倍，求最短路</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这一题刚开始看第一反应是dp，但后来发现BFS最短路来做也很简单</p>
<p>每次更新所有该轮操作可以到达的位置</p>
<p>无需更新负值，因为只能通过-1到达负值，而从负值到正值只能通过+1，二者相互抵消，不可能是最短路</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[n] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t == k) <span class="keyword">return</span> dist[k]; <span class="comment">// 已到终点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新三个距离</span></span><br><span class="line">        <span class="keyword">if</span> (t + <span class="number">1</span> &lt; N &amp;&amp; dist[t + <span class="number">1</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t + <span class="number">1</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t - <span class="number">1</span> &lt; N &amp;&amp; dist[t - <span class="number">1</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t - <span class="number">1</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t * <span class="number">2</span> &lt; N &amp;&amp; dist[t * <span class="number">2</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t * <span class="number">2</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h1><p>设置虚拟源点，到所有源点的距离都为0，也就是在起始时将每一个起点都存进队列</p>
<h2 id="矩阵距离"><a href="#矩阵距离" class="headerlink" title="矩阵距离"></a>矩阵距离</h2><p><a href="https://www.acwing.com/problem/content/175/">原题链接</a></p>
<p>给定一个 N 行 M 列的 01 矩阵 A，A[i][j] 与 A[k][l] 之间的曼哈顿距离定义为：</p>
<p><code>dist(A[i][j], A[k][l]) = |i − k| + |j − l|</code></p>
<p>输出一个 N 行 M 列的整数矩阵 B，其中：</p>
<p><code>B[i][j] = min~1≤x≤N,1≤y≤M,A[x][y]=1~ dist(A[i][j], A[x][y])</code></p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数 N,M。</p>
<p>接下来一个 N 行 M 列的 01 矩阵，数字之间没有空格。</p>
<p><strong>输出格式</strong></p>
<p>一个 N 行 M 列的矩阵 B，相邻两个整数之间用一个空格隔开。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ N, M ≤ 1000</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">0001</span></span><br><span class="line"><span class="number">0011</span></span><br><span class="line"><span class="number">0110</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个矩阵，求所有0距离最近的1的曼哈顿距离</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>设置虚拟源点，先将所有的1入队，更新所有0到达1的最短距离输出即可</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 所有源点入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            <span class="keyword">if</span> (dist[a][b] != <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 已被遍历</span></span><br><span class="line"></span><br><span class="line">            dist[a][b] = dist[t.ft][t.sd] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            cout &lt;&lt; dist[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="双端队列BFS"><a href="#双端队列BFS" class="headerlink" title="双端队列BFS"></a>双端队列BFS</h1><h2 id="电路维修"><a href="#电路维修" class="headerlink" title="电路维修"></a>电路维修</h2><p><a href="https://www.acwing.com/problem/content/177/">原题链接</a></p>
<p>达达是来自异世界的魔女，她在漫无目的地四处漂流的时候，遇到了善良的少女翰翰，从而被收留在地球上。</p>
<p>翰翰的家里有一辆飞行车。</p>
<p>有一天飞行车的电路板突然出现了故障，导致无法启动。</p>
<p>电路板的整体结构是一个 R 行 C 列的网格（R,C≤500），如下图所示。</p>
<img src="/posts/922f99a/1.png" class>


<p>每个格点都是电线的接点，每个格子都包含一个电子元件。</p>
<p>电子元件的主要部分是一个可旋转的、连接一条对角线上的两个接点的短电缆。</p>
<p>在旋转之后，它就可以连接另一条对角线的两个接点。</p>
<p>电路板左上角的接点接入直流电源，右下角的接点接入飞行车的发动装置。</p>
<p>达达发现因为某些元件的方向不小心发生了改变，电路板可能处于断路的状态。</p>
<p>她准备通过计算，旋转最少数量的元件，使电源与发动装置通过若干条短缆相连。</p>
<p>不过，电路的规模实在是太大了，达达并不擅长编程，希望你能够帮她解决这个问题。</p>
<p>注意：只能走斜向的线段，水平和竖直线段不能走。</p>
<p><strong>输入格式</strong></p>
<p>输入文件包含多组测试数据。</p>
<p>第一行包含一个整数 T，表示测试数据的数目。</p>
<p>对于每组测试数据，第一行包含正整数 R 和 C，表示电路板的行数和列数。</p>
<p>之后 R 行，每行 C 个字符，字符是”&#x2F;“和”&quot;中的一个，表示标准件的方向。</p>
<p><strong>输出格式</strong></p>
<p>对于每组测试数据，在单独的一行输出一个正整数，表示所需的最小旋转次数。</p>
<p>如果无论怎样都不能使得电源和发动机之间连通，输出 NO SOLUTION。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ R , C ≤ 500,<br>1 ≤ T ≤ 5</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line">\\/\\</span><br><span class="line">\\<span class="comment">///</span></span><br><span class="line">/\\\\</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>样例解释</strong></p>
<p>样例的输入对应于题目描述中的情况。</p>
<p>只需要按照下面的方式旋转标准件，就可以使得电源和发动机之间连通。</p>
<img src="/posts/922f99a/2.png" class>

<h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>从左上角走到右下角，只能走斜线，使斜线方向改变需要消耗1，问消耗最少的路径</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>首先转换一些题目语言，我们可以理解为，不需要改变斜线方向时边权是0，需要改变斜线方向时边权是1，那这个问题就转换成了边权是0 &#x2F; 1 的最短路问题，用Dijkstra是可以解决的</p>
<p>那能不能用BFS解决呢？</p>
<p>当然也可以，考虑到BFS中队列的二段性，本题我们使用双端队列，每次将边权为0的边放到队头，边权为1的边放到队尾（感觉有点贪心的思想）</p>
<p>（另外，绝对不会出现一条边未转换时走一次，然后转换了再走一次的情况，因为图中总有一半的点是走不到的</p>
<p>接下来的难点在于图的存储，需要对点和格子分别作出记录</p>
<h3 id="代码（加了注释）"><a href="#代码（加了注释）" class="headerlink" title="代码（加了注释）"></a>代码（加了注释）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图上的每条边</span></span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// 存每个点到起点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    deque&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cs[] = <span class="string">&quot;\\/\\/&quot;</span>; <span class="comment">// 分别表示往左上角、右上角、右下角、左下角走</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;; <span class="comment">// 进行这些操作点坐标的改变</span></span><br><span class="line">    <span class="type">int</span> ix[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, iy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 进行这些操作需要踩过哪些格子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[t.ft][t.sd]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t.ft][t.sd] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i]; <span class="comment">// 点坐标</span></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt; n || b &lt; <span class="number">0</span> || b &gt; m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> aa = t.ft + ix[i], bb = t.sd + iy[i]; <span class="comment">// 格子坐标</span></span><br><span class="line">            <span class="type">int</span> d = dist[t.ft][t.sd] + (g[aa][bb] != cs[i]); <span class="comment">// 原有距离加上当前格子的边权</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d &lt; dist[a][b]) <span class="comment">// 如果距离更小就更新</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[a][b] = d;</span><br><span class="line">                <span class="comment">// 根据边权情况选择加入队头or队尾</span></span><br><span class="line">                <span class="keyword">if</span> (g[aa][bb] != cs[i]) q.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_front</span>(&#123;a, b&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">&quot;NO SOLUTION\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>BFS</tag>
        <tag>广度优先搜索</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>【搜索】DFS剪枝与优化</title>
    <url>/posts/2e580918.html</url>
    <content><![CDATA[<p><strong>剪枝</strong>是什么意思呢？</p>
<p>我们知道，不管是内部搜索还是外部搜索，都可以形成一棵搜索树，如果将搜索树全部遍历一遍，效率会很低，但如果我们能在搜索的过程中，提前预知，判断某一些不可能是正确答案的情况，就可以不用遍历其下的子树，从而提高我们的算法效率</p>
<p>我们可以从以下几个角度考虑剪枝：</p>
<ol>
<li>优化搜索顺序<br>优先选择分支较少的结点</li>
<li>排除等效冗余<br>尽量保证不搜索重复的状态（就是在不考虑顺序时，采用组合的方式搜索）</li>
<li>可行性剪枝<br>不合法提前退出</li>
<li>最优性剪枝<br>如果当前答案无论如何都比目前的最优解要差，那就可以不要往下搜了</li>
<li>记忆化搜索（DP）</li>
</ol>
<p>接下来将通过例题来讲解</p>
<h1 id="小猫爬山"><a href="#小猫爬山" class="headerlink" title="小猫爬山"></a>小猫爬山</h1><p><a href="https://www.acwing.com/problem/content/167/">原题链接</a></p>
<p>翰翰和达达饲养了 N 只小猫，这天，小猫们要去爬山。</p>
<p>经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕&gt;_&lt;）。</p>
<p>翰翰和达达只好花钱让它们坐索道下山。</p>
<p>索道上的缆车最大承重量为 W，而 N 只小猫的重量分别是 C1、C2……CN。</p>
<p>当然，每辆缆车上的小猫的重量之和不能超过 W。</p>
<p>每租用一辆缆车，翰翰和达达就要付 1 美元，所以他们想知道，最少需要付多少美元才能把这 N 只小猫都运送下山？</p>
<p><strong>输入格式</strong></p>
<p>第 1 行：包含两个用空格隔开的整数，N 和 W。</p>
<p>第 2..N+1 行：每行一个整数，其中第 i+1 行的整数表示第 i 只小猫的重量 Ci。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ N ≤ 18,<br>1 ≤ C<del>i</del> ≤ W ≤ 108</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">1996</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1994</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出小猫重量、缆车承重，问最少要多少缆车能把所有小猫运走</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>枚举每只小猫，有两种状态：</p>
<ul>
<li>放到当前这辆车上</li>
<li>新开一辆车</li>
</ul>
<p><strong>优化：</strong> </p>
<ol>
<li>优化搜索顺序：比较一只比较轻的猫和另一只比较重的猫，显然是比较重的猫带来的分支数量较少，因为如果猫非常重可以直接把车占满，但是猫很轻的话我们就要考虑还要加什么别的猫，因此：将所有猫按从大到小排序，优先放重猫</li>
<li>可行性剪枝：当发现目前小猫的重量已经超过缆车承重，就不要再往下搜了</li>
<li>最优性剪枝：当发现目前缆车数量已经大于等于当前计算出的缆车最少数量，就不要再搜索了</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> ans = N; <span class="comment">// 最坏的情况:每只小猫占一辆车</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span> <span class="comment">// u:当前在搜第几只猫 k:当前在搜第几辆车</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 最优性剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ ) <span class="comment">// 遍历每一辆车</span></span><br><span class="line">        <span class="comment">// 可行性剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (sum[i] + w[u] &lt;= m) <span class="comment">// 称重符合条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum[i] += w[u];</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, k);</span><br><span class="line">            sum[i] -= w[u]; <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新开一辆车</span></span><br><span class="line">    sum[k] = w[u];</span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">    sum[k] = <span class="number">0</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化搜索顺序</span></span><br><span class="line">    <span class="built_in">sort</span>(w, w + n);</span><br><span class="line">    <span class="built_in">reverse</span>(w, w + n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数独"><a href="#数独" class="headerlink" title="数独"></a>数独</h1><p><a href="https://www.acwing.com/problem/content/168/">原题链接</a></p>
<p>数独是一种传统益智游戏，你需要把一个 9×9 的数独补充完整，使得数独中每行、每列、每个 3×3 的九宫格内数字 1∼9 均恰好出现一次。</p>
<p>请编写一个程序填写数独。</p>
<p><strong>输入格式</strong></p>
<p>输入包含多组测试用例。</p>
<p>每个测试用例占一行，包含 81 个字符，代表数独的 81 个格内数据（顺序总体由上到下，同行由左到右）。</p>
<p>每个字符都是一个数字（1−9）或一个 .（表示尚未填充）。</p>
<p>您可以假设输入中的每个谜题都只有一个解决方案。</p>
<p>文件结尾处为包含单词 end 的单行，表示输入结束。</p>
<p><strong>输出格式</strong></p>
<p>每个测试用例，输出一行数据，代表填充完全后的数独。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4.</span>...<span class="number">.8</span><span class="number">.5</span><span class="number">.3</span>.........<span class="number">.7</span>.....<span class="number">.2</span>....<span class="number">.6</span>....<span class="number">.8</span><span class="number">.4</span>.....<span class="number">.1</span>......<span class="number">.6</span><span class="number">.3</span><span class="number">.7</span><span class="number">.5</span>.<span class="number">.2</span>....<span class="number">.1</span><span class="number">.4</span>......</span><br><span class="line">.....<span class="number">.52</span>.<span class="number">.8</span><span class="number">.4</span>.....<span class="number">.3</span>..<span class="number">.9</span>..<span class="number">.5</span><span class="number">.1</span>..<span class="number">.6</span>.<span class="number">.2</span>.<span class="number">.7</span>.......<span class="number">.3</span>....<span class="number">.6</span>..<span class="number">.1</span>.........<span class="number">.7</span><span class="number">.4</span>......<span class="number">.3</span>.</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">417369825632158947958724316825437169791586432346912758289643571573291684164875293</span></span><br><span class="line"><span class="number">416837529982465371735129468571298643293746185864351297647913852359682714128574936</span></span><br></pre></td></tr></table></figure>
<h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>填好数独，保证每行每列、每个3x3方块都包含1-9</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>先做一个小优化，看比如说一个3x3小方格中有哪些数字没被用过，随意选择一个格子，然后对这些数字依次枚举搜索即可</p>
<p><strong>优化：</strong></p>
<ol>
<li>优化搜索顺序：选择格子时，尽量选择分支数量较少的格子，比如说一个格子有2种填法，另一个格子有5种，那肯定优先选择2种的</li>
<li>可行性剪枝：一旦与行列九宫格重复时就不要继续搜了</li>
<li>&#x3D;&#x3D;<strong>位运算优化：</strong>&#x3D;&#x3D; 特殊优化，可以用一个九位的二进制数表示每一行数使用的状态<br>比如：0 1 0 0 1 1 1 0 0 可以用来表示2 5 6 7还没用其他数字用过了<br>我们考虑这一位上能不能填这个数时，应该考虑二进制数的交集，即在行、列、九宫格的二进制数列上，这个数字都为1，表示在行、列、九宫格内这个数字都没有被使用，我们才能用这个数（直接按位与&amp;）<br>这里有个比循环九次更好的办法——<strong>lowbit</strong><br>lowbit运算可以帮助我们在O(1)的时间复杂度内，返回当前数里的最后一个1，因此用lowbit循环就可以抠出来所有的1</li>
</ol>
<p>好难啊好难啊qaq看代码注释吧还是</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">9</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ones[M]; <span class="comment">// 每个二进制数里1的个数</span></span><br><span class="line"><span class="type">int</span> mapp[M]; <span class="comment">// 把二进制数换成第几位是1</span></span><br><span class="line"><span class="type">int</span> row[N], col[N], cell[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 初始化，将所有位置都标记成没用过(也就是标记成1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ ) row[i] = col[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            cell[i][j] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> t, <span class="type">bool</span> is_set)</span> <span class="comment">// 在(x,y)这个位置填上/删去t 填上的话is_set为true 删去为false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_set) str[x * N + y] = <span class="string">&#x27;1&#x27;</span> + t; <span class="comment">// t属于0-8 要把它换算成1-9</span></span><br><span class="line">    <span class="keyword">else</span> str[x * N + y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span> &lt;&lt; t; <span class="comment">// t换算到在每一行的位置</span></span><br><span class="line">    <span class="keyword">if</span> (!is_set) v = -v; <span class="comment">// 若为清空操作则取反</span></span><br><span class="line"></span><br><span class="line">    row[x] -= v;</span><br><span class="line">    col[y] -= v;</span><br><span class="line">    cell[x / <span class="number">3</span>][y / <span class="number">3</span>] -= v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 返回二进制数的最后一个1以及这个1之后的所有0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">// 返回(x,y)能填的数字(二进制序列)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x / <span class="number">3</span>][y / <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cnt) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 全部填完</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> minv = <span class="number">10</span>; <span class="comment">// 首先找分支数最少的空格，将最少的分支数赋给maxx</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (str[i * N + j] == <span class="string">&#x27;.&#x27;</span>) <span class="comment">// 格子为空可以填数字</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> state = <span class="built_in">get</span>(i, j); <span class="comment">// 该格子能填的数字的交集</span></span><br><span class="line">                <span class="keyword">if</span> (ones[state] &lt; minv)</span><br><span class="line">                &#123;</span><br><span class="line">                    minv = ones[state]; <span class="comment">// 更新最少分支数</span></span><br><span class="line">                    x = i, y = j; <span class="comment">// xy存的就是分支数量最少的格子的坐标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> state = <span class="built_in">get</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = state; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = mapp[<span class="built_in">lowbit</span>(i)]; <span class="comment">// 得到最后一个1所在的位置</span></span><br><span class="line">        <span class="built_in">draw</span>(x, y, t, <span class="literal">true</span>); <span class="comment">// 把t填进去</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(cnt - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 成功直接返回true</span></span><br><span class="line">        <span class="built_in">draw</span>(x, y, t, <span class="literal">false</span>); <span class="comment">// 失败就把填进去的值再删掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打表得到ones和mapp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ ) mapp[<span class="number">1</span> &lt;&lt; i] = i; <span class="comment">// 将所有2^k转化成k(也就是返回二进制数里唯一一个1的位置)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; N; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">            ones[i] += i &gt;&gt; j &amp; <span class="number">1</span>; <span class="comment">// 记下每个二进制数里1的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; str, str[<span class="number">0</span>] != <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 有多少位置没填</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++, k ++ )</span><br><span class="line">                <span class="keyword">if</span> (str[k] != <span class="string">&#x27;.&#x27;</span>) <span class="comment">// 位置不空就把值填进去</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> t = str[k] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="built_in">draw</span>(i, j, t, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++ ; <span class="comment">// 位置空就累加空位的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(cnt);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="木棒"><a href="#木棒" class="headerlink" title="木棒"></a>木棒</h1><p><a href="https://www.acwing.com/problem/content/169/">原题链接</a></p>
<p>乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过 50 个长度单位。</p>
<p>然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。</p>
<p>请你设计一个程序，帮助乔治计算木棒的可能最小长度。</p>
<p>每一节木棍的长度都用大于零的整数表示。</p>
<p><strong>输入格式</strong></p>
<p>输入包含多组数据，每组数据包括两行。</p>
<p>第一行是一个不超过 64 的整数，表示砍断之后共有多少节木棍。</p>
<p>第二行是截断以后，所得到的各节木棍的长度。</p>
<p>在最后一组数据之后，是一个零。</p>
<p><strong>输出格式</strong></p>
<p>为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。</p>
<p><strong>数据范围</strong></p>
<p>数据保证每一节木棍的长度均不大于 50。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出一些数，将其分成若干组，使每一组总和相等，问最小的总和是多少</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>木棒：每一组的总和<br>木棍：题目中输入的数据</p>
<p>先从小到大枚举木棒的长度length，看木棍能不能组成该长度的木棒</p>
<p><strong>优化：</strong></p>
<ol>
<li>所有木棍的总长度sum必须能整除木棒的长度length，才可能有解，不能整除的情况直接回溯不要搜了</li>
<li>优化搜索顺序：先枚举比较长的木棍，使之后的分支较少</li>
<li>排除等效冗余：<br>(1) 如果一根木棒里有第一根第二根两根木棍，那么先用第一根和先用第二根达成的效果都是一样的，因此按照组合数方式枚举<br>(2) 如果当前木棍加到当前木棒中失败，那直接略过后面所有等长木棍<br>(3) 如果是木棒的第一根木棍失败（说明这根木棍没地方放），则当前状态一定失败，直接回溯不要往下搜了<br>(4) 如果是木棒的最后一根木棍失败（这里的意思是往下dfs找不到解），则当前状态一定失败（因为放入比这根木棍小的木棍拼接起来的也一定找不到解），直接回溯不要往下搜了</li>
</ol>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N], sum, length; <span class="comment">// w[i]:每根小棍长度 sum:所有小棍总长度 length:每组总和</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 小棍有没有用过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s, <span class="type">int</span> start)</span> <span class="comment">// u:当前枚举到哪根大棍 s:当前大棍长度 start:开始位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u * length == sum) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 符合条件</span></span><br><span class="line">    <span class="keyword">if</span> (s == length) <span class="keyword">return</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 这根木棍长度已达要求，开下一根木棍</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化3(1):从start开始枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i ++ ) <span class="comment">// 从start开始遍历木棍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line">        <span class="keyword">if</span> (s + w[i] &gt; length) <span class="keyword">continue</span>; <span class="comment">// 可行性剪枝</span></span><br><span class="line"></span><br><span class="line">        st[i] = <span class="literal">true</span>; <span class="comment">// 更改状态</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(u, s + w[i], i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 下一层遍历</span></span><br><span class="line">        st[i] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化3(3):开头不行就一定不行</span></span><br><span class="line">        <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化3(4):结尾不行就一定不行</span></span><br><span class="line">        <span class="keyword">if</span> (s + w[i] == length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化3(2):等长直接略过</span></span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; w[j] == w[i]) j ++ ;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; w[i];</span><br><span class="line">            sum += w[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化2：搜索顺序</span></span><br><span class="line">        <span class="built_in">sort</span> (w, w + n);</span><br><span class="line">        <span class="built_in">reverse</span>(w, w + n);</span><br><span class="line"></span><br><span class="line">        length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 优化1:必须是整数倍</span></span><br><span class="line">            <span class="keyword">if</span> (sum % length == <span class="number">0</span> &amp;&amp; <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; length &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            length ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生日蛋糕"><a href="#生日蛋糕" class="headerlink" title="生日蛋糕"></a>生日蛋糕</h1><p><a href="https://www.acwing.com/problem/content/170/">原题链接</a></p>
<p>7 月 17 日是 Mr.W 的生日，ACM-THU 为此要制作一个体积为 Nπ 的 M 层生日蛋糕，每层都是一个圆柱体。</p>
<p>设从下往上数第 i 层蛋糕是半径为 Ri，高度为 Hi 的圆柱。</p>
<p>当 $i&lt;M$ 时，要求 $Ri&gt;Ri+1$ 且 H<del>i</del> &gt; H<del>i+1</del>。</p>
<p>由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积 Q 最小。</p>
<p>令 $Q&#x3D;Sπ$ ，请编程对给出的 N 和 M，找出蛋糕的制作方案（适当的 Ri 和 Hi 的值），使 S 最小。</p>
<p>除 Q 外，以上所有数据皆为正整数。</p>
<p><strong>输入格式</strong></p>
<p>输入包含两行，第一行为整数 N，表示待制作的蛋糕的体积为 Nπ。</p>
<p>第二行为整数 M，表示蛋糕的层数为 M。</p>
<p><strong>输出格式</strong></p>
<p>输出仅一行，是一个正整数 S（若无解则 S&#x3D;0）。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ N ≤ 10000,<br>1 ≤ M ≤ 20</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">68</span></span><br></pre></td></tr></table></figure>
<h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>多层蛋糕，给出总体积总层数，可以自定义每一层半径和高度，使得从上往下看的总面积和总侧面积之和最小，求最小值</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先明确我们的目的是让 2 * R<del>m</del> * h<del>m</del> + 2 * R<del>m-1</del> * h<del>m-1</del> + … + 2 * R<del>1</del> * h<del>1</del> + R<del>m</del>^2^ 最小（省去了所有的$π$）</p>
<p><strong>优化：</strong></p>
<ol>
<li>优化搜索顺序：分支少的先搜，从大到小枚举<br>(1) 要先搜面积大的，因此自底向上搜<br>(2) 半径是平方级别，高是一次方，半径对体积影响更大，因此先枚举半径</li>
<li>可行性剪枝：<br>(1) 设从上往下为1-m层，第 u 层的半径记为 R<del>u</del>，一定比 u 大，且比 R<del>u+1</del> - 1 小，同时，我们设第 u 层下方的所有体积为 V，那么前 u 层的体积就是 $n - V$，即有 $n - V &gt;&#x3D; R_u^2h_u$，放缩后有 $R_u &lt;&#x3D; \sqrt{n - V}$<br>据此得到：**&#x3D;&#x3D;$u &lt;&#x3D; R_u &lt;&#x3D; min{R_{u+1}-1,  \sqrt{n-V}}$&#x3D;&#x3D;**<br>(2) 同时，H<del>u</del>也&gt;&#x3D;u，且比 H<del>u+1</del>小， $n - V &gt;&#x3D; R_u^2h_u$，放缩后有 $h_u&lt;&#x3D; \frac{n-V}{R^2}$<br>据此得到：**&#x3D;&#x3D;$u &lt;&#x3D; h_u &lt;&#x3D; min{h_{u+1}-1,  \frac{n-V}{R^2}}$&#x3D;&#x3D;**</li>
<li>最小体积是半径和高都取1时，因此可以预处理一下前 u 层的体积最小值$minv(u)$和表面积最小值$mins(u)$，需要满足以下两个条件才有往下搜的必要，否则直接回溯：<br><strong>&#x3D;&#x3D;$V+minv(u)&lt;&#x3D;n$&#x3D;&#x3D;</strong><br><strong>&#x3D;&#x3D;$s+mins(u)&lt;ans$&#x3D;&#x3D;</strong></li>
<li>已知：$n-V&#x3D;\sum_{k&#x3D;1}^{u}R_k^2h_k$<br>并且：$S_{1\rightarrow u}&#x3D;\sum_{k&#x3D;1}^{u}2R_kh_k&#x3D;\frac{2}{R_{u+1}}\sum_{k&#x3D;1}^{u}R_uhR_{u+1}&gt;\frac{2}{R_{u+1}}\sum_{k&#x3D;1}^{u}R_u^2h$<br>因此：$S_{1\rightarrow u}&gt;\frac{2(n-V)}{R_{u+1}}$<br>所以当$s+\frac{2(n-V)}{R_{u+1}}&gt;&#x3D;ans$时，已经不可能是最优解了，直接回溯</li>
</ol>
<p>(好难…疯掉TAT</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> minv[N], mins[N]; <span class="comment">// 分别表示每一层及该层上方的最小体积和最小表面积</span></span><br><span class="line"><span class="type">int</span> R[N], H[N]; <span class="comment">// 表示每一层的半径和高</span></span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> s)</span> <span class="comment">// u:当前层数 v:当前体积 s:当前表面积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v + minv[u] &gt; n) <span class="keyword">return</span>; <span class="comment">// 优化3</span></span><br><span class="line">    <span class="keyword">if</span> (s + mins[u] &gt;= ans) <span class="keyword">return</span>; <span class="comment">// 优化3</span></span><br><span class="line">    <span class="keyword">if</span> (s + <span class="number">2</span> * (n - v) / R[u + <span class="number">1</span>] &gt;= ans) <span class="keyword">return</span>; <span class="comment">// 优化4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="comment">//已全部搜完</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == n) ans = s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化1:从大到小枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="built_in">min</span>(R[u + <span class="number">1</span>] - <span class="number">1</span>, (<span class="type">int</span>)<span class="built_in">sqrt</span>(n - v)); r &gt;= u; r -- ) <span class="comment">// 优化2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> h = <span class="built_in">min</span>(H[u + <span class="number">1</span>] - <span class="number">1</span>, (n - v) / r / r); h &gt;= u; h -- ) <span class="comment">// 优化2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (u == m) t = r * r; <span class="comment">// 如果是最底层，要加上底面积</span></span><br><span class="line">            R[u] = r, H[u] = h; <span class="comment">// 更新RH</span></span><br><span class="line">            <span class="built_in">dfs</span>(u - <span class="number">1</span>, v + r * r * h, s + <span class="number">2</span> * h * r + t);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打表做出minv mins</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        minv[i] = minv[i - <span class="number">1</span>] + i * i * i;</span><br><span class="line">        mins[i] = mins[i - <span class="number">1</span>] + <span class="number">2</span> * i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    R[m + <span class="number">1</span>] = H[m + <span class="number">1</span>] = inf; <span class="comment">// 设置哨兵</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(m, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans == inf) ans = <span class="number">0</span>; <span class="comment">// 无满足要求的情况</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>【搜索】DFS搜索顺序</title>
    <url>/posts/7614fc0a.html</url>
    <content><![CDATA[<h1 id="马走日"><a href="#马走日" class="headerlink" title="马走日"></a>马走日</h1><p><a href="https://www.acwing.com/problem/content/1118/">原题链接</a></p>
<p>马在中国象棋以日字形规则移动。</p>
<p>请编写一段程序，给定 n∗m 大小的棋盘，以及马的初始位置 (x，y)，要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。</p>
<p><strong>输入格式</strong></p>
<p>第一行为整数 T，表示测试数据组数。</p>
<p>每一组测试数据包含一行，为四个整数，分别为棋盘的大小以及初始位置坐标 n,m,x,y。</p>
<p><strong>输出格式</strong></p>
<p>每组测试数据包含一行，为一个整数，表示马能遍历棋盘的途径总数，若无法遍历棋盘上的所有点则输出 0。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ T ≤ 9,<br>1 ≤ m , n ≤9,<br>1 ≤ n × m ≤ 28,<br>0 ≤ x ≤ n − 1,<br>0 ≤ y ≤ m − 1</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出矩阵大小，给出马的初始位置，马只能走日。问有多少种方案让马可以遍历完棋盘上的所有点，每种方案里不可以重复经过两个点</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这就是典型的外部搜索，是不同状态之间的搜索，因此每次需要恢复现场（可以理解为悔棋）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cnt)</span> <span class="comment">// 前两个参数表示当前点坐标，第三个参数表示目前已经搜了多少个点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n * m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans ++ ;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ ) <span class="comment">// 遍历八个操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line">        <span class="built_in">dfs</span>(a, b, cnt + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    st[x][y] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙</h1><p><a href="https://www.acwing.com/problem/content/1119/">原题链接</a></p>
<p>单词接龙是一个与我们经常玩的成语接龙相类似的游戏。</p>
<p>现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”，每个单词最多被使用两次。</p>
<p>在两个单词相连时，其重合部分合为一部分，例如 beast 和 astonish ，如果接成一条龙则变为 beastonish。</p>
<p>我们可以任意选择重合部分的长度，但其长度必须大于等于1，且严格小于两个串的长度，例如 at 和 atide 间不能相连。</p>
<p><strong>输入格式</strong></p>
<p>输入的第一行为一个单独的整数 n 表示单词数，以下 n 行每行有一个单词（只含有大写或小写字母，长度不超过20），输入的最后一行为一个单个字符，表示“龙”开头的字母。</p>
<p>你可以假定以此字母开头的“龙”一定存在。</p>
<p><strong>输出格式</strong></p>
<p>只需输出以此字母开头的最长的“龙”的长度。</p>
<p><strong>数据范围</strong></p>
<p>n ≤ 20，<br>单词随机生成。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">at</span><br><span class="line">touch</span><br><span class="line">cheat</span><br><span class="line">choose</span><br><span class="line">tact</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure>
<p><strong>提示</strong></p>
<p>连成的“龙”为 atoucheatactactouchoose。</p>
<h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出多个字符串，首位有相同字串的两个字符串可以连接，给出开头字符，问能连接的最大长度</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>外部搜索，每次需恢复原状</p>
<p>从开头字符与给定字符相同的单词开始，每次遇到能接到字符串后面的就往深遍历，（形成一个搜索树一样的结构）</p>
<p>下方代码有详细注释</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string word[N]; <span class="comment">// 记录每个单词</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 记录每两个单词有多少重合</span></span><br><span class="line"><span class="type">int</span> used[N]; <span class="comment">// 记录这个单词被用了多少次</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string dragon, <span class="type">int</span> last)</span> <span class="comment">// 第一个参数是当前字符串 第二个参数是当前最后一个字符串编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>((<span class="type">int</span>)dragon.<span class="built_in">size</span>(), ans); <span class="comment">// 更新最大长度</span></span><br><span class="line"></span><br><span class="line">    used[last] ++ ; <span class="comment">// 更新字符串使用次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 遍历每个字符串</span></span><br><span class="line">        <span class="keyword">if</span> (g[last][i] &amp;&amp; used[i] &lt; <span class="number">2</span>) <span class="comment">// 条件：和当前最后一个字符串有重合 &amp;&amp; 使用次数不到2次</span></span><br><span class="line">            <span class="built_in">dfs</span>(dragon + word[i].<span class="built_in">substr</span>(g[last][i]), i);</span><br><span class="line"></span><br><span class="line">    used[last] -- ; <span class="comment">// 恢复</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; word[i];</span><br><span class="line">    <span class="type">char</span> start;</span><br><span class="line">    cin &gt;&gt; start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每两个字符串最短的重合字符个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            string a = word[i], b = word[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; <span class="built_in">min</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()); k ++ ) <span class="comment">// 从1开始，最长不超过较短字符串长度</span></span><br><span class="line">                <span class="keyword">if</span> (a.<span class="built_in">substr</span>(a.<span class="built_in">size</span>() - k, k) == b.<span class="built_in">substr</span>(<span class="number">0</span>, k)) <span class="comment">// 一旦重合立刻跳出</span></span><br><span class="line">                &#123;</span><br><span class="line">                    g[i][j] = k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (word[i][<span class="number">0</span>] == start)</span><br><span class="line">            <span class="built_in">dfs</span>(word[i], i);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分成互质组"><a href="#分成互质组" class="headerlink" title="分成互质组"></a>分成互质组</h1><p><a href="https://www.acwing.com/problem/content/1120/">原题链接</a></p>
<p>给定 n 个正整数，将它们分组，使得每组中任意两个数互质。</p>
<p>至少要分成多少个组？</p>
<p><strong>输入格式</strong></p>
<p>第一行是一个正整数 n。</p>
<p>第二行是 n 个不大于10000的正整数。</p>
<p><strong>输出格式</strong></p>
<p>一个正整数，即最少需要的组数。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ n ≤ 10</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">14</span> <span class="number">20</span> <span class="number">33</span> <span class="number">117</span> <span class="number">143</span> <span class="number">175</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>每个组的数要互质，给出一系列数，问最少多少组</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>按照<strong>组合的方式</strong>搜索，每个组里按照下表从小到大添加所有能加进去的元素，直到不能再加任何一个元素，就新开一个组</p>
<p>&#x3D;&#x3D;<strong>当某个数可以加到最后一组时，就没有必要新开一个组</strong>&#x3D;&#x3D;</p>
<p>下方代码中有详细注释</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 存所有元素</span></span><br><span class="line"><span class="type">int</span> group[N][N]; <span class="comment">// 存每个组以及其中元素</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 判重</span></span><br><span class="line"><span class="type">int</span> ans = N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// 找最大公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> group[], <span class="type">int</span> gc, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; gc; j ++ ) <span class="comment">// 遍历group中的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">gcd</span>(p[group[j]], p[i]) &gt; <span class="number">1</span>) <span class="comment">// 最大公约数大于1说明不是互质</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> gc, <span class="type">int</span> tc, <span class="type">int</span> start)</span> <span class="comment">// u:第几组 gc:当前组内下标 tc:当前一共有多少元素 start:当前这一组从哪个元素开始搜</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt;= ans) <span class="keyword">return</span>; <span class="comment">// 剪枝优化:如果当前组数已经大于等于ans 说明一定不是最优解 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tc == n) ans = u; <span class="comment">// 所有数都搜索完了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// true表示当前组不能继续添加新元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i ++ ) <span class="comment">// 从start开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i] &amp;&amp; <span class="built_in">check</span>(group[u], gc, i)) <span class="comment">// 该元素没用过且与当前组所有元素互质</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>; <span class="comment">// 标记该元素</span></span><br><span class="line">            group[u][gc] = i; <span class="comment">// 将该元素加入组中</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span>(u, gc + <span class="number">1</span>, tc + <span class="number">1</span>, i + <span class="number">1</span>); <span class="comment">// 下一层遍历</span></span><br><span class="line"></span><br><span class="line">            st[i] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            flag = <span class="literal">false</span>; <span class="comment">// 表示还能添加新元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">dfs</span>(u + <span class="number">1</span>, <span class="number">0</span>, tc, <span class="number">0</span>); <span class="comment">// 不能添加新元素时新开一个组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>【搜索】DFS连通性模型</title>
    <url>/posts/46c8bf03.html</url>
    <content><![CDATA[<p>DFS 的搜索分为两大部分：</p>
<ul>
<li><strong>内部搜索</strong>：一个图中从一个点搜到另一个点</li>
<li><strong>外部搜索</strong>：从一张图（状态）搜到另一张图（状态）</li>
</ul>
<p>在第一个部分里是图内部点的搜索，每个点只能搜一次，因此搜过的点不需要恢复到原来的（还没被搜过的）状态（意思就是st数组不恢复）</p>
<p>而第二个部分是点的集合之间的搜索，每次搜索完一定要恢复到原有状态才可以进行下一步搜索（意思就是st数组每次需要恢复原状）</p>
<h1 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h1><p><a href="https://www.acwing.com/problem/content/1114/">原题链接</a></p>
<p>一天Extense在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由 n∗n 的格点组成，每个格点只有2种状态，.和#，前者表示可以通行后者表示不能通行。</p>
<p>同时当Extense处在某个格点时，他只能移动到东南西北(或者说上下左右)四个方向之一的相邻格点上，Extense想要从点A走到点B，问在不走出迷宫的情况下能不能办到。</p>
<p>如果起点或者终点有一个不能通行(为#)，则看成无法办到。</p>
<p>注意：A、B不一定是两个不同的点。</p>
<p><strong>输入格式</strong></p>
<p>第1行是测试数据的组数 k，后面跟着 k 组输入。</p>
<p>每组测试数据的第1行是一个正整数 n，表示迷宫的规模是 n∗n 的。</p>
<p>接下来是一个 n∗n 的矩阵，矩阵中的元素为.或者#。</p>
<p>再接下来一行是 4 个整数 ha,la,hb,lb，描述 A 处在第 ha 行, 第 la 列，B 处在第 hb 行, 第 lb 列。</p>
<p>注意到 ha,la,hb,lb 全部是从 0 开始计数的。</p>
<p><strong>输出格式</strong></p>
<p>k行，每行输出对应一个输入。</p>
<p>能办到则输出“YES”，否则输出“NO”。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ n ≤ 100</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">.##</span><br><span class="line">..#</span><br><span class="line">#..</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">.....</span><br><span class="line">###.#</span><br><span class="line">..#..</span><br><span class="line">###..</span><br><span class="line">...#.</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一张图两个点，问能不能从一个点走到另一个点</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接bfs遍历看能不能从一个点遍历到另一个</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line"><span class="type">int</span> xa, ya, xb, yb; <span class="comment">// 标记起点终点</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g[x][y] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == xb &amp;&amp; y == yb) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) <span class="comment">// 遍历四个操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(a, b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line">        cin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(xa, ya)) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="红与黑"><a href="#红与黑" class="headerlink" title="红与黑"></a>红与黑</h1><p><a href="https://www.acwing.com/problem/content/1115/">原题链接</a></p>
<p>有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。</p>
<p>你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。</p>
<p>请写一个程序，计算你总共能够到达多少块黑色的瓷砖。</p>
<p><strong>输入格式</strong></p>
<p>输入包括多个数据集合。</p>
<p>每个数据集合的第一行是两个整数 W 和 H，分别表示 x 方向和 y 方向瓷砖的数量。</p>
<p>在接下来的 H 行中，每行包括 W 个字符。每个字符表示一块瓷砖的颜色，规则如下</p>
<p>1）‘.’：黑色的瓷砖；<br>2）‘#’：红色的瓷砖；<br>3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。</p>
<p>当在一行中读入的是两个零时，表示输入结束。</p>
<p><strong>输出格式</strong></p>
<p>对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ W , H ≤ 20</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">9</span> </span><br><span class="line">....#. </span><br><span class="line">.....# </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">#@...# </span><br><span class="line">.#..#. </span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>
<h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一个图分为红黑方块，问某一个黑方块的连通块个数</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本质上是个Flood Fill问题，可以用BFS实现</p>
<p>用DFS也是一样的，只是搜索顺序不一样</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">        <span class="keyword">if</span> (g[a][b] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>; <span class="comment">// 不是黑色的</span></span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line"></span><br><span class="line">        cnt += <span class="built_in">dfs</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; m &gt;&gt; n, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>) <span class="comment">// 找起点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">dfs</span>(x, y) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>连通性</tag>
      </tags>
  </entry>
  <entry>
    <title>【搜索】DFS迭代加深与IDA*</title>
    <url>/posts/78aeb4cc.html</url>
    <content><![CDATA[<h1 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h1><p>搜索时可能会遇到这样一种情况：</p>
<img src="/posts/78aeb4cc/1.png" class>
<p>明明答案就在第一层！但是因为DFS的缘故浪费很多时间<br>迭代加深就是用来解决这个问题的算法</p>
<p>定义一个 max_depth ，每次搜索时，超过这一层就全部剪掉、<br>（相当于我们划定一个区域，在这个区域内找解，如果找不到，再扩大区域）</p>
<p>？迭代加深和BFS有什么区别呢<br>BFS用队列存储，浪费空间，迭代加深本质是还是DFS，只存储本条路径，还是O(n)的算法</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="加成序列"><a href="#加成序列" class="headerlink" title="加成序列"></a>加成序列</h3><p><a href="https://www.acwing.com/problem/content/172/">原题链接</a></p>
<p>满足如下条件的序列 X（序列中元素被标号为 1、2、3…m）被称为“加成序列”：</p>
<ol>
<li>$X[1]&#x3D;1$</li>
<li>$X[m]&#x3D;n$</li>
<li>$X[1]&lt;X[2]&lt;…&lt;X[m−1]&lt;X[m]$</li>
<li>对于每个 k（2 ≤ k ≤ m）都存在两个整数 i 和 j （1 ≤ i , j ≤ k − 1，i 和 j 可相等），使得 $X[k]&#x3D;X[i]+X[j]$。</li>
</ol>
<p>你的任务是：给定一个整数 n，找出符合上述条件的长度 m 最小的“加成序列”。</p>
<p>如果有多个满足要求的答案，只需要找出任意一个可行解。</p>
<p><strong>输入格式</strong></p>
<p>输入包含多组测试用例。</p>
<p>每组测试用例占据一行，包含一个整数 n。</p>
<p>当输入为单行的 0 时，表示输入结束。</p>
<p><strong>输出格式</strong></p>
<p>对于每个测试用例，输出一个满足需求的整数序列，数字之间用空格隔开。</p>
<p>每个输出占一行。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ n ≤ 100</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">77</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">12</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">10</span> <span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">17</span> <span class="number">34</span> <span class="number">68</span> <span class="number">77</span></span><br></pre></td></tr></table></figure>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给出 n 构造一个序列，要求第一个数是1，最后一个数是n，严格递增，且后面的数一定要是前面两个数之和（两个数可以是同一个数），输出一个长度最小的序列</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>序列的最小规模：1 2 4 8 16 32 64 128 此时就已经超过100了，说明正确答案的深度不会很深，适合用迭代加深来做<br>层数从1开始，依次考虑每一位选什么数字</p>
<p><strong>优化：</strong></p>
<ol>
<li>优化搜索顺序：优先枚举较大的数，层数较少，更快的找到 n</li>
<li>排除等效冗余：举个栗子：1 2 3 4 现在枚举下一个数，不管选择1+4还是2+3结果都是5，就可以不用计算两次了（方法是开一个bool数组存储每个数是否被用过）</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 标记某数是否被用过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span> <span class="comment">// 分别是当前层数和最大层数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; depth) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当前层数&gt;最大层数</span></span><br><span class="line">    <span class="keyword">if</span> (path[u - <span class="number">1</span>] == n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 最后一个数为n满足条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = u - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = path[i] + path[j];</span><br><span class="line">            <span class="keyword">if</span> (s &gt; n || s &lt;= path[u - <span class="number">1</span>] || st[s]) <span class="keyword">continue</span>; <span class="comment">// 大于最大值or小于前一个值or已被用过 都不满足条件</span></span><br><span class="line"></span><br><span class="line">            st[s] = <span class="literal">true</span>; <span class="comment">// 标记s已被用过</span></span><br><span class="line">            path[u] = s; <span class="comment">// 记录s</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(u + <span class="number">1</span>, depth)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 下一位</span></span><br><span class="line">            st[s] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">1</span>, depth)) depth ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i ++ ) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA*"></a>IDA*</h1><p>IDA*是什么意思？</p>
<p>IDA*就是特殊的剪枝，一般情况下和<strong>迭代加深</strong>结合起来使用，需要定义一个max_depth，我们搜索到一个结点的时候就开始预估这个结点和正确答案的步数，如果说在这个步数内无论如何都找不到正确答案，那就不继续往下搜了提前退出</p>
<p>要求：估价函数&lt;&#x3D;真实值</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="排书"><a href="#排书" class="headerlink" title="排书"></a>排书</h3><p><a href="https://www.acwing.com/problem/content/182/">原题链接</a></p>
<p>给定 $n$ 本书，编号为 $1∼n$。</p>
<p>在初始状态下，书是任意排列的。</p>
<p>在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。</p>
<p>我们的目标状态是把书按照 $1∼n$ 的顺序依次排列。</p>
<p>求最少需要多少次操作。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 $T$，表示共有 T 组测试数据。</p>
<p>每组数据包含两行，第一行为整数 $n$，表示书的数量。</p>
<p>第二行为 $n$ 个整数，表示 $1∼n$ 的一种任意排列。</p>
<p>同行数之间用空格隔开。</p>
<p><strong>输出格式</strong></p>
<p>每组数据输出一个最少操作次数。</p>
<p>如果最少操作次数大于或等于 5 次，则输出 <code>5 or more</code>。</p>
<p>每个结果占一行。</p>
<p><strong>数据范围</strong></p>
<p>$1 ≤ n ≤ 15$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">6</span> <span class="number">8</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">7</span> <span class="number">2</span> <span class="number">9</span> <span class="number">1</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">or</span> more</span><br></pre></td></tr></table></figure>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>一列数，每次可以取出其中一个子串插到其他地方，问至少多少次能让数列递增</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>采用迭代加深框架，每次估计当前序列最少要进行多少次操作才能把它变成排好序的序列</p>
<p>怎么确定估价函数呢？</p>
<p>我们观察每一位数的后继（也就是后面那个数），如果序列排好序，那么每个元素的后继都应该比元素本身大1<br>每操作一次会修改三个元素的后继，如下图所示：</p>
<img src="/posts/78aeb4cc/2.png" class>
<p>因此我们先统计出有 tot 个元素的后继不正确，因为每次操作可以修改三个后继，我们假设三个后继都变成正确的了，所以最少进行的操作步数就是$\lceil\frac{tot}{3}\rceil$，也就是$\lfloor\frac{tot+2}{3}\rfloor$，用它作为估价函数可以保证一定满足条件</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> w[<span class="number">5</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> <span class="comment">// 估价函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>; <span class="comment">// 错误的后继数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (q[i + <span class="number">1</span>] != q[i] + <span class="number">1</span>) tot ++ ;</span><br><span class="line">    <span class="keyword">return</span> (tot + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> max_depth)</span> <span class="comment">// 分别表示当前层数和最大层数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth + <span class="built_in">f</span>() &gt; max_depth) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当前深度大于最大深度</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 估价函数=0说明当前就是正确答案</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len ++ ) <span class="comment">// 枚举长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l + len - <span class="number">1</span> &lt; n; l ++ ) <span class="comment">// 枚举从哪开始截</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = r + <span class="number">1</span>; k &lt; n; k ++ ) <span class="comment">// 枚举挪到哪个位置（k是结尾位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(w[depth], q, <span class="keyword">sizeof</span> q); <span class="comment">// 把原数组存到w里</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 挪位</span></span><br><span class="line">                <span class="type">int</span> y = l;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = r + <span class="number">1</span>; x &lt;= k; x ++, y ++ ) q[y] = w[depth][x];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = l; x &lt;= r; x ++, y ++ ) q[y] = w[depth][x];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth + <span class="number">1</span>, max_depth)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(q, w[depth], <span class="keyword">sizeof</span> q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代加深</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>; <span class="comment">// 最大层数</span></span><br><span class="line">        <span class="keyword">while</span> (depth &lt; <span class="number">5</span> &amp;&amp; !<span class="built_in">dfs</span>(<span class="number">0</span>, depth)) depth ++ ; <span class="comment">// 这里注意循环判断条件一定要把depth&lt;5放前面！否则TLE</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= <span class="number">5</span>) cout &lt;&lt; <span class="string">&quot;5 or more\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; depth &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>挪位理解不了就画图</p>
<img src="/posts/78aeb4cc/3.png" class>

<h3 id="回转游戏"><a href="#回转游戏" class="headerlink" title="回转游戏"></a>回转游戏</h3><p><a href="https://www.acwing.com/problem/content/183/">原题链接</a></p>
<p>如下图所示，有一个 # 形的棋盘，上面有 1,2,3 三种数字各 8 个。</p>
<p>给定 8 种操作，分别为图中的 $A∼H$。</p>
<p>这些操作会按照图中字母和箭头所指明的方向，把一条长为 7 的序列循环移动 1 个单位。</p>
<p>例如下图最左边的 # 形棋盘执行操作 $A$ 后，会变为下图中间的 # 形棋盘，再执行操作 $C$ 后会变成下图最右边的 # 形棋盘。</p>
<p>给定一个初始状态，请使用最少的操作次数，使 # 形棋盘最中间的 8 个格子里的数字相同。</p>
<img src="/posts/78aeb4cc/4.png" class>


<p><strong>输入格式</strong></p>
<p>输入包含多组测试用例。</p>
<p>每个测试用例占一行，包含 24 个数字，表示将初始棋盘中的每一个位置的数字，按整体从上到下，同行从左到右的顺序依次列出。</p>
<p>输入样例中的第一个测试用例，对应上图最左边棋盘的初始状态。</p>
<p>当输入只包含一个 0 的行时，表示输入终止。</p>
<p><strong>输出格式</strong></p>
<p>每个测试用例输出占两行。</p>
<p>第一行包含所有移动步骤，每步移动用大写字母 $A∼H$ 中的一个表示，字母之间没有空格，如果不需要移动则输出 <code>No moves needed</code>。</p>
<p>第二行包含一个整数，表示移动完成后，中间 8 个格子里的数字。</p>
<p>如果有多种方案，则输出字典序最小的解决方案。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AC</span><br><span class="line"><span class="number">2</span></span><br><span class="line">DDHH</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>井字格，每次可以拉动任意一条边，要求用最小的操作次数使中间的八个格子数字一样</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>要求字典序最小，因此按照字典序搜索即可</p>
<p>每次往下搜所层数都很深，但是根据 <del>搜索问题的玄学性，</del> 直觉来看正确答案的层数不会很深，所以选择迭代加深的算法来做<br>迭代加深搜索的过程中我们加入估价函数，让迭代加深升级为IDA*</p>
<p>每拉动一次，中间的八个格子只有一个格子的数字会改变，所以先统计八个格子里出现次数最多的数字出现了多少次（记作 $cnt$），那最好的情况就是每操作一次，都使得一个不是最多数的数字变成最多数，因此可以将估价函数设置为 $f()&#x3D;8-cnt$，就可以保证这个数字一定小于等于正确答案</p>
<p>本题还有一个难点就是怎么表示出这几个操作，我们可以先打表，给格子编号，然后预先处理出几个操作的具体步骤<br>{asset_image 5.png}</p>
<p><strong>优化：</strong> 本次枚举的操作一定不能是上一次的逆操作</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储每个操作移动的位置</span></span><br><span class="line"><span class="type">int</span> op[<span class="number">8</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">22</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>&#125;,</span><br><span class="line">    &#123;<span class="number">23</span>, <span class="number">21</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">22</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储每个操作对应的逆操作</span></span><br><span class="line"><span class="type">int</span> opposite[<span class="number">8</span>] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储中间的八个数</span></span><br><span class="line"><span class="type">int</span> center[<span class="number">8</span>] = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> path[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> <span class="comment">// 估价函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ ) sum[q[center[i]]] ++ ; <span class="comment">// 找到每个数出现几次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i ++ ) s = <span class="built_in">max</span>(s, sum[i]); <span class="comment">// 找到出现最多的次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> - s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operate</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = q[op[x][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i ++ ) q[op[x][i]] = q[op[x][i + <span class="number">1</span>]];</span><br><span class="line">    q[op[x][<span class="number">6</span>]] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> max_depth, <span class="type">int</span> last)</span> <span class="comment">// depth:当前层数 max_depth:最大层数 last:上一步</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth + <span class="built_in">f</span>() &gt; max_depth) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 范围内找不到解</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到正确答案</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (opposite[i] != last) <span class="comment">// 只要不是逆操作就往下搜</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">operate</span>(i);</span><br><span class="line">            path[depth] = i; <span class="comment">// 记录操作</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth + <span class="number">1</span>, max_depth, i)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 递归操作</span></span><br><span class="line">            <span class="built_in">operate</span>(opposite[i]); <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; q[<span class="number">0</span>], q[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代加深</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">0</span>, depth, <span class="number">-1</span>)) depth ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!depth) cout &lt;&lt; <span class="string">&quot;No moves needed&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i ++ ) cout &lt;&lt; (<span class="type">char</span>)(path[i] + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; q[<span class="number">6</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>迭代加深</tag>
        <tag>IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title>【搜索】Flood Fill</title>
    <url>/posts/de9f691a.html</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>什么是 Flood Fill 算法？<br>字面意思理解：洪水覆盖<br>也就是说，下图的格子分为两大类，一类比较高一类比较低，现在从任意一处较低的格子开始灌水，下一次水将会覆盖它&#x3D;&#x3D;相邻的&#x3D;&#x3D;、&#x3D;&#x3D;较低的&#x3D;&#x3D;格子，依此类推<br>这就相当于是BFS的思想（也可以用DFS实现，但BFS不会出现爆栈的问题）</p>
<p><strong>Flood Fill 算法可以在线性时间复杂度内，找到某个点所在的连通块</strong></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="池塘计数"><a href="#池塘计数" class="headerlink" title="池塘计数"></a>池塘计数</h2><p><a href="https://www.acwing.com/problem/content/1099/">原题链接</a></p>
<p>农夫约翰有一片 N∗M 的矩形土地。</p>
<p>最近，由于降雨的原因，部分土地被水淹没了。</p>
<p>现在用一个字符矩阵来表示他的土地。</p>
<p>每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。</p>
<p>现在，约翰想知道他的土地中形成了多少片池塘。</p>
<p>每组相连的积水单元格集合可以看作是一片池塘。</p>
<p>每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。</p>
<p>请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 N 和 M。</p>
<p>接下来 N 行，每行包含 M 个字符，字符为”W”或”.”，用以表示矩形土地的积水状况，字符之间没有空格。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示池塘数目。</p>
<p><strong>数据范围</strong><br>1 ≤ N, M ≤ 1000</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">12</span></span><br><span class="line">W........WW.</span><br><span class="line">.WWW.....WWW</span><br><span class="line">....WW...WW.</span><br><span class="line">.........WW.</span><br><span class="line">.........W..</span><br><span class="line">..W......W..</span><br><span class="line">.W.W.....WW.</span><br><span class="line">W.W.W.....W.</span><br><span class="line">.W.W......W.</span><br><span class="line">..W.......W.</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>模板题，问有多少连通块</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按顺序遍历图上每一个点，如果这个点是洼地且未被遍历过，就在答案的基础上加1，并且标记这个连通块的所有点，直到遍历完整个图</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t.ft - <span class="number">1</span>; i &lt;= t.ft + <span class="number">1</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = t.sd - <span class="number">1</span>; j &lt;= t.sd + <span class="number">1</span>; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == t.ft &amp;&amp; j == t.sd) <span class="keyword">continue</span>; <span class="comment">// 正好遍历到当前点</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;.&#x27;</span> || st[i][j]) <span class="keyword">continue</span>; <span class="comment">// 不是洼地或已遍历过</span></span><br><span class="line"></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                st[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;W&#x27;</span> &amp;&amp; !st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">bfs</span>(i, j);</span><br><span class="line">                cnt ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="城堡问题"><a href="#城堡问题" class="headerlink" title="城堡问题"></a>城堡问题</h2><p><a href="https://www.acwing.com/problem/content/1100/">原题链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   1   2   3   4   5   6   7  </span><br><span class="line">  #############################</span><br><span class="line">1 #   |   #   |   #   |   |   #</span><br><span class="line">  #####---#####---#---#####---#</span><br><span class="line">2 #   #   |   #   #   #   #   #</span><br><span class="line">  #---#####---#####---#####---#</span><br><span class="line">3 #   |   |   #   #   #   #   #</span><br><span class="line">  #---#########---#####---#---#</span><br><span class="line">4 #   #   |   |   |   |   #   #</span><br><span class="line">  #############################</span><br><span class="line">             (图 1)</span><br><span class="line"></span><br><span class="line">  #  = Wall   </span><br><span class="line">  |  = No wall</span><br><span class="line">  -  = No wall</span><br><span class="line"></span><br><span class="line">  方向：上北下南左西右东。</span><br></pre></td></tr></table></figure>

<p>图1是一个城堡的地形图。</p>
<p>请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。</p>
<p>城堡被分割成 m∗n 个方格区域，每个方格区域可以有0~4面墙。</p>
<p>注意：墙体厚度忽略不计。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 m 和 n，分别表示城堡南北方向的长度和东西方向的长度。</p>
<p>接下来 m 行，每行包含 n 个整数，每个整数都表示平面图对应位置的方块的墙的特征。</p>
<p>每个方块中墙的特征由数字 P 来描述，我们用1表示西墙，2表示北墙，4表示东墙，8表示南墙，P 为该方块包含墙的数字之和。</p>
<p>例如，如果一个方块的 P 为3，则 3 &#x3D; 1 + 2，该方块包含西墙和北墙。</p>
<p>城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。</p>
<p>输入的数据保证城堡至少有两个房间。</p>
<p><strong>输出格式</strong></p>
<p>共两行，第一行输出房间总数，第二行输出最大房间的面积（方块数）。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ m, n ≤ 50,<br>0 ≤ P ≤ 15</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">7</span> </span><br><span class="line"><span class="number">11</span> <span class="number">6</span> <span class="number">11</span> <span class="number">6</span> <span class="number">3</span> <span class="number">10</span> <span class="number">6</span> </span><br><span class="line"><span class="number">7</span> <span class="number">9</span> <span class="number">6</span> <span class="number">13</span> <span class="number">5</span> <span class="number">15</span> <span class="number">5</span> </span><br><span class="line"><span class="number">1</span> <span class="number">10</span> <span class="number">12</span> <span class="number">7</span> <span class="number">13</span> <span class="number">7</span> <span class="number">5</span> </span><br><span class="line"><span class="number">13</span> <span class="number">11</span> <span class="number">10</span> <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">13</span> </span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个城堡中每个房间四面是否有墙壁，输出该城堡有多少个连通的房间，最大的连通块面积是多少</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>和上一题基本一样，判断每个房间的四面墙壁情况，只是要额外加一个面积的计算</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        area ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; <span class="comment">// 已被遍历</span></span><br><span class="line">            <span class="keyword">if</span> (g[t.ft][t.sd] &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 这个方向是墙</span></span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">            st[a][b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                area = <span class="built_in">max</span>(area, <span class="built_in">bfs</span>(i, j));</span><br><span class="line">                cnt ++ ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="山峰和山谷"><a href="#山峰和山谷" class="headerlink" title="山峰和山谷"></a>山峰和山谷</h2><p><a href="https://www.acwing.com/problem/content/1108/">原题链接</a></p>
<p>FGD小朋友特别喜欢爬山，在爬山的时候他就在研究山峰和山谷。</p>
<p>为了能够对旅程有一个安排，他想知道山峰和山谷的数量。</p>
<p>给定一个地图，为FGD想要旅行的区域，地图被分为 n×n 的网格，每个格子 (i,j) 的高度 w(i,j) 是给定的。</p>
<p>若两个格子有公共顶点，那么它们就是相邻的格子，如与 (i,j) 相邻的格子有(i−1,j−1),(i−1,j),(i−1,j+1),(i,j−1),(i,j+1),(i+1,j−1),(i+1,j),(i+1,j+1)。</p>
<p>我们定义一个格子的集合 S 为山峰（山谷）当且仅当：</p>
<ol>
<li>S 的所有格子都有相同的高度。</li>
<li>S 的所有格子都连通。</li>
<li>对于 s 属于 S，与 s 相邻的 s′ 不属于 S，都有 ws&gt;ws′（山峰），或者 ws&lt;ws′（山谷）。</li>
<li>如果周围不存在相邻区域，则同时将其视为山峰和山谷。</li>
</ol>
<p>你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含一个正整数 n，表示地图的大小。</p>
<p>接下来一个 n×n 的矩阵，表示地图上每个格子的高度 w。</p>
<p><strong>输出格式</strong></p>
<p>共一行，包含两个整数，表示山峰和山谷的数量。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ n ≤ 1000,<br>0 ≤ w ≤ 109</p>
<p><strong>输入样例1</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">7</span> <span class="number">7</span> <span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例1</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>输入样例2</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例2</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出不同地块的高度，高度相同的连通块周边高度都小于等于该连通块高度，那么该连通块为山峰，反之为山谷，问山峰山谷数量</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>依旧是遍历每一个点，如果没有遍历过该点，就遍历该点所在连通块，直到找到连通块边界，再判断这个连通块是否为山峰或山谷</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N][N];</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">bool</span>&amp; has_higher, <span class="type">bool</span>&amp; has_lower)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t.ft - <span class="number">1</span>; i &lt;= t.ft + <span class="number">1</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = t.sd - <span class="number">1</span>; j &lt;= t.sd + <span class="number">1</span>; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == t.ft &amp;&amp; j == t.sd) <span class="keyword">continue</span>; <span class="comment">// 遍历到自身</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">                <span class="keyword">if</span> (h[i][j] != h[t.ft][t.sd]) <span class="comment">// 边界</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (h[i][j] &gt; h[t.ft][t.sd]) has_higher = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> has_lower = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!st[i][j]) <span class="comment">// 非边界且未遍历</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                    st[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cin &gt;&gt; h[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> peak = <span class="number">0</span>, valley = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> has_higher = <span class="literal">false</span>, has_lower = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bfs</span>(i, j, has_higher, has_lower);</span><br><span class="line">                <span class="keyword">if</span> (!has_higher) peak ++ ;</span><br><span class="line">                <span class="keyword">if</span> (!has_lower) valley ++ ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; peak &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; valley &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>Flood Fill</tag>
      </tags>
  </entry>
  <entry>
    <title>【搜索】双向DFS</title>
    <url>/posts/c90ca664.html</url>
    <content><![CDATA[<p>双向BFS和前面的双向DFS思路基本一样，都是为了从两端搜索从而避免搜索中间一大块复杂的情况</p>
<h1 id="送礼物"><a href="#送礼物" class="headerlink" title="送礼物"></a>送礼物</h1><p><a href="https://www.acwing.com/problem/content/173/">原题链接</a></p>
<p>达达帮翰翰给女生送礼物，翰翰一共准备了 $N$ 个礼物，其中第 i 个礼物的重量是 $G[i]$。</p>
<p>达达的力气很大，他一次可以搬动重量之和不超过 $W$ 的任意多个物品。</p>
<p>达达希望一次搬掉尽量重的一些物品，请你告诉达达在他的力气范围内一次性能搬动的最大重量是多少。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数，分别代表 $W$ 和 $N$。</p>
<p>以后 $N$ 行，每行一个正整数表示 $G[i]$。</p>
<p><strong>输出格式</strong></p>
<p>仅一个整数，表示达达在他的力气范围内一次性能搬动的最大重量。</p>
<p><strong>数据范围</strong></p>
<p>$1 ≤ N ≤ 46,$<br>$1 ≤ W , G[i] ≤ 2^{31}−1$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出背包体积和每个物品体积，问一次最多装多少物品</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看数据范围判断背包问题一定会TLE，但N范围比较小，因此使用爆搜，把所有可能方案枚举一遍，取一个最大值<br>但是直接爆搜，时间复杂度 2^46^，也是会超时的</p>
<p><strong>优化——双向DFS</strong> 用空间换时间<br>先枚举前一半数能凑出来的集合，再枚举后一半数，然后在两个集合中分别找 $a、b$，看能不能找到使$a+b&lt;&#x3D;w$（$w$是要求的最大总重量）<br>爆搜b，二分查找a，借此优化时间复杂度</p>
<p>本题思路总结如下：</p>
<ol>
<li>将所有物品重量从大到小排序</li>
<li>先将前k件物品能凑出的所有重量打表，然后排序判重</li>
<li>搜索剩下的n-k件物品的选择方式，然后在表中二分出不超过w的最大值</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">46</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="type">int</span> w[N]; <span class="comment">// 每个物品重量</span></span><br><span class="line"><span class="type">int</span> weights[<span class="number">1</span> &lt;&lt; <span class="number">25</span>], cnt; <span class="comment">// 能凑出来的重量</span></span><br><span class="line"><span class="type">int</span> ans; <span class="comment">// 全局最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s)</span> <span class="comment">// u:枚举到哪个数 s:当前的和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == k)</span><br><span class="line">    &#123;</span><br><span class="line">        weights[cnt ++ ] = s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(u + <span class="number">1</span>, s); <span class="comment">// 不选第u个</span></span><br><span class="line">    <span class="keyword">if</span> ((i64)s + w[u] &lt;= m) <span class="built_in">dfs1</span>(u + <span class="number">1</span>, s + w[u]); <span class="comment">// 选第u个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 二分查找前一部分</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (weights[mid] &lt;= m - s)  l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, weights[l] + s); <span class="comment">// 更新答案</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs2</span>(u + <span class="number">1</span>, s); <span class="comment">// 不选第u个</span></span><br><span class="line">    <span class="keyword">if</span> ((i64)s + w[u] &lt;= m) <span class="built_in">dfs2</span>(u + <span class="number">1</span>, s + w[u]); <span class="comment">// 选第u个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(w, w + n);</span><br><span class="line">    <span class="built_in">reverse</span>(w, w + n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对前k个数打表预处理</span></span><br><span class="line">    k = n / <span class="number">2</span>; <span class="comment">// 防止n==1死循环</span></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序去重</span></span><br><span class="line">    <span class="built_in">sort</span>(weights, weights + cnt);</span><br><span class="line">    cnt = <span class="built_in">unique</span>(weights, weights + cnt) - weights; <span class="comment">// 返回当前数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs2</span>(k, <span class="number">0</span>); <span class="comment">// 爆搜后一部分</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>【搜索】最小步数（双向广搜与A*算法）</title>
    <url>/posts/e9a0dd50.html</url>
    <content><![CDATA[<h1 id="最小步数"><a href="#最小步数" class="headerlink" title="最小步数"></a>最小步数</h1><h2 id="魔板"><a href="#魔板" class="headerlink" title="魔板"></a>魔板</h2><p><a href="https://www.acwing.com/problem/content/1109/">原题链接</a></p>
<p>Rubik 先生在发明了风靡全球的魔方之后，又发明了它的二维版本——魔板。</p>
<p>这是一张有 8 个大小相同的格子的魔板：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">8 7 6 5</span><br></pre></td></tr></table></figure>
<p>我们知道魔板的每一个方格都有一种颜色。</p>
<p>这 8 种颜色用前 8 个正整数来表示。</p>
<p>可以用颜色的序列来表示一种魔板状态，规定从魔板的左上角开始，沿顺时针方向依次取出整数，构成一个颜色序列。</p>
<p>对于上图的魔板状态，我们用序列 (1,2,3,4,5,6,7,8) 来表示，这是基本状态。</p>
<p>这里提供三种基本操作，分别用大写字母 A，B，C 来表示（可以通过这些操作改变魔板的状态）：</p>
<p>A：交换上下两行；<br>B：将最右边的一列插入到最左边；<br>C：魔板中央对的4个数作顺时针旋转。</p>
<p>下面是对基本状态进行操作的示范：</p>
<p>A：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 7 6 5</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>
<p>B：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1 2 3</span><br><span class="line">5 8 7 6</span><br></pre></td></tr></table></figure>
<p>C：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 7 2 4</span><br><span class="line">8 6 3 5</span><br></pre></td></tr></table></figure>
<p>对于每种可能的状态，这三种基本操作都可以使用。</p>
<p>你要编程计算用最少的基本操作完成基本状态到特殊状态的转换，输出基本操作序列。</p>
<p>注意：数据保证一定有解。</p>
<p><strong>输入格式</strong></p>
<p>输入仅一行，包括 8 个整数，用空格分开，表示目标状态。</p>
<p><strong>输出格式</strong></p>
<p>输出文件的第一行包括一个整数，表示最短操作序列的长度。</p>
<p>如果操作序列的长度大于0，则在第二行输出字典序最小的操作序列。</p>
<p><strong>数据范围</strong></p>
<p>输入数据中的所有数字均为 1 到 8 之间的整数。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line">BCABCCB</span><br></pre></td></tr></table></figure>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个原始状态，问怎么经过最少步骤转换成特殊状态，以及转换步骤是什么</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路比较简单但是代码实现有难度，依然是把原始状态先入队，然后每次更新队头序列可以进行的操作<br>每个操作直接打表更简单</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[<span class="number">10</span>];</span><br><span class="line">string endd;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; dist; <span class="comment">// 存储每一个状态到最终状态的距离</span></span><br><span class="line">map&lt;string, pair&lt;<span class="type">char</span>, string&gt; &gt; pre; <span class="comment">// 存储从后一个状态到前一个状态的具体操作</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">get</span><span class="params">(string t, <span class="type">int</span> op)</span> <span class="comment">// 模拟每个操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string k;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">0</span>) k = &#123;t[<span class="number">4</span>], t[<span class="number">5</span>], t[<span class="number">6</span>], t[<span class="number">7</span>], t[<span class="number">0</span>], t[<span class="number">1</span>], t[<span class="number">2</span>], t[<span class="number">3</span>]&#125;;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) k = &#123;t[<span class="number">3</span>], t[<span class="number">0</span>], t[<span class="number">1</span>], t[<span class="number">2</span>], t[<span class="number">7</span>], t[<span class="number">4</span>], t[<span class="number">5</span>], t[<span class="number">6</span>]&#125;;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">2</span>) k = &#123;t[<span class="number">0</span>], t[<span class="number">5</span>], t[<span class="number">1</span>], t[<span class="number">3</span>], t[<span class="number">4</span>], t[<span class="number">6</span>], t[<span class="number">2</span>], t[<span class="number">7</span>]&#125;;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;12348765&quot;</span>;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t == endd) <span class="keyword">return</span> dist[t];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ ) <span class="comment">// 更新每个操作后的新序列</span></span><br><span class="line">        &#123;</span><br><span class="line">            string s = <span class="built_in">get</span>(t, i);</span><br><span class="line">            <span class="keyword">if</span> (!dist.<span class="built_in">count</span>(s))</span><br><span class="line">            &#123;</span><br><span class="line">                dist[s] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                pre[s] = &#123;<span class="string">&#x27;A&#x27;</span> + i, t&#125;;</span><br><span class="line">                q.<span class="built_in">push</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start = <span class="string">&quot;12348765&quot;</span>, ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">reverse</span>(a + <span class="number">5</span>, a + <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i ++ ) endd.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (endd != start)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += pre[endd].first;</span><br><span class="line">        endd = pre[endd].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="双向广搜"><a href="#双向广搜" class="headerlink" title="双向广搜"></a>双向广搜</h1><p>因为BFS越到后面，每一层可以扩展的情况越多（会成指数型增长），为了防止TLE &#x2F; MLE，可以用双向广搜对其进行优化</p>
<p>从两端开始搜索，到中间相遇，使得搜索次数降低，避免了中间大部分不必要的搜索环节</p>
<h2 id="字串变换"><a href="#字串变换" class="headerlink" title="字串变换"></a>字串变换</h2><p><a href="https://www.acwing.com/problem/content/192/">原题链接</a></p>
<p>已知有两个字串 A, B 及一组字串变换的规则（至多 6 个规则）:</p>
<p>A1→B1<br>A2→B2<br>…</p>
<p>规则的含义为：在 A 中的子串 A1 可以变换为 B1、A2 可以变换为 B2…。</p>
<p>例如：A＝abcd B＝xyz</p>
<p>变换规则为：<br>abc → xu ud → y y → yz</p>
<p>则此时，A 可以经过一系列的变换变为 B，其变换的过程为：</p>
<p>abcd → xud → xy → xyz</p>
<p>共进行了三次变换，使得 A 变换为 B。</p>
<p>注意，一次变换只能变换一个子串，例如 A＝aa B＝bb</p>
<p>变换规则为：</p>
<p>a → b</p>
<p>此时，不能将两个 a 在一步中全部转换为 b，而应当分两步完成。</p>
<p><strong>输入格式</strong></p>
<p>输入格式如下：<br>A B<br>A1 B1<br>A2 B2<br>… …</p>
<p>第一行是两个给定的字符串 A 和 B。</p>
<p>接下来若干行，每行描述一组字串变换的规则。</p>
<p>所有字符串长度的上限为 20。</p>
<p><strong>输出格式</strong></p>
<p>若在 10 步（包含 10 步）以内能将 A 变换为 B ，则输出最少的变换步数；否则输出 NO ANSWER!。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">abcd xyz</span><br><span class="line">abc xu</span><br><span class="line">ud y</span><br><span class="line">y yz</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>一个字符串想转变成另一个字符串，现在给出若干个变换规则（某个字串可以转换成另一个字串），问最少的步骤数目是多少</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>从开始和结尾两个字符串同时往中间搜索，搜索过程中相遇就直接输出，具体看代码注释</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string A, B;</span><br><span class="line">string a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(queue&lt;string&gt;&amp; q, unordered_map&lt;string, <span class="type">int</span>&gt;&amp; da, unordered_map&lt;string, <span class="type">int</span>&gt;&amp; db, string a[N], string b[N])</span> <span class="comment">// 要处理da 从a-&gt;b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = da[q.<span class="built_in">front</span>()];</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; da[q.<span class="built_in">front</span>()] == d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 遍历每个规则</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t.<span class="built_in">size</span>(); j ++ ) <span class="comment">// 遍历每个元素作为开头</span></span><br><span class="line">                <span class="keyword">if</span> (t.<span class="built_in">substr</span>(j, a[i].<span class="built_in">size</span>()) == a[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    string r = t.<span class="built_in">substr</span>(<span class="number">0</span>, j) + b[i] + t.<span class="built_in">substr</span>(j + a[i].<span class="built_in">size</span>()); <span class="comment">// 记录新字符串</span></span><br><span class="line">                    <span class="keyword">if</span> (db.<span class="built_in">count</span>(r)) <span class="keyword">return</span> da[t] + db[r] + <span class="number">1</span>; <span class="comment">// 在另一个里找到了，直接输出</span></span><br><span class="line">                    <span class="keyword">if</span> (da.<span class="built_in">count</span>(r)) <span class="keyword">continue</span>; <span class="comment">// 在自己里找到了，说明重复了直接开始下一次循环</span></span><br><span class="line">                    da[r] = da[t] + <span class="number">1</span>; <span class="comment">// 更新距离</span></span><br><span class="line">                    q.<span class="built_in">push</span>(r); <span class="comment">// 新字符串入队</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == B) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    queue&lt;string&gt; qa, qb; <span class="comment">// qa qb两个队列同时搜索</span></span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; da, db; <span class="comment">// 不同字符串到起始字符串的步骤数</span></span><br><span class="line"></span><br><span class="line">    qa.<span class="built_in">push</span>(A), qb.<span class="built_in">push</span>(B); <span class="comment">// 队头入队</span></span><br><span class="line">    da[A] = db[B] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (qa.<span class="built_in">size</span>() &amp;&amp; qb.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="comment">// 每次对队列长的那边进行操作</span></span><br><span class="line">        <span class="keyword">if</span> (qa.<span class="built_in">size</span>() &lt; qb.<span class="built_in">size</span>()) t = <span class="built_in">extend</span>(qa, da, db, a, b);</span><br><span class="line">        <span class="keyword">else</span> t = <span class="built_in">extend</span>(qb, db, da, b, a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t &lt;= <span class="number">10</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">if</span> ( ++ step == <span class="number">10</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a[n] &gt;&gt; b[n]) n ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">-1</span>) cout &lt;&lt; <span class="string">&quot;NO ANSWER!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h1><p>A*与双向广搜解决的问题类似，利用<strong>估价函数</strong>，在非常少的步骤内从一个状态到达另一个状态</p>
<p>可以解决任何边权的问题，只要没有负权回路</p>
<p>步骤：</p>
<ol>
<li>把BFS中的队列换成优先队列（小根堆），队列中存的是从起点到当前点的真实距离（不一定是最短距离）和从当前点到终点的估计距离（<del>算法的尽头是玄学</del>），优先队列排序的依据是存储的两个距离相加，也就是从起点到终点的估计距离</li>
<li>取出优先队列队头（也就是估计距离最短的点）</li>
<li>for循环 t 的所有邻边，能更新的话就更新并将邻边入队</li>
<li>当终点第一次出队时break</li>
</ol>
<p>（和Dijkstra非常像，可以看为Dijkstra中所有从当前点到终点的估计距离都取0（（但本质上没什么关系</p>
<p><strong>必须要保证当前点到终点的估计距离一定要小于等于真实距离，并且要保证有解（否则效率很低）</strong></p>
<p>A*只能保证终点距离起点是最优的，不能保证其他点第一次出队时也是最优的，除了终点外，每个点不一定只扩展一次</p>
<h2 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h2><p><a href="https://www.acwing.com/problem/content/181/">原题链接</a></p>
<p>在一个 3×3 的网格中，1∼8 这 8 个数字和一个 X 恰好不重不漏地分布在这 3×3 的网格中。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">X 4 6</span><br><span class="line">7 5 8</span><br></pre></td></tr></table></figure>
<p>在游戏过程中，可以把 X 与其上、下、左、右四个方向之一的数字交换（如果存在）。</p>
<p>我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 X</span><br></pre></td></tr></table></figure>
<p>例如，示例中图形就可以通过让 X 先后与右、下、右三个方向的数字交换成功得到正确排列。</p>
<p>交换过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3   1 2 3   1 2 3   1 2 3</span><br><span class="line">X 4 6   4 X 6   4 5 6   4 5 6</span><br><span class="line">7 5 8   7 5 8   7 X 8   7 8 X</span><br></pre></td></tr></table></figure>
<p>把 X 与上下左右方向数字交换的行动记录为 u、d、l、r。</p>
<p>现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列。</p>
<p><strong>输入格式</strong></p>
<p>输入占一行，将 3×3 的初始网格描绘出来。</p>
<p>例如，如果初始网格如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">x 4 6 </span><br><span class="line">7 5 8 </span><br></pre></td></tr></table></figure>
<p>则输入为：<code>1 2 3 x 4 6 7 5 8</code></p>
<p><strong>输出格式</strong></p>
<p>输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。</p>
<p>如果答案不唯一，输出任意一种合法方案即可。</p>
<p>如果不存在解决方案，则输出 <code>unsolvable</code>。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">5</span>  x  <span class="number">7</span>  <span class="number">6</span>  <span class="number">8</span> </span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ullddrurdllurdruldr</span><br></pre></td></tr></table></figure>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>每次可以修改一个数字上下左右移动，输出一个从给定状态转化到标准状态的最少步骤</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>首先，怎么判断是否有解？</p>
<p>我们将九宫格中的数字转换成字符串，每次将数字左右移动时，字符串中的逆序对数量不变，上下移动时，逆序对数量总是改变2，所以奇偶性不变<br>我们知道最终要求的状态的逆序对是偶数，所以看初始状态的逆序对数量，是偶数就一定有解，是奇数就一定无解</p>
<p>然后是最关键的问题：怎么设计估计函数？</p>
<p>注意到每次移动，最好的情况是将移动的数字向目标位置移动一格，因此估价函数可以取当前的每一个数字和最终目标位置之间的曼哈顿距离之和（这样可以保证估计值一定小于等于真实值）</p>
<h3 id="代码（＋详细注释）"><a href="#代码（＋详细注释）" class="headerlink" title="代码（＋详细注释）"></a>代码（＋详细注释）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, string&gt; PIS;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(string state)</span> <span class="comment">// 估价函数（曼哈顿距离）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        <span class="keyword">if</span> (state[i] != <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = state[i] - <span class="string">&#x27;1&#x27;</span>; <span class="comment">// 转换成数字</span></span><br><span class="line">            res += <span class="built_in">abs</span>(i / <span class="number">3</span> - t / <span class="number">3</span>) + <span class="built_in">abs</span>(i % <span class="number">3</span> - t % <span class="number">3</span>); <span class="comment">// 计算曼哈顿距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">bfs</span><span class="params">(string start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string end = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">    <span class="type">char</span> op[] = <span class="string">&quot;urdl&quot;</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; dist; <span class="comment">// 记录每个状态距离初始状态的步数</span></span><br><span class="line">    unordered_map&lt;string, pair&lt;<span class="type">char</span>, string&gt; &gt; prev; <span class="comment">// 前一个字符串是由后一个字符串经过什么操作得来的</span></span><br><span class="line">    priority_queue&lt;PIS, vector&lt;PIS&gt;, greater&lt;PIS&gt; &gt; heap; <span class="comment">// 第一个参数是估计距离 第二个参数是当前状态</span></span><br><span class="line"></span><br><span class="line">    dist[start] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="built_in">f</span>(start), start&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>(); <span class="comment">// 取出队头元素</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        string state = t.sd; <span class="comment">// 当前状态</span></span><br><span class="line">        <span class="keyword">if</span> (state == end) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x, y; <span class="comment">// xy表示空位的坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (state[i] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x = i / <span class="number">3</span>, y = i % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        string source = state; <span class="comment">// 记录当前状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) <span class="comment">// 遍历四个操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = x + dx[i], b = y + dy[i]; <span class="comment">// 操作后坐标</span></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= <span class="number">3</span> || b &lt; <span class="number">0</span> || b &gt;= <span class="number">3</span>) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            state = source; <span class="comment">// 将state在每个操作前恢复至初始状态</span></span><br><span class="line">            <span class="built_in">swap</span>(state[x * <span class="number">3</span> + y], state[a * <span class="number">3</span> + b]); <span class="comment">// 修改操作后字符窜</span></span><br><span class="line">            <span class="keyword">if</span> (!dist.<span class="built_in">count</span>(state) || dist[state] &gt; dist[source] + <span class="number">1</span>) <span class="comment">// 没更新过或者有更优解</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[state] = dist[source] + <span class="number">1</span>; <span class="comment">// 更新距离</span></span><br><span class="line">                prev[state] = &#123;op[i], source&#125;; <span class="comment">// 记录操作</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[state] + <span class="built_in">f</span>(state), state&#125;); <span class="comment">// 存进优先队列中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res; <span class="comment">// 记录操作字符串</span></span><br><span class="line">    <span class="keyword">while</span> (end != start)</span><br><span class="line">    &#123;</span><br><span class="line">        res += prev[end].ft;</span><br><span class="line">        end = prev[end].sd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start, seq;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        start += c;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;x&#x27;</span>) seq += c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 逆序对数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; <span class="number">8</span>; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (seq[i] &gt; seq[j]) cnt ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;unsolvable\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">bfs</span>(start) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第K短路"><a href="#第K短路" class="headerlink" title="第K短路"></a>第K短路</h2><p><a href="https://www.acwing.com/problem/content/180/">原题链接</a></p>
<p>给定一张 N 个点（编号 1,2…N），M 条边的有向图，求从起点 S 到终点 T 的第 K 短路的长度，路径允许重复经过点或边。</p>
<p>注意： 每条最短路中至少要包含一条边。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 N 和 M。</p>
<p>接下来 M 行，每行包含三个整数 A,B 和 L，表示点 A 与点 B 之间存在有向边，且边长为 L。</p>
<p>最后一行包含三个整数 S,T 和 K，分别表示起点 S，终点 T 和第 K 短路。</p>
<p><strong>输出格式</strong></p>
<p>输出占一行，包含一个整数，表示第 K 短路的长度，如果第 K 短路不存在，则输出 −1。</p>
<p><strong>数据范围</strong></p>
<p>1 ≤ S , T ≤ N ≤ 1000,<br>0 ≤ M ≤ 104,<br>1 ≤ K ≤ 1000,<br>1 ≤ L ≤ 100</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>找到起点到终点第k短的路径</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这一题和之前不同的地方在于，之前只有需要更新距离的时候才将点存进队列，现在不管是否需要更新距离，都要存进队列</p>
<p>估价函数：从起点到终点的最短路（用Dijkstra求）（这样就可以保证估计距离小于等于真实距离）</p>
<p>之前求最短路的时候我们认为终点第一次从队列中弹出时是最小值，在这里第k次从队列中弹出时是第k小值（因为每个点最多只能走不超过K次）（可以证明）</p>
<h3 id="代码（-详细注释）"><a href="#代码（-详细注释）" class="headerlink" title="代码（ + 详细注释）"></a>代码（ + 详细注释）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, PII&gt; PIII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, S, T, K;</span><br><span class="line"><span class="type">int</span> h[N], rh[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap; <span class="comment">// 第二个参数是点 第一个参数是第二个参数到终点的距离</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, T&#125;); <span class="comment">// 终点入队</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[T] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.sd; <span class="comment">// 记录当前遍历的点</span></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = rh[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i]) <span class="comment">// 不是最优解就更新距离并入队</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">astar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt; &gt; heap; <span class="comment">// 第一个参数是估计距离 第二个参数中 ft:到起始点的距离 sd:当前点</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;dist[S], &#123;<span class="number">0</span>, S&#125;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.sd.sd, distance = t.sd.ft; <span class="comment">// distance是到起点的真实距离</span></span><br><span class="line">        cnt[ver] ++ ; <span class="comment">// 第几次遍历该点</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[T] == K) <span class="keyword">return</span> distance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i]) <span class="comment">// 遍历所有邻接点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt[j] &lt; K) <span class="comment">// 没遍历k次以上的就入队</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;distance + w[i] + dist[j], &#123;distance + w[i], j&#125;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(rh, <span class="number">-1</span>, <span class="keyword">sizeof</span> rh);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(h, a, b, c); <span class="comment">// 存正向边</span></span><br><span class="line">        <span class="built_in">add</span>(rh, b, a, c); <span class="comment">// 存反向边（因为dijkstra里需要计算所有点到终点的最短路</span></span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; S &gt;&gt; T &gt;&gt; K;</span><br><span class="line">    <span class="keyword">if</span> (S == T) K ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">astar</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>最小步数</tag>
        <tag>双向广搜</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】ST表与RMQ算法</title>
    <url>/posts/7527e30.html</url>
    <content><![CDATA[<p>本文参考<a href="https://zhuanlan.zhihu.com/p/123360481">【朝夕的ACM笔记】数据结构-ST表</a></p>
<p>在练习线段树的过程中经常会感叹代码怎么这么长啊啊啊懒标记怎么这么难传啊啊啊</p>
<p>于是在得知有一种代码量远小于线段树的算法时、、、（其实是因为做到了<a href="https://www.luogu.com.cn/problem/P2471">[SCOI2007] 降雨量</a></p>
<p>就是ST表啦~</p>
<p>在什么情况下可以用ST表代替线段树呢？</p>
<p><strong>&#x3D;&#x3D;不需要区间修改&#x3D;&#x3D;的&#x3D;&#x3D;可重复贡献问题&#x3D;&#x3D;</strong></p>
<p>不需要区间修改很好理解，什么叫做可重复贡献呢？</p>
<p>我们知道，求一个数组的最大值（比如说长度为10的数组），我们可以先求前六个数的最大值，再求后七个数的最大值，最后求这两个最大值的最大值，虽然这中间有重复的元素，但是对最终的最大值结果不会有影响，这就叫做可重复贡献问题。</p>
<p>但是如果我们要求一个数组中所有元素的和（还是比如说长度为10的数组），我们就不能用前六个元素的和加上后七个元素的和了，这就叫做不可重复贡献问题。</p>
<p>常见的可重复贡献问题包括：求<strong>区间最大&#x2F;小值</strong>，<strong>区间按位和&#x2F;或</strong>，<strong>区间gcd</strong>…</p>
<p><strong>怎么构建ST表呢？</strong></p>
<p>ST表是一种基于<strong>倍增</strong>算法的数据结构</p>
<p>我们设<code>f[i][j]</code>表示区间 $[i, i + 2^j - 1]$ 的最大值，因此<code>f[i][0]</code>表示的就是第 i 个元素本身了</p>
<p>由倍增思想，区间 $[i, i + 2^j - 1]$ 可以被我们拆成两个长度为 $2^{j - 1}$ 的子区间，所以可以的到递推式 $f[i][j]&#x3D;max(f[i][j - 1], f[i + 2^{j-1}][j-1])$，因此先枚举 $j$，再枚举 $i$，就可以得到 $f[i][j]$ 的值了</p>
<p><strong>怎么查询区间信息呢？–&gt; RMQ算法</strong></p>
<p>如果我们想知道 $[l, r]$ 的最值，我们可能会输出 $f[l][x]$, $l+2^x-1&#x3D;r$，这样解出x，会发现 $x&#x3D;log_2(r-l+1)$，这样得到的 x 就不一定是个整数了，向下取整的话可能会使区间有所损失</p>
<p>这时可重复贡献的性质就发挥作用了，我们把要查询的区间 $[l,r]$ 分成长度为 $\lfloor{x}\rfloor$ 两部分，一部分以 l 开头，一部分以 r 结尾，也就是 $[l, l+2^x-1]$ 和 $[r-2^x+1,r]$，只要找到这两个区间的最大值，再取最大值，就可以得到整个区间的最大值了</p>
<p><strong>时间复杂度</strong></p>
<p>预处理 $O(nlogn)$<br>查询 $O(1)$</p>
<p><strong>板子</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">100005</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> logn[<span class="number">100005</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span> <span class="comment">// 预处理log 防止查询时T</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    logn[<span class="number">1</span>] = <span class="number">0</span>, logn[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">        logn[i] = logn[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入数组本身</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; f[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">21</span>; j++) <span class="comment">// 2的21次方满足两百万数据 数据变大上限也要变大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i ++ )</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]); <span class="comment">// 这里根据所求内容不同需要做相应修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// RMQ查询</span></span><br><span class="line">        <span class="type">int</span> lg = logn[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(f[l][lg], f[r - (<span class="number">1</span> &lt;&lt; lg) + <span class="number">1</span>][lg]);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>ST表</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】并查集</title>
    <url>/posts/2e7813af.html</url>
    <content><![CDATA[<p>今天补题遇到了这个知识点，能想到这个方法但是自己没办法实现，所以来复习一下相关知识做个总结~</p>
<p>并查集，简单来说，就是合并两个集合，然后能迅速判断两个元素是否在同一集合中<br><strong>板子</strong><br>返回 x 的祖先结点，同时进行路径压缩，让 p[x] 直接指向祖先结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现方法：</strong><br>首先所有元素各为一个集合，创建数组 p[i]，意为 i 的父结点，起初，p[i] 全部等于 i </p>
<ul>
<li>当两个元素 a b 进行合并时（实际上就是两个集合进行合并），让 a 的祖先结点的父结点等于 b 的祖先结点，a 的祖先结点直接指向 b 的祖先结点<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure></li>
<li>当询问两个元素 a b 是否在同一个集合中时，只需要看 a b 的祖先结点是不是同一个，也就是判断 find(a) &#x3D;&#x3D; find(b) 是否成立</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】树状数组</title>
    <url>/posts/b289bb13.html</url>
    <content><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/574739597">https://zhuanlan.zhihu.com/p/574739597</a></p>
<p>树状数组主要是支持两种操作：</p>
<ul>
<li><strong>单点修改</strong></li>
<li><strong>区间查询</strong></li>
</ul>
<p>这两个操作的时间复杂度都是 <em>O(logn)</em><br>根据前缀和的原理，任意一段区间求和都可以转换成两个前缀和的差，因此区间求和问题转换成求前缀和问题</p>
<h1 id="前提准备：计算-lowbit"><a href="#前提准备：计算-lowbit" class="headerlink" title="前提准备：计算 lowbit"></a>前提准备：计算 lowbit</h1><p>在此我们定义一个 <code>lowbit(x)</code> ，表示 x 的最末尾一个 1 与这个 1 后面的所有 0 组成的二进制数<br><code>lowbit(x)</code> 应该怎么实现呢？<br>很简单，这里直接给出结论 <code>lowbit(x) = x &amp; -x</code><br>还是通过例子来说明</p>
<blockquote>
<p>现有二进制数 101100<br>x &#x3D; 101100<br>反码：010011<br>补码：010100</p>
</blockquote>
<p>可以注意到，-x 是 x 末尾的一个 1 到结束的 0 不动，前面全部取反的结果<br>那么 <code>x &amp; -x</code> 就只保留了末尾的 1 和后面的 0<br>因此得到我们的 lowbit 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="树状数组的含义"><a href="#树状数组的含义" class="headerlink" title="树状数组的含义"></a>树状数组的含义</h1><p>我们定义原数组为<code>a</code>，用一个数组 <code>tree</code> 维护若干个小区间，<code>tree[i]</code> 表示<strong>以<code>a[i]</code>为结尾、长度为<code>lowbit(i)</code>的区间的和，也就是<code>(i-lowbit(i), i]</code>（左开右闭）这一区间的和</strong>（这一点很重要，请务必记住）<br>举个栗子吧</p>
<blockquote>
<p>i &#x3D; 5 &#x3D; 101<del>(2)</del><br>lowbit(i) &#x3D; lowbit(101) &#x3D; 001<del>(2)</del> &#x3D; 1         i - lowbit(i) &#x3D; 100<del>(2)</del> &#x3D; 4<br>i &#x3D; i - lowbit(i) &#x3D; 4 &#x3D; 100<del>(2)</del><br>lowbit(i) &#x3D; lowbit(100) &#x3D; 100<del>(2)</del>         i - lowbit(i) &#x3D; 0<br>因此 lowbit(5) 就等于以 a[5] 结尾，长度为 lowbit(5) &#x3D; 1 的区间的和，也就是等于 a[5]</p>
</blockquote>
<ul>
<li>单点修改时，只更新<strong>包含这一元素的区间</strong></li>
<li>求前 n 项和时，通过将区间进行<strong>组合</strong>，得到从 1 到 n 的区间，然后对所有用到的区间求和。<br>将 n 转换为二进制，任意一个数都可以看作是几个二进制数表示区间的和<br>举个栗子<blockquote>
<p>11<del>(10)</del> &#x3D; 1011<del>(2)</del><br>求前 11 项的和，可以转换成求 1010 - 1011、1000 - 1010、0000 - 1000 这几个区间的和</p>
</blockquote>
</li>
</ul>
<p>这个步骤就是在不断地删去最末尾的一个 1<br>而我们刚刚在前提准备里提到，lowbit 运算，就是不断删去末尾的 1 的过程</p>
<p>因此单点修改时，我们只需要从<code>tree[1]</code>开始，每次将<code>i</code> 更新成<code>i + lowbit(i)</code>，修改当前的<code>tree[i]</code>，直到<code>i</code>被更新为 N<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= N)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[i] += x;</span><br><span class="line">		i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求 <code>a[i]</code> 的前缀和时，可以利用循环来求解，每次将 <code>i</code> 更新为 <code>i - lowbit(i)</code>，加上修改后的 <code>i</code> 的 <code>tree[i]</code> 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefix_sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		presum += tree[i];</span><br><span class="line">		i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> presum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，区间求和的代码也显而易见了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">prefix_sum</span>(r) - <span class="built_in">prefix_sum</span>(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拓展应用"><a href="#拓展应用" class="headerlink" title="拓展应用"></a>拓展应用</h1><h2 id="拓展一：区间修改、单点查询"><a href="#拓展一：区间修改、单点查询" class="headerlink" title="拓展一：区间修改、单点查询"></a>拓展一：区间修改、单点查询</h2><p>区间修改，我们需要给区间内的每个数加上同一个给定值 x，很容易想到利用差分来降低复杂度，记原数组为<code>a[i]</code>，差分数组为<code>b[i]</code>，<code>b[i] = a[i] - a[i - 1]</code><br>在<code>b[i]</code>上建立树状数组<code>tree[i]</code>，每次对<code>a</code>中<code>[l, r]</code>区间上的修改，就相当于<code>b[l] += x</code>和<code>b[r + 1] -= x</code>，这样我们也可以对<code>tree[i]</code>做出相应的两次单点修改，于是区间修改也被我们转换成单点修改得到解决了</p>
<p>单点查询，根据差分数组的性质，<code>a[i] = b[1] + b[2] + … + b[i]</code>，即可将单点查询转换成求<code>b</code>的前缀和，进而利用树状数组进行计算</p>
<h2 id="拓展二：区间查询、区间修改"><a href="#拓展二：区间查询、区间修改" class="headerlink" title="拓展二：区间查询、区间修改"></a>拓展二：区间查询、区间修改</h2><p>计算<code>a[i]</code>时，需要计算<code>b[i]</code>的前缀和<br>所以计算<code>a[i]</code>的前缀和时，我们就需要计算<code>b[i]</code>的前缀和的前缀和<br>用数学公式表达如下：（计算<code>a[p]</code>的前缀和）</p>
<p>$\sum_{i &#x3D; 1}^{p} a[i] &#x3D; \sum_{i &#x3D; 1}^{p}(\sum_{j &#x3D; 1}^{i} b[j])$</p>
<p>等号右侧中，<code>b[1]</code>出现了 p 次，<code>b[2]</code>出现了 p - 1 次，<code>b[j]</code>出现了 p + 1 - j 次。因此可知：</p>
<p>$\sum_{i &#x3D; 1}^{p} a[i] &#x3D; (p + 1)\sum_{j &#x3D; i  -1}^{p}b[j] - \sum_{j &#x3D; 1}^{p}b[j] * j$</p>
<p>可以理解为：我们先把每个<code>b[j]</code>都算作出现了<code>p + 1</code>次，然后再把多算的 <code>j</code> 次减去。</p>
<p>因此——</p>
<ul>
<li><code>b[i] = a[i] - a[i - 1]</code></li>
<li><code>c[i] = b[i] * i</code></li>
</ul>
<p>对于<code>b[i]</code>和<code>c[i]</code>都建立树状数组，这样就可以很容易求出<code>b[i]</code>和<code>c[i]</code>的前缀和，也就得到了<code>a[i]</code>的前缀和，区间查询完成</p>
<p>对于区间修改，我们将<code>a</code>的<code>[l, r]</code>每个元素加上 x，<code>b</code>的变化方式为<code>b[l] += x</code>和<code>b[r + 1] -= x</code>，相应的，<code>c</code>的变化方式为<code>c[l] += x * l ，c[r + 1] -= x * (r + 1)</code>，也就是对 b 和 c 进行两次单点修改，这个步骤已经在上面写过就不重复了</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线段树</title>
    <url>/posts/63fc9272.html</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&#x3D;&#x3D;<strong>时间复杂度：O(logn)</strong>&#x3D;&#x3D;</p>
<p>线段树是一棵二叉树，把一段区间分成多个部分</p>
<img src="/posts/63fc9272/1.png" class title="This is an test image">
<p>类似堆的方式，用一维数组存整棵树</p>
<p>对于编号x的结点：</p>
<ul>
<li>父结点 $\lfloor x \rfloor$，表示为 <code>x &gt;&gt; 1</code></li>
<li>左子树 $2x$，表示为 <code>x &lt;&lt; 1</code></li>
<li>右子树 $2x+1$，表示为 <code>x &lt;&lt; 1 | 1</code></li>
</ul>
<p>对于长度为n的区间，最坏估计有 $4n-1$ 个结点，因此 &#x3D;&#x3D;<strong>开数组时空间一般开 $4n$</strong>&#x3D;&#x3D;</p>
<h1 id="pushup"><a href="#pushup" class="headerlink" title="pushup"></a>pushup</h1><p><strong>由子结点计算父结点的信息</strong></p>
<p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u表示当前树中结点编号 lr表示树中结点左右子结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 此处用[l]和[r]的值更新[u] */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="build"><a href="#build" class="headerlink" title="build"></a>build</h1><p><strong>将一段区间初始化为线段树</strong></p>
<ol>
<li>首先记录下当前区间的左右端点，如果左端点和右端点相等就直接返回</li>
<li>如果不相等，取中间值 <code>mid</code>，然后分别递归左右两段</li>
</ol>
<p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u表示当前树中结点编号 lr表示区间左右端点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="comment">// 左右端点相同表示到达叶子结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;    &#125;; <span class="comment">// 创建该结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r); <span class="comment">// 分别构造左右两棵子树</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 利用pushup更新该点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="modify"><a href="#modify" class="headerlink" title="modify"></a>modify</h1><p><strong>修改单点或区间（需要用到push_down操作）</strong></p>
<p><strong>修改单点</strong>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u为当前树中结点编号 要把x位置的值更新为v</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x) <span class="comment">// 到达叶子结点 直接更新</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;     &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v); <span class="comment">// 要更新的位置在左半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v); <span class="comment">// 要更新的位置在右半部分</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 更新此位置结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改区间</strong>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="comment">// 当前树中结点在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (i64)(tr[u].r - tr[u].l + <span class="number">1</span>) * d; <span class="comment">// 更新区间信息</span></span><br><span class="line">        tr[u].add += d; <span class="comment">// 打上懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 当前树中结点不在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u); <span class="comment">// 将懒标记向下传递</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 由于modify修改了区间结点的信息，所以被修改的结点的祖先结点都需要重算一遍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="query"><a href="#query" class="headerlink" title="query"></a>query</h1><p><strong>查询区间信息</strong></p>
<p>假设我们要查询某区间的最大值</p>
<p>定义 <code>[l, r]</code> 为我们要查询的区间，<code>[Tl, Tr]</code> 为树中结点（当前我们正在维护的区间），这两个区间会有如下两种关系：</p>
<ul>
<li>$[Tl, Tr]\subset[l, r]$，树中结点完全包含在要查询的区间内部<br>这种情况直接返回当前区间最大值即可</li>
<li>$[l, r]\bigcap[Tl, Tr]\not&#x3D;\emptyset$，二者有交集<br>和左边有交集就递归到左边做一遍，和右边有交集就递归到右边做一遍<br>即<code>l &gt; mid</code>只递归右边，<code>r &lt;= mid</code>只递归左边，否则左右都递归</li>
</ul>
<p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u]; <span class="comment">// 当前区间在被查询区间之内 直接返回</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r); <span class="comment">// 被查询区间在当前区间左半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r); <span class="comment">// 被查询区间在当前区间右半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 被查询区间横跨当前区间的左右两部分</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r); <span class="comment">// 计算出左半部分值</span></span><br><span class="line">            <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r); <span class="comment">// 计算出右半部分值</span></span><br><span class="line">            Node res;</span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right); <span class="comment">// 更新结果</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="pushdown（懒标记-延迟标记）"><a href="#pushdown（懒标记-延迟标记）" class="headerlink" title="pushdown（懒标记 &#x2F; 延迟标记）"></a>pushdown（懒标记 &#x2F; 延迟标记）</h1><p><strong>将父结点的修改更新到子结点</strong></p>
<p>单点修改可以只用pushup，涉及到区间修改就需要使用pushdown</p>
<p><strong>懒标记</strong> ：在当前树中结点上打上懒标记，就表示对<strong>以当前树中结点为根结点</strong>的<strong>每一个子树</strong>都进行操作（根结点自己不用操作）</p>
<p>那么懒标记怎么进行传递呢？</p>
<p>焗个栗子：比如我们在蓝色的这一段区间上打上懒标记</p>

<p>每当我们需要遍历蓝色区间结点下方的子结点时，我们就把懒标记传递给下一层结点，同时把根结点的懒标记删除，就像这样：</p>

<p>当然，除了传递标记，我们还需要对线段树中记录的值进行更新，比如说这个线段树记录的是区间和，打上懒标记表示这一段区间每一个数都要加上<code>a</code>，那么我们在传递懒标记的同时，还需要让下方结点的区间和加上<code>(r - l + 1) * a</code>，其中<code>(l - r + 1)</code>表示下方被更新结点的区间长度</p>
<p>以此类推，每当我们需要遍历下方结点时，就把懒标记向下传，并更新下方结点的值</p>
<p>以上就是pushdown操作的基本内容</p>
<p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (root.add) <span class="comment">// 当前结点有懒标记 向下传递</span></span><br><span class="line">    &#123;</span><br><span class="line">        left.add += root.add, left.sum += (i64)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (i64)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例题：一个简单的整数问题2"><a href="#例题：一个简单的整数问题2" class="headerlink" title="例题：一个简单的整数问题2"></a>例题：一个简单的整数问题2</h1><p><a href="https://www.acwing.com/problem/content/244/">原题链接</a></p>
<p>给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p>
<p><code>C l r d</code>，表示把 A[l],A[l+1],…,A[r] 都加上 d。<br><code>Q l r</code>，表示询问数列中第 l∼r 个数的和。<br>对于每个询问，输出一个整数表示答案。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数 N,M。</p>
<p>第二行 N 个整数 A[i]。</p>
<p>接下来 M 行表示 M 条指令，每条指令的格式如题目描述所示。</p>
<p><strong>输出格式</strong></p>
<p>对于每个询问，输出一个整数表示答案。</p>
<p>每个答案占一行。</p>
<p><strong>数据范围</strong></p>
<p>$1≤N,M≤105,$<br>$|d|≤10000,$<br>$|A[i]|≤109$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">Q <span class="number">4</span> <span class="number">4</span></span><br><span class="line">Q <span class="number">1</span> <span class="number">10</span></span><br><span class="line">Q <span class="number">2</span> <span class="number">4</span></span><br><span class="line">C <span class="number">3</span> <span class="number">6</span> <span class="number">3</span></span><br><span class="line">Q <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    i64 sum, add; <span class="comment">// 区间和和懒标记</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (root.add) <span class="comment">// 当前结点有懒标记 向下传递</span></span><br><span class="line">    &#123;</span><br><span class="line">        left.add += root.add, left.sum += (i64)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (i64)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="comment">// 当前树中结点在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (i64)(tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[u].add += d; <span class="comment">// 打上懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 当前树中结点不在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u); <span class="comment">// 将懒标记向下传递</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 由于modify修改了区间结点的信息，所以被修改的结点的祖先结点都需要重算一遍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u); <span class="comment">// 为了让查询到的最小结点都已计算过祖先结点的懒标记</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    i64 sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> l, r, d;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; d;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="扫描线法"><a href="#扫描线法" class="headerlink" title="扫描线法"></a>扫描线法</h1><p>放一道例题</p>
<h2 id="亚特兰蒂斯"><a href="#亚特兰蒂斯" class="headerlink" title="亚特兰蒂斯"></a>亚特兰蒂斯</h2><p><a href="https://www.acwing.com/problem/content/249/">原题链接</a></p>
<p>有几个古希腊书籍中包含了对传说中的亚特兰蒂斯岛的描述。</p>
<p>其中一些甚至包括岛屿部分地图。</p>
<p>但不幸的是，这些地图描述了亚特兰蒂斯的不同区域。</p>
<p>您的朋友 Bill 必须知道地图的总面积。</p>
<p>你自告奋勇写了一个计算这个总面积的程序。</p>
<p><strong>输入格式</strong></p>
<p>输入包含多组测试用例。</p>
<p>对于每组测试用例，第一行包含整数 n，表示总的地图数量。</p>
<p>接下来 n 行，描绘了每张地图，每行包含四个数字 x1,y1,x2,y2（不一定是整数），(x1,y1) 和 (x2,y2) 分别是地图的左上角位置和右下角位置。</p>
<p>注意，坐标轴 x 轴从上向下延伸，y 轴从左向右延伸。</p>
<p>当输入用例 n&#x3D;0 时，表示输入终止，该用例无需处理。</p>
<p><strong>输出格式</strong></p>
<p>每组测试用例输出两行。</p>
<p>第一行输出 Test case #k，其中 k 是测试用例的编号，从 1 开始。</p>
<p>第二行输出 Total explored area: a，其中 a 是总地图面积（即此测试用例中所有矩形的面积并，注意如果一片区域被多个地图包含，则在计算总面积时只计算一次），精确到小数点后两位数。</p>
<p>在每个测试用例后输出一个空行。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤10000,$<br>$0≤x1&lt;x2≤100000,$<br>$0≤y1&lt;y2≤100000$</p>
<p>注意，本题 n 的范围上限加强至 10000。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span> <span class="number">20</span> <span class="number">20</span></span><br><span class="line"><span class="number">15</span> <span class="number">15</span> <span class="number">25</span> <span class="number">25.5</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Test <span class="keyword">case</span> #<span class="number">1</span></span><br><span class="line">Total explored area: <span class="number">180.00</span> </span><br></pre></td></tr></table></figure>

<p><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x, y1, y2;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Segment &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">double</span> len;</span><br><span class="line">&#125;tr[N * <span class="number">8</span>]; <span class="comment">// 线段树</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; ys; <span class="comment">// 存储纵坐标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), y) - ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].cnt) tr[u].len = ys[tr[u].r + <span class="number">1</span>] - ys[tr[u].l]; <span class="comment">// 这一段被完全覆盖 所以直接算长度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[u].l != tr[u].r) <span class="comment">// 没有被完全覆盖 分成左右两段分别来看</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = <span class="number">0</span>; <span class="comment">// 叶子结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l != r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// cnt和len都是0所以不需要pushdown</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="comment">// 完全覆盖</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].cnt += k;</span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 更新该节点的len</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        ys.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> x1, x2, y1, y2;</span><br><span class="line">            cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            <span class="comment">// 把所有竖着的线段存进segment</span></span><br><span class="line">            seg[j ++ ] = &#123;x1, y1, y2, <span class="number">1</span>&#125;;</span><br><span class="line">            seg[j ++ ] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">            ys.<span class="built_in">push_back</span>(y1), ys.<span class="built_in">push_back</span>(y2); <span class="comment">// 把所有纵坐标存进ys</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 纵坐标去重</span></span><br><span class="line">        <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>());</span><br><span class="line">        ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>()), ys.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, ys.<span class="built_in">size</span>() - <span class="number">2</span>); <span class="comment">// 纵坐标点的数量到ys-1 线段数量就是ys-2</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(seg, seg + n * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i) res += tr[<span class="number">1</span>].len * (seg[i].x - seg[i - <span class="number">1</span>].x);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test case #&quot;</span> &lt;&lt; T &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        T ++ ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】莫队</title>
    <url>/posts/3dab568c.html</url>
    <content><![CDATA[<p>这篇博客起源于本人把一道 $pow(2,n)$ 的问题考虑成求组合数前缀和的问题qwq，于是接触到了这个新算法来总结一下</p>
<p>参考自<a href="https://www.cnblogs.com/WAMonster/p/10118934.html#!comments">这篇文章</a>，写得太好了</p>
<p>首先是一道<a href="https://www.luogu.com.cn/problem/SP3267">模板题</a></p>
<p>题目意思是，给出一个数组a，再给出多个区间，问这些区间里分别有多少不一样的数字</p>
<p>焗个栗子：</p>
<img src="/posts/3dab568c/1.jpg" class>
<p>比如给出的是这样一个数组，询问的两个区间是红色和绿色标注的区间</p>
<p>如果我们分别遍历每一个区间，复杂度就太高了，因此就有大佬提出这样一种算法——</p>
<p>首先定义双指针 $l$、$r$，初始化为 $l&#x3D;0,r&#x3D;-1$（表示此时区间内没有任何元素），然后用<code>unorderd_map&lt;int, int&gt; map</code>存储当前区间内每个元素的个数</p>
<p>看我们要求的第一个区间 $[0,5]$</p>
<p>$l$ 此时等于$0$，和所求区间的左端点相同，因此无需移动</p>
<p>$r$ 此时等于$-1$，在所求区间右端点的左侧，因此需要向右移</p>
<p>首先向右移一位变成 $0$，此时区间内添加了一个元素 5,因为<code>map[5] = 0</code>，元素5不存在于原来的区间里，因此元素种类数<code>cnt</code>加一，<code>map[5] ++ </code></p>
<p>然后 $r$ 再右移一位变成 1，此时区间内添加了一个元素 7,因为<code>map[7] = 0</code>，元素7不存在于原来的区间里，因此元素种类数<code>cnt</code>加一，<code>map[7] ++ </code></p>
<p>依此类推，直到 $r$ 右移到了 5，此时区间内添加了一个元素 7，但是添加前的<code>map[7] = 1</code>，添加了当前的 7 并不会让区间内元素的个数增多，因此<code>cnt</code>无需改变，<code>map[7] ++</code></p>
<p>之后从红色区间挪到绿色区间的操作也是类似的</p>
<p>上文介绍了如何往区间内添加数，当然，删除一个数的操作也是类似的，只不过添加数时，我们要先看被添加的数有没有出现在原来的区间里，也就是<code>map[x]</code>是否等于0，如果等于0说明不存在于原来的区间，区间内元素种类数<code>cnt</code>才能加一，而删除数时，我们要先把当前数删除，也就是<code>map[x]</code>减一，然后再判断当前区间里还有没有x，如果没有x也就是<code>map[x] == 0</code>，那么区间内元素种类数<code>cnt</code>减一</p>
<p><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!map[a[pos]]) cnt ++ ; <span class="comment">// 在区间中新出现，总数要+1</span></span><br><span class="line">    map[a[pos]] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map[a[pos]] -- ;</span><br><span class="line">    <span class="keyword">if</span> (!map[a[pos]]) cnt -- ; <span class="comment">// 在区间中不再出现，总数要-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入询问区间的左右端点</span></span><br><span class="line">        <span class="type">int</span> ql, qr;</span><br><span class="line">        cin &gt;&gt; ql &gt;&gt; qr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; ql) <span class="built_in">del</span>(l++); <span class="comment">// 如左指针在查询区间左方，左指针向右移直到与查询区间左端点重合</span></span><br><span class="line">        <span class="keyword">while</span> (l &gt; ql) <span class="built_in">add</span>(--l); <span class="comment">// 如左指针在查询区间左端点右方，左指针左移</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; qr) <span class="built_in">add</span>(++r); <span class="comment">// 右指针在查询区间右端点左方，右指针右移</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; qr) <span class="built_in">del</span>(r--);        <span class="comment">// 否则左移</span></span><br><span class="line">        cout &lt;&lt; cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就 <del>结束啦</del> qwq</p>
<p>才怪</p>
<p>还可以对这个算法继续优化</p>
<p> <strong>莫队算法优化的核心是&#x3D;&#x3D;分块&#x3D;&#x3D;和&#x3D;&#x3D;排序&#x3D;&#x3D;</strong></p>
<p>把长度为 $n$ 的序列分成 $\sqrt{n}$ 个块，然后按照左端点所在的块排序，如果左端点在同一个块内，则按右端点排序</p>
<p><strong>优化1</strong><br>这种排序方法也可以接着优化：如果左端点在同一奇数块内，则按右端点从小到大排序，如果左端点在同一偶数块内，则按右端点从大到小排序，这样排序是为了减少右端点移动的次数进而提高效率）</p>
<p><strong>优化2</strong><br>听说开O2优化能产生奇妙反应，实在没办法了可以考虑考虑这个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br></pre></td></tr></table></figure>

<p><strong>优化3</strong><br>某佬把上面的一长串代码简化成了下面这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; ql) cnt -= !--map[a[l++]];</span><br><span class="line"><span class="keyword">while</span>(l &gt; ql) cnt += !map[a[--l]]++;</span><br><span class="line"><span class="keyword">while</span>(r &lt; qr) cnt += !map[a[++r]]++;</span><br><span class="line"><span class="keyword">while</span>(r &gt; qr) cnt -= !--map[a[r--]];</span><br></pre></td></tr></table></figure>
<p>于是模板题的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; PPI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="type">int</span> bnum = <span class="built_in">ceil</span>((<span class="type">double</span>)n / size); <span class="comment">// 把序列分成了多少块</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">belong</span><span class="params">(<span class="number">1e6</span> + <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bnum; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = (i - <span class="number">1</span>) * size + <span class="number">1</span>; j &lt;= i * size; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            belong[j] = i; <span class="comment">// 标记每个元素属于哪个块</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;PPI&gt; <span class="title">q</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; q[i].first.first &gt;&gt; q[i].first.second;</span><br><span class="line">        q[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">bool</span>(PPI a, PPI b)&gt; cmp = [&amp;](PPI a, PPI b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// return (belong[a.first.first] ^ belong[b.first.first]) ? belong[a.first.first] &lt; belong[b.first.first] : ((belong[a.first.first] &amp; 1) ? a.first.second &lt; b.first.second : a.first.second &gt; b.first.second);</span></span><br><span class="line">        <span class="keyword">if</span> (belong[a.first.first] != belong[b.first.first]) <span class="keyword">return</span> belong[a.first.first] &lt; belong[b.first.first];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (belong[a.first.first] % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> belong[a.first.second] &lt; belong[b.first.second];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> belong[a.first.second] &gt; belong[b.first.second];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ql = q[i].first.first, qr = q[i].first.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; ql) cnt -= !--map[a[l ++ ]];</span><br><span class="line">        <span class="keyword">while</span>(l &gt; ql) cnt += !map[a[-- l]] ++;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; qr) cnt += !map[a[++ r]] ++;</span><br><span class="line">        <span class="keyword">while</span>(r &gt; qr) cnt -= !--map[a[r -- ]];</span><br><span class="line"></span><br><span class="line">        ans[q[i].second] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的之后更新~~qwq</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
</search>
