<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【数论】GCD与LCM</title>
      <link href="/posts/20e3f349.html"/>
      <url>/posts/20e3f349.html</url>
      
        <content type="html"><![CDATA[<h1 id="最大公约数gcd"><a href="#最大公约数gcd" class="headerlink" title="最大公约数gcd"></a>最大公约数gcd</h1><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &gt; <span class="number">0</span> ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小公倍数lcm"><a href="#最小公倍数lcm" class="headerlink" title="最小公倍数lcm"></a>最小公倍数lcm</h1><h2 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ol><li><code>gcd(a, b) * lcm(a, b) = a * b</code></li><li><code>gcd(a, b) = gcd(a, b - a)</code></li><li><code>gcd(a, b, c) = gcd(a, gcd(b, c))</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcd </tag>
            
            <tag> lcm </tag>
            
            <tag> 数论 </tag>
            
            <tag> 最大公约数 </tag>
            
            <tag> 最小公倍数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多数组判断的边界问题</title>
      <link href="/posts/ef231f25.html"/>
      <url>/posts/ef231f25.html</url>
      
        <content type="html"><![CDATA[<p>背景是有两个字符串 <code>s1</code> 和 <code>s2</code>， 要找到 <code>s2</code> 中的每个字符第一次出现在 <code>s1</code> 中的位置</p><p>方法一：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s2.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (s1[i] != s2[j]) i ++ ;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s2.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (s1[++ i] != s2[j])</span><br><span class="line">;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>它们的最大不同之处在于&#x3D;&#x3D;如果<code>s2</code>中有两个连续的相同的字符，方法一会把这两个字符映射到<code>s1</code>中的同一个位置，方法二会把这两个字符映射到<code>s1</code>中的前后两个位置&#x3D;&#x3D;</strong></p><p>举个栗子</p><blockquote><p><code>s1 = aaaaa</code></p><p><code>s2 = aa</code></p></blockquote><p>根据方法一，<code>s2</code> 的第一个 <code>a</code> 对应 <code>s1</code> 的第一个 <code>a</code>， <code>s2</code> 的第二个 <code>a</code> 也对应 <code>s1</code> 的第一个 <code>a</code></p><p>根据方法二，<code>s2</code> 的第一个 <code>a</code> 对应 <code>s1</code> 的第一个 <code>a</code>， <code>s2</code> 的第二个 <code>a</code> 对应 <code>s1</code> 的第二个 <code>a</code></p>]]></content>
      
      
      <categories>
          
          <category> 记录遇到的问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】查找排序_复习笔记总结</title>
      <link href="/posts/a7becaf9.html"/>
      <url>/posts/a7becaf9.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、查找"><a href="#一、查找" class="headerlink" title="一、查找"></a>一、查找</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="（1）-查找表"><a href="#（1）-查找表" class="headerlink" title="（1） 查找表"></a>（1） 查找表</h3><p>比如说线性表、树表、散列表</p><h3 id="（2）-动态查找表和静态查找表"><a href="#（2）-动态查找表和静态查找表" class="headerlink" title="（2） 动态查找表和静态查找表"></a>（2） 动态查找表和静态查找表</h3><ul><li>动态查找表：边找边操作，找到了就返回，找不到就插入</li><li>静态查找表：不可以操作</li></ul><h3 id="（3）-平均查找长度-ASL"><a href="#（3）-平均查找长度-ASL" class="headerlink" title="（3） 平均查找长度 ASL"></a>（3） 平均查找长度 ASL</h3><p>其中，P<del>i</del> 为查找表中第 i 个记录的概率，C<del>i</del> 为找到表中其关键字与给定值相等的第 i 个记录时比较次数。</p><h2 id="2-线性表的查找"><a href="#2-线性表的查找" class="headerlink" title="2. 线性表的查找"></a>2. 线性表的查找</h2><h3 id="（1）-顺序查找"><a href="#（1）-顺序查找" class="headerlink" title="（1） 顺序查找"></a>（1） 顺序查找</h3><p>翻译：从左到右找，相当于之前的线性表查找操作<br><strong>时间复杂度：</strong> O ( n )</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line"><span class="keyword">if</span> (ST.R[i].key == key) <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法每次都要比较 i 是否大于等于1，为了避免这个检测，可以设置一个哨兵</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ST.R[<span class="number">0</span>].key = key; <span class="comment">// 监视哨</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = ST.length; ST.R[i].key != key; -- i)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果表中没有所求值，到0的位置就会返回0，我们也就知道已经查找完毕且没找到了，不需要去一直比较 i 和0的大小来判断是否查找完毕</p><h3 id="（2）-折半查找-二分查找"><a href="#（2）-折半查找-二分查找" class="headerlink" title="（2） 折半查找 &#x2F; 二分查找"></a>（2） 折半查找 &#x2F; 二分查找</h3><p>&#x3D;&#x3D;考试重点！！！&#x3D;&#x3D;<br><strong>时间复杂度：</strong> O ( log<del>2</del> n)<br>假定序列有序，先从中间开始找，如果中间值等于给定值，查找成功并返回，否则：</p><ul><li>如果中间值小于给定值，说明给定值在中间值右边，所以在右半区域继续查找</li><li>如果中间值大于给定值，说明给定值在中间值左边，所以在左半区域继续查找<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// low到high就是目前所查找的区间</span></span><br><span class="line"><span class="type">int</span> low = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> high = ST.length;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = low + high &gt;&gt; <span class="number">1</span>; <span class="comment">// 中间值</span></span><br><span class="line"><span class="keyword">if</span> (key == ST.R[mid].key) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &lt; ST.R[mid].key) high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>平均查找长度的计算</strong></li><li><strong>判定树</strong><br>举个栗子~这个序列的查找过程就是这个样子（这个二叉树叫做<strong>判定树</strong>）6 比较一次<br>3 9 比较两次<br>1 4 7 10 比较三次<br>2 5 8 11 比较四次<br><strong>ASL &#x3D; （1 + 2 x 2 + 3 x 4 + 4 x 4)&#x2F; 11 &#x3D; 3</strong></li></ul><h3 id="（3）-分块查找"><a href="#（3）-分块查找" class="headerlink" title="（3） 分块查找"></a>（3） 分块查找</h3><p><strong>时间复杂度：</strong> O ( log(m) + n &#x2F; m )<br>又叫索引顺序查找<br>&#x3D;&#x3D;<strong>块间有序，块内无序</strong>&#x3D;&#x3D;<br>在索引表里折半查找，找到相应块后顺序查找</p><h2 id="3-树表的查找"><a href="#3-树表的查找" class="headerlink" title="3. 树表的查找"></a>3. 树表的查找</h2><h3 id="（1）-二叉排序树"><a href="#（1）-二叉排序树" class="headerlink" title="（1） 二叉排序树"></a>（1） 二叉排序树</h3><p>又叫二叉查找树</p><h4 id="A-定义"><a href="#A-定义" class="headerlink" title="A. 定义"></a>A. 定义</h4><p>二叉排序树是一颗空树，或者满足：左子树比根小，右子树比根大，且左右子树都是二叉排序树<br>&#x3D;&#x3D;<strong>中序遍历一棵二叉排序树可以得到递增的有序序列</strong>&#x3D;&#x3D;</p><h4 id="B-查找"><a href="#B-查找" class="headerlink" title="B. 查找"></a>B. 查找</h4><p><strong>时间复杂度：</strong> 在O(n)和O(log<del>2</del> n)之间，取决于树长什么样<br>如果是平衡二叉树就是O(log<del>2</del> n)</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>从根结点开始找</p><ul><li>所给值等于根结点，查找成功</li><li>所给值小于根结点，继续查找左子树</li><li>所给值大于根结点，继续查找右子树</li></ul><p>直到查找的子树为空，查找失败</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>（考试不考，先挖个坑~）</p><h4 id="C-插入"><a href="#C-插入" class="headerlink" title="C. 插入"></a>C. 插入</h4><p><strong>时间复杂度：</strong> O(log<del>2</del> n)</p><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ul><li>如果二叉树为空，就将给定值放在根结点</li><li>如果二叉树非空：<ul><li>给定值大于根结点，插入右子树</li><li>给定值小于根结点，插入左子树</li></ul></li></ul><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>（挖坑）</p><h4 id="D-创建"><a href="#D-创建" class="headerlink" title="D. 创建"></a>D. 创建</h4><p>就是不断插入结点，每次插入的结点都是叶子结点，不需要移动其他结点</p><h4 id="E-删除"><a href="#E-删除" class="headerlink" title="E. 删除"></a>E. 删除</h4><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>首先查找带删除的结点，如果找不到就当没说，找到了就开始删：</p><ul><li>如果该结点是叶子结点，直接删，即修改一下待删结点的双亲指针使它们指向NULL</li><li>如果该结点只有一个孩子，把孩子接到待删结点的双亲上，自己删去，也就是修改双亲指针使它们指向孩子</li><li>如果该结点有两个孩子，先中序遍历，然后把待删结点的直接前驱或者直接后继之间替代待删结点，然后再把原来直接前驱或者直接后继的结点删去<br><strong>举个栗子</strong>在这棵树里我们删除结点45<br>先看中序遍历：3 24 37 45 50 53 100<br>结点45的直接前驱和直接后继分别是37和50<br>我们选择50替代45 就变成这样<br>然后删去原来的结点50<br>变成这样这样也不会影响结点之间的相对顺序啦</li></ul><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><p>（挖坑）</p><h3 id="（2）-平衡二叉树"><a href="#（2）-平衡二叉树" class="headerlink" title="（2） 平衡二叉树"></a>（2） 平衡二叉树</h3><p>二叉树高度越小，查找起来越快，效率就越高<br>高度尽可能小的二叉树叫做<strong>平衡二叉树</strong>，也叫AVL树，它有以下特点：</p><ol><li>左子树右子树的深度之差绝对值不超过1</li><li>左子树和右子树也是平衡二叉树</li></ol><ul><li><strong>平衡因子：</strong> 左右子树深度之差<br>平衡二叉树的平衡因子一定只能是0、1、-1</li></ul><p><strong>平衡二叉树查找的时间复杂度：</strong> O (log<del>2</del> n)</p><h4 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h4><p><em>插入和生成都可以转化为平衡二叉树的调整问题来解决，这里就不多赘述了</em><br>平衡二叉树失去平衡后的调整可以分为以下四种情况：</p><h5 id="i-RR型"><a href="#i-RR型" class="headerlink" title="i. RR型"></a>i. RR型</h5><p>即破坏平衡结点在右子树的右边，进行右单旋</p><p>在这个例子中，找到距离13最近的被破坏的子树的根结点是5，13在5的右子树的右边<br>于是进行逆时针旋转，把被破坏结点的右子树变成当前二叉树的根，逆时针旋转，即将结点10变成根<br>此时会发现结点10的度为3（5,   8，14)，就将8按照二叉排序树的规则重新插入，放在结点5的右子树位置，调整后的平衡二叉树如图</p><h5 id="ii-LL型"><a href="#ii-LL型" class="headerlink" title="ii. LL型"></a>ii. LL型</h5><p>即破坏平衡结点在左子树的左边，进行左单旋</p><p>在这个例子中，结点2破坏了以结点5为根的二叉树的平衡<br>找到距离2最近的被破坏的子树的根结点是4，2在4的左子树的左边<br>于是进行顺时针旋转，把被破坏结点的左子树变成当前二叉树的根，顺时针旋转，即将结点3变成根<br>修改后结果如图</p><h5 id="iii-LR型"><a href="#iii-LR型" class="headerlink" title="iii. LR型"></a>iii. LR型</h5><p>即破坏平衡结点在左子树的右边，进行左右双旋</p><p>在这个例子中，结点6破坏了以结点7为根的二叉树的平衡<br>找到距离2最近的被破坏的子树的根结点是7，6在7的左子树的右边<br>于是以被破坏结点的左孩子右单旋，逆时针旋转，即变为</p><p>这个时候，破坏的结点变成了3,3破坏了以7为根的平衡二叉树，距离3最近的被破坏子树的根是7，3在7的左子树的左边，进行左单旋，调整后结果为</p><h5 id="iv-RL型"><a href="#iv-RL型" class="headerlink" title="iv. RL型"></a>iv. RL型</h5><p>即破坏平衡结点在右子树的左边，进行右左双旋</p><p>在这个例子中，结点5破坏了以结点3为根的二叉树的平衡<br>找到距离5最近的被破坏的子树的根结点是3，5在3的右子树的左边<br>于是以被破坏结点的右孩子左单旋，顺时针旋转，即变为</p><p>这个时候，破坏的结点变成了7,7破坏了以3为根的平衡二叉树，距离7最近的被破坏子树的根是3，7在3的右子树的右边，进行右单旋，调整后结果为</p><p>（码完才发现平衡二叉树居然不考！！可恶！！！！！)</p><h2 id="4-散列表的查找"><a href="#4-散列表的查找" class="headerlink" title="4. 散列表的查找"></a>4. 散列表的查找</h2><ul><li><strong>散列表</strong>又叫<strong>哈希表</strong>，通常是一个数组存储的信息，对于不同的关键字，散列地址可能相同，此时称作<strong>冲突</strong></li><li>散列表的<strong>装填因子 α</strong><ul><li>α &#x3D; 填入表中的记录数 &#x2F; 散列表的长度</li><li>装填因子反应散列表的装填程度</li></ul></li></ul><h3 id="（1）-构造方法"><a href="#（1）-构造方法" class="headerlink" title="（1） 构造方法"></a>（1） 构造方法</h3><h4 id="A-数字分析法"><a href="#A-数字分析法" class="headerlink" title="A. 数字分析法"></a>A. 数字分析法</h4><p>事先知道关键字集合，选取重复较小的若干位作为散列地址</p><h4 id="B-平方取中法"><a href="#B-平方取中法" class="headerlink" title="B. 平方取中法"></a>B. 平方取中法</h4><p>如果事先不知道关键字集合，可以将关键字转换成内部编码（按自己确定的规则）然后平方，选择其中的若干位作为散列地址</p><h4 id="C-折叠法"><a href="#C-折叠法" class="headerlink" title="C. 折叠法"></a>C. 折叠法</h4><p>如果散列地址位数较少，关键字位数较多，可以把关键字分割成位数相同的几部分，相加舍去进位，得到的值作为散列地址</p><h4 id="D-除留余数法"><a href="#D-除留余数法" class="headerlink" title="&#x3D;&#x3D;D. 除留余数法&#x3D;&#x3D;"></a>&#x3D;&#x3D;D. 除留余数法&#x3D;&#x3D;</h4><p>如果散列表表长为 m ，选择一个不大于 m 的 p ，用关键字除以 p ，得到的余数作为散列地址<br>根据经验得，p 选择小于 m 的最大质数，可以减少冲突情况</p><h3 id="（2）-处理冲突"><a href="#（2）-处理冲突" class="headerlink" title="（2） 处理冲突"></a>（2） 处理冲突</h3><h4 id="A-开放寻址法"><a href="#A-开放寻址法" class="headerlink" title="A. 开放寻址法"></a>A. 开放寻址法</h4><p>当某关键字的初始散列地址 H<del>0</del> 发生冲突，在 H<del>0</del> 的基础上计算得到新地址 H<del>1</del> ，如果还是冲突就在 H<del>1</del> 的基础上继续计算<br><strong>计算公式：H<del>i</del> &#x3D; (H(key) + d<del>i</del>) % m</strong><br>其中，H(key) 为散列函数，m 为散列表表长，根据d<del>i</del> 的不同，分为以下三种方式：</p><h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><p>d<del>i</del>  &#x3D; 1 …… m - 1<br>说人话就是当发生冲突时，从原散列地址的后一个地址开始找，遇到空的就存进去，满的就再找下一个，到最后一个都没找到空的就从头开始找</p><h5 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h5><p>d<del>i</del> &#x3D; 1^2^  -1^2^ 2^2^  -2^2^……</p><h5 id="伪随机探测法"><a href="#伪随机探测法" class="headerlink" title="伪随机探测法"></a>伪随机探测法</h5><p>d<del>i</del> &#x3D; 伪随机数序列</p><h5 id="优缺点比较"><a href="#优缺点比较" class="headerlink" title="优缺点比较"></a>优缺点比较</h5><p>可以发现，当第 i, i + 1, i + 2 位上都有值时，下一个散列地址是 i, i + 1, i + 2 的值都存入 i + 3，这种现象叫做<strong>二次聚集</strong></p><ul><li>线性探测法<ul><li>线性探测法可以保证所有关键字都存进散列表</li><li>线性探测法会产生二次聚集</li></ul></li><li>二次探测法 &#x2F; 伪随机探测法<ul><li>不保证所有关键字都能被存进散列表</li><li>不会产生二次聚集</li></ul></li></ul><h4 id="B-链地址法"><a href="#B-链地址法" class="headerlink" title="B. 链地址法"></a>B. 链地址法</h4><p>把具有相同散列地址的关键字放在一个单链表中</p><h1 id="二、排序"><a href="#二、排序" class="headerlink" title="二、排序"></a>二、排序</h1><h2 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p><strong>排序的稳定性</strong><br>假设有两个值 a b，a &#x3D; b，a 在序列中的位置是 i ，b 在序列中的位置是 j<br>排列前 i &lt; j，如果排序后 i 依然小于 j，说明该排序稳定，否则说明该排序不稳定</p><h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h2><p><strong>基本思想：</strong> 将每一个待排序的关键字按大小插入适当位置，直到所有关键字都被插入</p><h3 id="（1）-直接插入排序"><a href="#（1）-直接插入排序" class="headerlink" title="（1） 直接插入排序"></a>（1） 直接插入排序</h3><p>最简单的排序方法，思路就是从前往后，将每一个数插入前面已经排好序的序列的合适位置，到最后一个数插入完毕数列就变得有序</p><ul><li>&#x3D;&#x3D;<strong>时间复杂度：</strong> O (n^2^)&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>空间复杂度：</strong> O (1)&#x3D;&#x3D;</li><li><strong>直接插入排序是&#x3D;&#x3D;稳定的排序&#x3D;&#x3D;</strong></li></ul><p><strong>举个栗子</strong></p><blockquote><p>排序（13，6，3，31，9，27，5，11）</p></blockquote><p>直接插入排序过程：<br>【13】, 6, 3, 31, 9, 27, 5, 11<br>【6, 13】, 3, 31, 9, 27, 5, 11<br>【3, 6, 13】, 31, 9, 27, 5, 11<br>【3, 6, 13，31】, 9, 27, 5, 11<br>【3, 6, 9, 13，31】, 27, 5, 11<br>【3, 6, 9, 13，27, 31】, 5, 11<br>【3, 5, 6, 9, 13，27, 31】, 11<br>【3, 5, 6, 9, 11，13，27,  31】</p><h3 id="（2）-折半插入排序"><a href="#（2）-折半插入排序" class="headerlink" title="（2） 折半插入排序"></a>（2） 折半插入排序</h3><p>就是把直接插入排序的查找步骤换成折半查找</p><ul><li>&#x3D;&#x3D;<strong>时间复杂度：</strong> O (n^2^)&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>空间复杂度：</strong> O (1)&#x3D;&#x3D;</li><li><strong>折半插入排序是&#x3D;&#x3D;稳定的排序&#x3D;&#x3D;</strong></li></ul><h3 id="（3）-希尔排序"><a href="#（3）-希尔排序" class="headerlink" title="（3） 希尔排序"></a>（3） 希尔排序</h3><p>选取增量 d ，每相隔 d 的元素分为一组，分别排序这两个数<br>每次缩小增量 d ，直到 d 为1</p><ul><li>&#x3D;&#x3D;<strong>时间复杂度：</strong> O (nlog<del>2</del>n)&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>空间复杂度：</strong> O (1)&#x3D;&#x3D;</li><li><strong>希尔排序是&#x3D;&#x3D;不稳定的排序&#x3D;&#x3D;</strong></li></ul><p><strong>举个栗子</strong></p><blockquote><p>排列 T&#x3D;(49，38，65，97, 76, 13, 27, 49*，55,  04）</p></blockquote><p>起初选取 d &#x3D; 5，得到结果：</p><p>第二次选取 d &#x3D; 3，得到结果：</p><p>第三次选取 d &#x3D; 1，得到结果：</p><ul><li>d 较大时，组数少，排序快</li><li>d 较小时，由于原排列已经基本有序，排序还是很快</li></ul><h2 id="3-交换排序"><a href="#3-交换排序" class="headerlink" title="3. 交换排序"></a>3. 交换排序</h2><p>主要思路就是两两比较待排序列，一旦发现无序就交换</p><h3 id="（1）-冒泡排序"><a href="#（1）-冒泡排序" class="headerlink" title="（1） 冒泡排序"></a>（1） 冒泡排序</h3><p>最简单的交换排序，两两比较相邻数据，如果是逆序就交换<br>每轮都可以确定一个当前序列的最小值 &#x2F; 最大值</p><ul><li>&#x3D;&#x3D;<strong>时间复杂度：</strong> O (n^2^)&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>空间复杂度：</strong> O (1)&#x3D;&#x3D;</li><li><strong>冒泡排序是&#x3D;&#x3D;稳定的排序&#x3D;&#x3D;</strong></li></ul><p><strong>举个栗子</strong></p><blockquote><p>排序：21，25，49， 25*，16，  08</p></blockquote><p> 交换过程如图所示</p><p>每次都可以确定当前待排序列的最大值</p><h3 id="（2）-快速排序"><a href="#（2）-快速排序" class="headerlink" title="（2） 快速排序"></a>（2） 快速排序</h3><p>选择序列中任意一个元素，每次排序把序列中小于它的放到前面，大于它的放到后面，形成两段，再分别递归对前后两段进行排序，直到每一段仅剩一个元素<br>需要使用双指针</p><ul><li>&#x3D;&#x3D;<strong>时间复杂度：</strong> O (nlog<del>2</del>n)&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>空间复杂度：</strong> O (log<del>2</del>n)&#x3D;&#x3D;</li><li><strong>快速排序是&#x3D;&#x3D;不稳定的排序&#x3D;&#x3D;</strong></li></ul><p><strong>举个栗子</strong><br>排序</p><p>选择第一个元素49作为分界点，把49放到0的位置，两个指针一个指队头一个指队尾</p><p>判断队尾元素，49不小于49，因此尾指针向前挪一位</p><p>27小于49，把27放到low的位置</p><p>现在看头指针</p><p>38小于49，头指针往后一位</p><p>65大于49，把65挪到尾指针</p><p>尾指针往前挪一位</p><p>13小于49，把13挪到头指针</p><p>头指针往后挪一位</p><p>97大于49，把97交换到尾指针</p><p>尾指针往前挪一位</p><p>76大于49，尾指针再往前挪一位</p><p>头尾指针相遇，把49放进去</p><p>再对前半部分排序，把27确立为分界点</p><p>先看尾指针，13小于27，把13换到头指针，再看头指针，38大于27，把38换到尾指针，然后头尾指针相遇，把27放进去</p><p>再对后半部分排序，把76确立为分界点</p><p>先看尾指针，49小于76，把49换到头指针，再看头指针，97大于76，把97换到尾指针，再看尾指针，65小于76，把65换到头指针，然后头尾指针相遇，把76放进去</p><p>再对后半部分的前半部分排序，把49确定为分界点</p><p>先看尾指针，65大于49，尾指针往前挪一位，头尾指针相遇，把49放进去</p><p>排序完毕~</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L.r[<span class="number">0</span>] = L.r[low];</span><br><span class="line">pivotkey = L.r[row].key;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey) -- high;</span><br><span class="line">L.r[low] = L.r[high];</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey) ++ low;</span><br><span class="line">L.r[high] = L.r[low];</span><br><span class="line">&#125;</span><br><span class="line">L.r[low] = L.r[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">pivotloc = <span class="built_in">Partition</span>(L, low, high);</span><br><span class="line"><span class="built_in">QSort</span>(L, low, pivotloc - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">QSort</span>(L, pivotloc + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">QSort</span>(L, <span class="number">1</span>, L.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4. 选择排序"></a>4. 选择排序</h2><h3 id="（1）-简单选择排序（直接选择排序）"><a href="#（1）-简单选择排序（直接选择排序）" class="headerlink" title="（1） 简单选择排序（直接选择排序）"></a>（1） 简单选择排序（直接选择排序）</h3><p>每次找到最小值，调到待排序列的最前面</p><ul><li>&#x3D;&#x3D;<strong>时间复杂度：</strong> O (n^2^)&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>空间复杂度：</strong> O (1)&#x3D;&#x3D;</li><li><strong>简单选择排序是&#x3D;&#x3D;不稳定的排序&#x3D;&#x3D;</strong></li></ul><h3 id="（2）-树形选择排序（锦标赛排序）"><a href="#（2）-树形选择排序（锦标赛排序）" class="headerlink" title="（2） 树形选择排序（锦标赛排序）"></a>（2） 树形选择排序（锦标赛排序）</h3><p>利用上次的比较结果，依次输出最小值</p><ul><li>&#x3D;&#x3D;<strong>时间复杂度：</strong> O (nlog<del>2</del>n)&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>空间复杂度：</strong> O (n)&#x3D;&#x3D;</li><li><strong>树形选择排序是&#x3D;&#x3D;稳定的排序&#x3D;&#x3D;</strong></li></ul><h3 id="（3）-堆排序"><a href="#（3）-堆排序" class="headerlink" title="（3） 堆排序"></a>（3） 堆排序</h3><p>树形选择排序的一种</p><ul><li>大跟堆，双亲比孩子大</li><li>小跟堆，双亲比孩子小</li></ul><p>这样，根一定是最大值或者最小值</p><ul><li>&#x3D;&#x3D;<strong>时间复杂度：</strong> O (nlog<del>2</del>n)&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>空间复杂度：</strong> O (1)&#x3D;&#x3D;</li><li><strong>堆排序是&#x3D;&#x3D;不稳定的排序&#x3D;&#x3D;</strong></li></ul><h4 id="A-调整堆"><a href="#A-调整堆" class="headerlink" title="A. 调整堆"></a>A. 调整堆</h4><p>输出堆顶元素后，以堆中最后一个元素替代根结点，将根结点与左、右子树根结点比较，并与大者交换重复直至叶子结点，得到新的堆<br>直接看例子说明吧~</p><blockquote><p>把70取出后，重新调整堆</p></blockquote><p>先把最后一个元素10放到原来70的位置，在10 60 12中60最大，把10和60交换，在10 40 30中40最大，把10和40交换，得到</p><p>之后的步骤类似，就不说啦</p><h4 id="B-建初堆"><a href="#B-建初堆" class="headerlink" title="B. 建初堆"></a>B. 建初堆</h4><p>因为有n 个结点的完全二叉树，最后一个分支结点的标号是⌊n &#x2F; 2⌋，所以从⌊n &#x2F; 2⌋开始一直到1，依次进行调整堆就可以啦</p><h4 id="C-算法实现"><a href="#C-算法实现" class="headerlink" title="C. 算法实现"></a>C. 算法实现</h4><p>（不考，先挖个坑）</p><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><p>先在序列中两个两个排序，排完合成一组，然后每两组排一次合并成一组，以此类推，直到完全遍历完</p><ul><li>&#x3D;&#x3D;<strong>时间复杂度：</strong> O (nlog<del>2</del>n)&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>空间复杂度：</strong> O (n)&#x3D;&#x3D;</li><li><strong>归并排序是&#x3D;&#x3D;稳定的排序&#x3D;&#x3D;</strong></li></ul><p>看图自行理解~</p><h2 id="6-排序算法总结"><a href="#6-排序算法总结" class="headerlink" title="6. 排序算法总结"></a>6. 排序算法总结</h2><p>&#x3D;&#x3D;<strong>快选堆希不稳定</strong>&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构期末复习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 课内 </tag>
            
            <tag> 查找 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】图_复习笔记总结</title>
      <link href="/posts/af7de5b5.html"/>
      <url>/posts/af7de5b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、基本定义与性质"><a href="#一、基本定义与性质" class="headerlink" title="一、基本定义与性质"></a>一、基本定义与性质</h1><p>图由两个集合 V 和 E 组成，记为 G &#x3D; （V，E）， V 是顶点集，E 是边集</p><ul><li><strong>有向图：</strong> 顶点对 &lt;x, y&gt; 有序，意为一条由点 x 指向点 y 的有向边。&lt;x, y&gt; 和 &lt;y, x&gt;是不同的两条边<ul><li>在 &lt;x, y&gt; 中，x 是始点 &#x2F; 弧尾，y 是终点 &#x2F; 弧头</li></ul></li><li><strong>无向图：</strong> 顶点对(x, y) 无序，(x, y) 和 (y, x) 指的是同一条</li></ul><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><p>n 表示顶点数，e 表示边数</p><ul><li><strong>子图：</strong> 有一个图的顶点全部都是另一个图的顶点，边也全都是另一个图的边，这个图叫做另一个图的子图</li><li><strong>完全图</strong><ul><li><strong>无向完全图：</strong> 有 n(n - 1) &#x2F; 2 条边的无向图，说人话就是每两个顶点之间都有边</li><li><strong>有向完全图：</strong> 有 n(n - 1) 条边的有向图，说人话就是从任何一个顶点都能到任何一个其他顶点</li></ul></li><li><strong>稀疏图和稠密图：</strong> 边少的就是稀疏图，边多的就是稠密图</li><li><strong>网：</strong> 带权图</li><li><strong>邻接点：</strong> 无向图中，(v, v’) 表示 v 与 v’ 互为邻接点，v 和 v’ 相邻接，边 (v, v’) 依附于顶点 v 和 v’，边 (v, v’) 和顶点 v v’ 相关联</li><li><strong>度：</strong> 和顶点相关联的边的个数，记作TD(v)<ul><li><strong>入度：</strong> 有向图中从该点发出的边的个数，记作ID(v)</li><li><strong>出度：</strong> 有向图中从该点进入的边的个数，记作OD(v)</li><li><strong>TD(v) &#x3D; ID(v) + OD(v)</strong></li><li><strong>度是边数的两倍</strong></li></ul></li><li><strong>路径长度：</strong> 一条路径上边的个数</li><li><strong>回路 &#x2F; 环：</strong> 起点终点相同</li><li><strong>简单路径：</strong> 顶点不重复的路径</li><li><strong>简单回路 &#x2F; 简单环：</strong> 起点终点相同，其他不出现重复顶点的回路</li><li><strong>连通：</strong> v 可以到达 v’，则称这两点连通</li><li><strong>连通图：</strong> 图中任意两点连通</li><li><strong>连通分量：</strong> 无向图中极大连通子图</li><li><strong>强连通图：</strong> 有向图中，从任意一个点可以到任意另一个点</li><li><strong>强连通分量：</strong> 有向图中极大强连通子图</li><li><strong>连通图的生成树：</strong> 含有图中全部顶点，但是边数减1，任意添加一条边，必定构成环</li><li><strong>有向树：</strong> 一个顶点入度为0，其余顶点入度为1</li></ul><h1 id="二、图的存储"><a href="#二、图的存储" class="headerlink" title="二、图的存储"></a>二、图的存储</h1><h2 id="1-邻接矩阵"><a href="#1-邻接矩阵" class="headerlink" title="1. 邻接矩阵"></a>1. 邻接矩阵</h2><p>二维数组，G[i][j] 代表 i 和 j 点的边情况</p><ul><li>无向图中，G[i][j] &#x3D; 1说明有边，G[i][j] &#x3D; 0说明无边</li><li>有向图中，G[i][j] &#x3D; w说明有边，权值是w，G[i][j] &#x3D; ∞说明无边</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VerTexType vexs[MVNum]; <span class="comment">// 存顶点</span></span><br><span class="line">ArcType arcs[MVNum][MVNum]; <span class="comment">// 存边</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum; <span class="comment">// 存顶点数和边数</span></span><br><span class="line">&#125;AMGraph;</span><br></pre></td></tr></table></figure><h2 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="2. 邻接表"></a>2. 邻接表</h2><p>链式存储结构，分为表头结点表和边表</p><ul><li>表头结点表：包含数据和指针，数据表示存的是哪个顶点，指针指向这个顶点相邻的边表集</li><li>边表：包含数据，邻接点，指针，数据存储权值，邻接点存储是哪个点和本表的顶点相邻，指针指向下一个和顶点相邻的结点</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span> <span class="comment">// 边表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextarc;</span><br><span class="line">OtherInfo info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span> <span class="comment">// 表头结点表</span></span><br><span class="line">&#123;</span><br><span class="line">VerTexType data;</span><br><span class="line">ArcNode *firstarc;</span><br><span class="line">&#125;VNode, AdjList[MVNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vertices;</span><br><span class="line"><span class="type">int</span> vexnum, arcnum;</span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><h2 id="3-十字链表"><a href="#3-十字链表" class="headerlink" title="3. 十字链表"></a>3. 十字链表</h2><p>个人觉得可以理解为有向图的邻接矩阵按邻接表的方式存储<br>看图自己理解吧~感觉考到的概率不大</p><img src="/posts/af7de5b5/5.png" class><h2 id="4-邻接矩阵和邻接表存储的比较"><a href="#4-邻接矩阵和邻接表存储的比较" class="headerlink" title="4. 邻接矩阵和邻接表存储的比较"></a>4. 邻接矩阵和邻接表存储的比较</h2><h3 id="（1）-邻接矩阵"><a href="#（1）-邻接矩阵" class="headerlink" title="（1） 邻接矩阵"></a>（1） 邻接矩阵</h3><ul><li>优点：方便</li><li>缺点：图稍微大一点就存不下</li></ul><h3 id="（2）-邻接表"><a href="#（2）-邻接表" class="headerlink" title="（2） 邻接表"></a>（2） 邻接表</h3><ul><li>优点：可以存下大图</li><li>缺点：麻烦，相对来说没有邻接矩阵直观（其实是本菜狗太弱了）</li></ul><h1 id="三、图的遍历"><a href="#三、图的遍历" class="headerlink" title="三、图的遍历"></a>三、图的遍历</h1><h2 id="1-深度优先搜索-DFS"><a href="#1-深度优先搜索-DFS" class="headerlink" title="1. 深度优先搜索 DFS"></a>1. 深度优先搜索 DFS</h2><h3 id="（1）-思路"><a href="#（1）-思路" class="headerlink" title="（1） 思路"></a>（1） 思路</h3><p>不撞南墙不回头，只要有没有走过的点就接着走，一条路走到底，直到不能走了就退回来，找到下一条能走的路<br><strong>举个栗子</strong></p><img src="/posts/af7de5b5/4.png" class><p>深搜的结果是：v1 -&gt; v2 -&gt; v4 -&gt; v8 -&gt; v5 -&gt; v3 -&gt; v6 -&gt; v7</p><h3 id="（2）-算法实现"><a href="#（2）-算法实现" class="headerlink" title="（2） 算法实现"></a>（2） 算法实现</h3><h4 id="邻接矩阵存储图"><a href="#邻接矩阵存储图" class="headerlink" title="邻接矩阵存储图"></a>邻接矩阵存储图</h4><p><strong>时间复杂度：</strong> O(V^2^)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_AM</span><span class="params">(AMGraph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; v; <span class="comment">// 遍历过v点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>; <span class="comment">// 标记v已被遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; w &lt; G.vexnum; w ++ ) <span class="comment">// 遍历图中所有点</span></span><br><span class="line"><span class="keyword">if</span> ((G.arcs[v][w] != <span class="number">0</span>) &amp;&amp; (!visited[w])) <span class="built_in">DFS_AM</span>(G, w); <span class="comment">// 该点没有被遍历过 且 该点和v之间有边 就递归遍历该点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表存储图"><a href="#邻接表存储图" class="headerlink" title="邻接表存储图"></a>邻接表存储图</h4><p><strong>时间复杂度：</strong> O(V + E)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_AL</span><span class="params">(ALGraph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; v; <span class="comment">// 遍历过v点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>; <span class="comment">// 标记v已被遍历过</span></span><br><span class="line">p = G.vertices[v].firstarc; <span class="comment">// 和v第一个相邻的点记作p</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) <span class="comment">// 只要p存在就进入循环</span></span><br><span class="line">&#123;</span><br><span class="line">w = p-&gt;adjvex; <span class="comment">// w是p的值</span></span><br><span class="line"><span class="keyword">if</span> (!visited[w]) <span class="built_in">DFS_AL</span>(G, w); <span class="comment">// 只要w点没被遍历过 就递归遍历该点</span></span><br><span class="line">p = p-&gt;nextarc; <span class="comment">// p指向下一个边结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-广度优先搜索-BFS"><a href="#2-广度优先搜索-BFS" class="headerlink" title="2. 广度优先搜索 BFS"></a>2. 广度优先搜索 BFS</h2><h3 id="（1）-思路-1"><a href="#（1）-思路-1" class="headerlink" title="（1） 思路"></a>（1） 思路</h3><p>知道起点之后，第一次遍历起点，第二次遍历所有与起点距离为1的点，第三次遍历所有与起点距离为2的点，以此类推~<br><strong>举个栗子</strong></p><img src="/posts/af7de5b5/3.png" class><p>还是这个图<br>广搜的结果是：v1 -&gt; v2 -&gt; v3 -&gt; v4 -&gt; v5 -&gt; v6 -&gt; v7 -&gt; v8</p><h3 id="（2）-算法实现-1"><a href="#（2）-算法实现-1" class="headerlink" title="（2） 算法实现"></a>（2） 算法实现</h3><h4 id="邻接矩阵存储图-1"><a href="#邻接矩阵存储图-1" class="headerlink" title="邻接矩阵存储图"></a>邻接矩阵存储图</h4><p><strong>时间复杂度：</strong> O(V^2^)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS_AM</span><span class="params">(Graph_AM G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; v;</span><br><span class="line">visited[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> queue[MAXSIZE]; <span class="comment">// 创建队列 这里因为考试可能不能写c++ 就用数组模拟队列啦</span></span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>, rear = <span class="number">0</span>; <span class="comment">// 清空队列</span></span><br><span class="line">queue[rear ++ ] = v; <span class="comment">// 把点v存进队列</span></span><br><span class="line"><span class="keyword">while</span> (head != rear)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = queue[head ++ ]; <span class="comment">// 队头元素出队并保存</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;VexNum; i ++ ) <span class="comment">// 遍历所有点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((G.arcs[u][i] != <span class="number">0</span>) &amp;&amp; (!visited[i])) <span class="comment">// 该点没有被遍历过 且 该点和v之间有边 就遍历该点</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i;</span><br><span class="line">visited[i] = <span class="literal">true</span>;</span><br><span class="line">queue[rear ++ ] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表存储图-1"><a href="#邻接表存储图-1" class="headerlink" title="邻接表存储图"></a>邻接表存储图</h4><p><strong>时间复杂度：</strong> O(V + E)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS_AL</span><span class="params">(Graph_AL G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; v; <span class="comment">// 遍历过该点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>; <span class="comment">// 标记</span></span><br><span class="line">ArcNode queue[MAXSIZE]; <span class="comment">// 建立队列</span></span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>, rear = <span class="number">0</span>; <span class="comment">// 队列初始化</span></span><br><span class="line">queue[rear ++ ] = G.vertices[v].firstarc; <span class="comment">// 把目前遍历的这个点的第一个相邻点入队</span></span><br><span class="line"><span class="keyword">while</span> (head != rear) <span class="comment">// 队列不空就循环</span></span><br><span class="line">&#123;</span><br><span class="line">ArcNode u = queue[head ++ ]; <span class="comment">// 取出队头并删去</span></span><br><span class="line"><span class="keyword">while</span> (u)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[u-&gt;adjvex]) <span class="comment">// 只要没遍历过就立刻遍历</span></span><br><span class="line">             &#123;</span><br><span class="line">cout &lt;&lt; u-&gt;adjvex;</span><br><span class="line">visited[u-&gt;adjvex] = <span class="literal">true</span>;</span><br><span class="line">queue[rear ++ ] = G.vertices[u-&gt;adjvex].FirstEdge; <span class="comment">// 把与目前遍历的点相邻的第一个点存进去</span></span><br><span class="line">&#125;</span><br><span class="line">u = u-&gt;Next; <span class="comment">// 遍历下一个</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、图的应用"><a href="#四、图的应用" class="headerlink" title="四、图的应用"></a>四、图的应用</h1><h2 id="1-最小生成树"><a href="#1-最小生成树" class="headerlink" title="1. 最小生成树"></a>1. 最小生成树</h2><p>在一个连通网的所有生成树里权值之和最小的就是最小生成树。</p><h3 id="（1）-普里姆-（Prim）算法"><a href="#（1）-普里姆-（Prim）算法" class="headerlink" title="（1） 普里姆 （Prim）算法"></a>（1） 普里姆 （Prim）算法</h3><h4 id="A-思路"><a href="#A-思路" class="headerlink" title="A. 思路"></a>A. 思路</h4><p>从起点开始，每次循环中遍历所有点，选择<strong>还没有加入最小生成树</strong>且<strong>与生成树集合距离最短</strong>的点加入生成树，直到所有点都加入生成树中<img src="/posts/af7de5b5/2.png" class></p><h4 id="B-算法实现"><a href="#B-算法实现" class="headerlink" title="B. 算法实现"></a>B. 算法实现</h4><p><em>挖坑~</em></p><h3 id="（2）-克鲁斯卡尔（Kruskal）算法"><a href="#（2）-克鲁斯卡尔（Kruskal）算法" class="headerlink" title="（2） 克鲁斯卡尔（Kruskal）算法"></a>（2） 克鲁斯卡尔（Kruskal）算法</h3><h4 id="A-思路-1"><a href="#A-思路-1" class="headerlink" title="A. 思路"></a>A. 思路</h4><p>把所有边的权值按照从小到大排序，每次选择当前最小的，如果这条边连接的两个顶点有至少一个没有遍历过，就把这条边加入生成树，直到所有顶点都在生成树里</p><img src="/posts/af7de5b5/1.png" class><h4 id="B-算法实现-1"><a href="#B-算法实现-1" class="headerlink" title="B. 算法实现"></a>B. 算法实现</h4><p><em>继续挖坑~</em></p><h2 id="2-关键路径"><a href="#2-关键路径" class="headerlink" title="2. 关键路径"></a>2. 关键路径</h2><h3 id="（1）-AOE网"><a href="#（1）-AOE网" class="headerlink" title="（1） AOE网"></a>（1） AOE网</h3><p>AOE网——带权有向无环图</p><ul><li>边：活动</li><li>顶点：事件</li><li>权值：活动持续的时间</li></ul><p><strong>基本概念</strong></p><ul><li><strong>源点：</strong> 入度为0的点</li><li><strong>汇点：</strong> 出度为0的点</li><li><strong>带权路径长度：</strong> 一条路径上各边权值之和</li><li><strong>关键路径：</strong> 从源点到汇点带权路径长度最大的路径</li><li><strong>关键活动：</strong> 关键路径上的活动</li><li><strong>事件 v<del>i</del> 最早发生时间 ve(i)</strong><br>从源点到 v<del>i</del> 的最长路径长度<br>ve(0) &#x3D; 0<br>ve(i) &#x3D; max{ve(k) + w<del>k,i</del>}</li><li><strong>事件 v<del>i</del> 最迟发生时间 vl(i)</strong><br>不延误任何后继事件的最迟发生时间<br>vl(i) &#x3D; min{vl(k) - w<del>i,k</del>}</li><li><strong>活动 a<del>i</del> &#x3D; &lt;v<del>j</del>, v<del>k</del>&gt; 最早开始时间 e(i)</strong><br>等于事件 v<del>j</del> 的最早发生时间<br>e(i) &#x3D; ve(i)</li><li><strong>活动 a<del>i</del> &#x3D; &lt;v<del>j</del>, v<del>k</del>&gt; 最晚开始时间 l(i)</strong><br>等于事件 v<del>k</del> 的最迟发生时间减活动持续时间<br>l(i) &#x3D; vl(k) - w<del>i,k</del></li><li><strong>&#x3D;&#x3D;当一个活动的最早发生时间等于最晚发生时间，那么说明这个活动是关键活动&#x3D;&#x3D;</strong></li></ul><h3 id="（3）-关键路径"><a href="#（3）-关键路径" class="headerlink" title="（3） 关键路径"></a>（3） 关键路径</h3><h4 id="A-思路-2"><a href="#A-思路-2" class="headerlink" title="A. 思路"></a>A. 思路</h4><p>没有思路，找到最长的一条路径<del>，然后凭直觉做吧</del></p><h4 id="B-算法实现-2"><a href="#B-算法实现-2" class="headerlink" title="B. 算法实现"></a>B. 算法实现</h4><p><em>再挖一个</em></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构期末复习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图 </tag>
            
            <tag> 课内 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】树_复习笔记总结</title>
      <link href="/posts/72a6d47e.html"/>
      <url>/posts/72a6d47e.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、基本定义与性质"><a href="#一、基本定义与性质" class="headerlink" title="一、基本定义与性质"></a>一、基本定义与性质</h1><h2 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h2><ul><li><strong>结点的度：</strong> 结点拥有的子树个数</li><li><strong>树的度：</strong> 树内各结点度的最大值</li><li><strong>叶子 &#x2F; 终端结点：</strong> 度为0的结点</li><li><strong>双亲和孩子：</strong> 结点的子树称为该结点的孩子，该结点叫做孩子的双亲</li><li><strong>兄弟：</strong> 同一个双亲的孩子互称兄弟</li><li><strong>祖先：</strong> 从根到该结点路径上的所有结点</li><li><strong>子孙：</strong> 以某结点为根的子树中的任意结点</li><li><strong>堂兄弟：</strong> 双亲在同一层的结点</li><li><strong>层次：</strong> 根为第一层，孩子结点的层次等于双亲结点的层次加1</li><li><strong>树的深度：</strong> 树中结点的最大层次数</li><li><strong>森林：</strong> 互不相交的树的集合</li></ul><p><strong>二叉树的五种基本形态：</strong><img src="/posts/72a6d47e/15.png" class></p><ul><li><strong>满二叉树：</strong> 深度为k，有2^k^ -1个结点</li><li><strong>完全二叉树：</strong> 深度为k，有n个结点，每个结点编号都与深度为k的满二叉树中编号相同（说人话就是只有最后一层可能没放满，且从左到右不留空地放）</li><li><strong>需要注意的是：二叉树不是树的特殊形态！二叉树不属于树！</strong></li></ul><h2 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h2><ul><li><strong>性质1</strong>  在二叉树的第 i 层上至多有2 ^i-1^（i &gt;&#x3D; 1）个结点</li><li><strong>性质2</strong>  深度为 k 的二叉树至多有2 ^k^ - 1（k&gt;&#x3D;1）个结点</li><li><strong>性质3</strong> 对任何一颗二叉树T，如果其终端结点数为n<del>0</del> ，度为2的结点数为n<del>2</del> ，则n<del>0</del> &#x3D; n<del>2</del> + 1<ul><li>证明：设n<del>1</del> 为度为1的结点个数，结点总数n &#x3D; n<del>0</del> + n<del>1</del> + n<del>2</del><br>设B为分支总数<br>除了根结点之外，每个结点都有一条分支进入，所以 n &#x3D; B + 1<br>除了叶子结点的每个结点都会发出分支，所以 n &#x3D; 2n<del>2</del> + n<del>1</del><br>所以有 n &#x3D; n<del>1</del> + 2n<del>2</del> + 1<br>得 n<del>0</del> &#x3D; n<del>2</del> + 1</li></ul></li><li><strong>性质4</strong>  具有 n 个结点的完全二叉树深度为⌊log<del>2</del> n⌋ + 1</li><li><strong>性质5</strong>  如果对一棵有 n 个结点的完全二叉树按层序编号：<ul><li>如果 i &#x3D; 1，则结点 i 是二叉树的根</li><li>如果 2i &gt; n，则结点 i 无左孩子，否则左孩子是结点 2i</li><li>如果 2i + 1 &gt; n，则结点 i 无右孩子，否则右孩子是结点 2i + 1</li></ul></li></ul><h1 id="二、存储、操作与算法"><a href="#二、存储、操作与算法" class="headerlink" title="二、存储、操作与算法"></a>二、存储、操作与算法</h1><p>以下均以二叉树为例</p><h2 id="1-二叉树的存储结构"><a href="#1-二叉树的存储结构" class="headerlink" title="1. 二叉树的存储结构"></a>1. 二叉树的存储结构</h2><h3 id="（1）-顺序存储"><a href="#（1）-顺序存储" class="headerlink" title="（1） 顺序存储"></a>（1） 顺序存储</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> ElemType SqBiTree[MAXSIZE];</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure><p>这种存储结构仅适用于完全二叉树，因此我们大部分采用链式存储</p><h3 id="（2）-链式存储"><a href="#（2）-链式存储" class="headerlink" title="（2） 链式存储"></a>（2） 链式存储</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;</span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h2 id="2-遍历二叉树"><a href="#2-遍历二叉树" class="headerlink" title="2. 遍历二叉树"></a>2. 遍历二叉树</h2><p><em>由于考试范围里说不考非递归，复习时间紧，所以这个坑先放着啦，希望还记得来填上</em></p><h3 id="（1）-先序遍历-根左右"><a href="#（1）-先序遍历-根左右" class="headerlink" title="（1） 先序遍历 - 根左右"></a>（1） 先序遍历 - 根左右</h3><h4 id="A-递归算法"><a href="#A-递归算法" class="headerlink" title="A. 递归算法"></a>A. 递归算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T) <span class="comment">// 若二叉树非空</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; T-&gt;data;</span><br><span class="line"><span class="built_in">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line"><span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）-中序遍历-左根右"><a href="#（2）-中序遍历-左根右" class="headerlink" title="（2） 中序遍历 - 左根右"></a>（2） 中序遍历 - 左根右</h3><h4 id="A-递归算法-1"><a href="#A-递归算法-1" class="headerlink" title="A. 递归算法"></a>A. 递归算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T) <span class="comment">// 若二叉树非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">cout &lt;&lt; T-&gt;data;</span><br><span class="line"><span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）-后序遍历-左右根"><a href="#（3）-后序遍历-左右根" class="headerlink" title="（3） 后序遍历 - 左右根"></a>（3） 后序遍历 - 左右根</h3><h4 id="A-递归算法-2"><a href="#A-递归算法-2" class="headerlink" title="A. 递归算法"></a>A. 递归算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T) <span class="comment">// 若二叉树非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line"><span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">cout &lt;&lt; T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）-根据遍历序列确定二叉树"><a href="#（4）-根据遍历序列确定二叉树" class="headerlink" title="（4） 根据遍历序列确定二叉树"></a>（4） 根据遍历序列确定二叉树</h3><p>在二叉树的先序遍历、中序遍历、后序遍历中选两个确定二叉树，这两个中<strong>必须有一个是中序遍历</strong><br>思路很简单啦就是根据先序遍历or后序遍历找到根，再在中序遍历中找到根的位置，在根前面的就是左子树，在根后面的就是右子树，然后返回先序遍历or后序遍历继续找两个子树的根，这样递归下去就能确定整个二叉树啦<br><em>还是因为考试原因留个代码的坑啦~</em></p><h3 id="（5）-计算二叉树的深度"><a href="#（5）-计算二叉树的深度" class="headerlink" title="（5） 计算二叉树的深度"></a>（5） 计算二叉树的深度</h3><p><strong>思路：</strong> 分别递归计算一个结点左右子树的深度，这个结点的深度就是左右结点深度中较大的那个加1</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m = <span class="built_in">Depth</span>(T-&gt;lchild); <span class="comment">// 递归计算左子树深度</span></span><br><span class="line">n = <span class="built_in">Depth</span>(T-&gt;rchild); <span class="comment">// 递归计算右子树深度</span></span><br><span class="line"><span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> (m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">return</span> (n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（6）-计算二叉树结点的个数"><a href="#（6）-计算二叉树结点的个数" class="headerlink" title="（6） 计算二叉树结点的个数"></a>（6） 计算二叉树结点的个数</h3><p><strong>思路：</strong> 空树返回0，不是空树就返回左子树个数加右子树个数加1</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">NodeCount</span>(T-&gt;lchild) + <span class="built_in">NodeCount</span>(T-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-树和森林"><a href="#3-树和森林" class="headerlink" title="3. 树和森林"></a>3. 树和森林</h2><h3 id="（1）-树的存储结构"><a href="#（1）-树的存储结构" class="headerlink" title="（1） 树的存储结构"></a>（1） 树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>每个结点存自身数值和双亲，求双亲和根很容易，但是求孩子很难</p><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>孩子数目多时，像单链表那样把孩子存起来</p><h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p>每个结点存自身数值、第一个孩子结点和下一个兄弟结点<br>在树的存储中应用较为普遍</p><h3 id="（2）-树（森林）与二叉树的转换"><a href="#（2）-树（森林）与二叉树的转换" class="headerlink" title="（2） 树（森林）与二叉树的转换"></a>（2） 树（森林）与二叉树的转换</h3><h4 id="树转换成二叉树"><a href="#树转换成二叉树" class="headerlink" title="树转换成二叉树"></a>树转换成二叉树</h4><img src="/posts/72a6d47e/14.png" class><ol><li>在所有的兄弟结点之间加一条线 <img src="/posts/72a6d47e/13.png" class></li><li>树中的每个结点只保留与第一个孩子的连线，删去其他的<img src="/posts/72a6d47e/12.png" class></li><li>调整整个树的结构，让兄弟转换一下变成右孩子<img src="/posts/72a6d47e/11.png" class><br>bingo~完成！</li></ol><h4 id="二叉树转换成树"><a href="#二叉树转换成树" class="headerlink" title="二叉树转换成树"></a>二叉树转换成树</h4><ol><li><p>将二叉树左上到右下分层排列整齐</p> <img src="/posts/72a6d47e/10.png" class></li><li><p>找到每层结点的父结点，加线</p>  <img src="/posts/72a6d47e/9.png" class></li><li><p>删掉兄弟之间的连线</p> <img src="/posts/72a6d47e/8.png" class><p>  完成~</p></li></ol><h4 id="二叉树转换成森林"><a href="#二叉树转换成森林" class="headerlink" title="二叉树转换成森林"></a>二叉树转换成森林</h4><ol><li>从根节点开始，删去右孩子的连线</li><li>再看被删去的那一部分，继续删去右孩子的连线，直到全部删去为止</li><li>将得到的二叉树转换成树</li></ol><h2 id="4-哈夫曼树（Huffman）"><a href="#4-哈夫曼树（Huffman）" class="headerlink" title="4. 哈夫曼树（Huffman）"></a>4. 哈夫曼树（Huffman）</h2><p> 哈夫曼树又叫做<strong>最优树</strong>，是带权路径长度最短的树。</p><ul><li>路径：从一个结点到另一个结点的分支</li><li>路径长度：路径上的分支数目</li><li>树的路径长度：树根到每一结点的路径长度之和</li><li>结点的带权路径长度：结点到树根的路径长度与结点上权值的乘积</li><li>树的带权路径长度：树中所有叶子结点的带权路径长度之和，记作WPL</li><li>哈夫曼：带权路径长度最小的二叉树</li></ul><h3 id="（1）-构造过程"><a href="#（1）-构造过程" class="headerlink" title="（1） 构造过程"></a>（1） 构造过程</h3><ol><li>找到当前所有结点中最小的两个，将这两个结点作为兄弟，连在同一个双亲上，双亲的权值是两个结点权值之和</li><li>把这两个结点从点集中删去，把双亲结点加入点集</li><li>继续寻找目前点集中最小的两个，重复步骤12，直到点集中只剩下一个点</li></ol><p><strong>举个栗子</strong></p><blockquote><p>w &#x3D; (5, 29, 7, 8, 14, 23, 3, 11) 构造哈夫曼树并计算带权路径长度</p></blockquote><p>先在 w 里找到最小的两个点——3，5，然后构造：</p><img src="/posts/72a6d47e/7.png" class><p>现在点集变为 w &#x3D; (8, 29, 7, 8, 14, 23, 11)，找到最小的两个——7， 8，然后构造：</p><img src="/posts/72a6d47e/6.png" class><p>现在点集变为 w &#x3D; (15, 29, 8, 14, 23, 11)，找到最小的两个——8， 11，然后构造：</p><img src="/posts/72a6d47e/5.png" class><p>现在点集变为 w &#x3D; (15, 29, 17, 14, 23)，找到最小的两个——14， 15，然后构造：</p><img src="/posts/72a6d47e/4.png" class><p>现在点集变为 w &#x3D; (29, 29, 17,  23)，找到最小的两个——17， 23，然后构造：</p><img src="/posts/72a6d47e/3.png" class><p>现在点集变为 w &#x3D; (29, 29, 40)，找到最小的两个——29， 29，然后构造：</p><img src="/posts/72a6d47e/2.png" class><p>现在点集变为 w &#x3D; (58, 40)，找到最小的两个——40， 58，然后构造：</p><img src="/posts/72a6d47e/1.png" class><p>WPL &#x3D; 8 x 3 + 11 x 3 + 23 x 2 + 29 x 2 + 14 x 3 + 7 x 4 + 3 x 5 + 5 x 5 &#x3D; 271</p><h3 id="（2）-算法实现"><a href="#（2）-算法实现" class="headerlink" title="（2） 算法实现"></a>（2） 算法实现</h3><p><em>（挖坑~）</em></p><h2 id="5-哈夫曼编码"><a href="#5-哈夫曼编码" class="headerlink" title="5. 哈夫曼编码"></a>5. 哈夫曼编码</h2><p>列出给定字母，字母出现的次数为权值，构造哈夫曼树<br>然后从根结点开始走，左0右1，得到的字串即为哈夫曼编码</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构期末复习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 课内 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】栈和队列_复习笔记总结</title>
      <link href="/posts/1994ad8a.html"/>
      <url>/posts/1994ad8a.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h1><p>栈就是后进先出的线性表。</p><ul><li>表尾叫做&#x3D;&#x3D;栈顶&#x3D;&#x3D;，表头叫做&#x3D;&#x3D;栈底&#x3D;&#x3D;</li></ul><h2 id="1-顺序存储"><a href="#1-顺序存储" class="headerlink" title="1. 顺序存储"></a>1. 顺序存储</h2><h3 id="（1）-结构体定义"><a href="#（1）-结构体定义" class="headerlink" title="（1） 结构体定义"></a>（1） 结构体定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType *base; <span class="comment">// 栈底指针</span></span><br><span class="line">ElemType *top; <span class="comment">// 栈顶指针</span></span><br><span class="line"><span class="type">int</span> stacksize; <span class="comment">// 栈大小</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><ul><li>base始终指向栈底，若base &#x3D;&#x3D; NULL，则说明为空栈</li><li>top为栈顶指针，起初栈中没有元素时指向栈底，每添加一个元素，top也++，top始终指向最后一个元素的上一个位置</li></ul><h3 id="（2）-初始化空栈"><a href="#（2）-初始化空栈" class="headerlink" title="（2） 初始化空栈"></a>（2） 初始化空栈</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.base = <span class="keyword">new</span> ElemType[MAXSIZE]; <span class="comment">// 分配内存</span></span><br><span class="line"><span class="keyword">if</span> (!S.base) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">// 内存分配失败</span></span><br><span class="line">S.top = S.base; <span class="comment">// 栈中无元素，栈顶指针和栈底指针相等</span></span><br><span class="line">S.stacksize = MAXSIZE;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）-入栈"><a href="#（3）-入栈" class="headerlink" title="（3） 入栈"></a>（3） 入栈</h3><p><strong>思路：</strong> 就是先判断栈是否满，没满就在栈顶插入一个新元素，最后不要忘了把栈顶指针+1</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top - S.base == S.stacksize) <span class="keyword">return</span> ERROR; <span class="comment">// 栈满，插入失败</span></span><br><span class="line">*S.top ++ = e;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*S.top ++ = e; </span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*S.top = e; <span class="comment">// 栈顶元素赋为e</span></span><br><span class="line">*S.top ++; <span class="comment">//  栈顶指针+1</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="（4）-出栈"><a href="#（4）-出栈" class="headerlink" title="（4） 出栈"></a>（4） 出栈</h3><p><strong>思路：</strong> 看看栈是不是空的，不是空的就让栈顶指针–就好啦</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == S.base) <span class="keyword">return</span> ERROR; <span class="comment">// 栈空，没有能删的</span></span><br><span class="line">e = *-- S.top;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">e = *-- S.top; </span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*S.top --; <span class="comment">// 栈顶指针-1</span></span><br><span class="line">e = *S.top; <span class="comment">//  栈顶元素赋为e</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="（5）取栈顶元素"><a href="#（5）取栈顶元素" class="headerlink" title="（5）取栈顶元素"></a>（5）取栈顶元素</h3><p><strong>思路：</strong> 没有思路</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">GetTop</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top != S.base) <span class="keyword">return</span> *(S.top - <span class="number">1</span>); <span class="comment">// 栈顶指针不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-链式存储"><a href="#2-链式存储" class="headerlink" title="2. 链式存储"></a>2. 链式存储</h2><h3 id="（1）-结构体定义-1"><a href="#（1）-结构体定义-1" class="headerlink" title="（1） 结构体定义"></a>（1） 结构体定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackNode</span> *next;</span><br><span class="line">&#125;StackNode, *LinkStack;</span><br></pre></td></tr></table></figure><ul><li>不需要单独设置头结点，因为第一个元素不需要改变</li></ul><h3 id="（2）-初始化空栈-1"><a href="#（2）-初始化空栈-1" class="headerlink" title="（2） 初始化空栈"></a>（2） 初始化空栈</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）-入栈-1"><a href="#（3）-入栈-1" class="headerlink" title="（3） 入栈"></a>（3） 入栈</h3><p><strong>思路：</strong> 建立一个新的结点，接到链表的后面就好啦，记得修改栈顶指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="keyword">new</span> StackNode; <span class="comment">// 分配空间</span></span><br><span class="line">p-&gt;data = e; <span class="comment">// 赋值</span></span><br><span class="line">p-&gt;next = S; <span class="comment">// 新结点插入栈顶</span></span><br><span class="line">S = p; <span class="comment">// 修改栈顶指针</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）-出栈-1"><a href="#（4）-出栈-1" class="headerlink" title="（4） 出栈"></a>（4） 出栈</h3><p><strong>思路：</strong> 看看是不是空栈，不是空栈就修改栈顶指针，释放原来栈顶的空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR; <span class="comment">// 栈空</span></span><br><span class="line">e = S-&gt;data; <span class="comment">// 存要删去的值</span></span><br><span class="line">p = S; <span class="comment">// 记录要删去的结点</span></span><br><span class="line">S = S-&gt;next; <span class="comment">// 修改栈顶指针</span></span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// 释放空间</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）-取栈顶元素"><a href="#（5）-取栈顶元素" class="headerlink" title="（5） 取栈顶元素"></a>（5） 取栈顶元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S) <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h1><p>队列就是先进先出的线性表。</p><ul><li>插入的那一端叫做&#x3D;&#x3D;队尾&#x3D;&#x3D;，删除的那一端叫做&#x3D;&#x3D;队头&#x3D;&#x3D;</li></ul><h2 id="1-顺序存储-1"><a href="#1-顺序存储-1" class="headerlink" title="1. 顺序存储"></a>1. 顺序存储</h2><h3 id="（1）-结构体定义-2"><a href="#（1）-结构体定义-2" class="headerlink" title="（1） 结构体定义"></a>（1） 结构体定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType *base;</span><br><span class="line"><span class="type">int</span> front; <span class="comment">// 头指针：指向队头元素位置</span></span><br><span class="line"><span class="type">int</span> rear; <span class="comment">// 尾指针：指向队尾元素的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><ul><li>在使用时一般选择<strong>循环队列</strong>，每在队头删除一个元素，就让front &#x3D; （front + 1） % MAXSIZE ， 每在队尾插入一个元素，就让rear &#x3D; （rear + 1）% MAXSIZE，解决假溢出问题</li><li>为便于判断队空队满，一个循环队列只用MAXSIZE - 1个位置<ul><li>当front &#x3D;&#x3D; rear + 1时：队满</li><li>当front &#x3D;&#x3D; rear 时：队空</li></ul></li></ul><h3 id="（2）-初始化空队"><a href="#（2）-初始化空队" class="headerlink" title="（2） 初始化空队"></a>（2） 初始化空队</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q,base = <span class="keyword">new</span> ElemType[MAXSIZE]; <span class="comment">// 分配一整个数组的内存</span></span><br><span class="line"><span class="keyword">if</span> (!Q.base) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">// 分配内存失败</span></span><br><span class="line">Q.front = Q,rear = <span class="number">0</span>; <span class="comment">// 初始化头尾指针</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）-求队列长度"><a href="#（3）-求队列长度" class="headerlink" title="（3） 求队列长度"></a>（3） 求队列长度</h3><p><strong>思路：</strong> 头指针和尾指针的差值就是长度，差值可能为负数就加上MAXSIZE</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(Squeue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）-入队"><a href="#（4）-入队" class="headerlink" title="（4） 入队"></a>（4） 入队</h3><p><strong>思路：</strong> 看看是不是队满，没满就把新元素放到rear的位置，然后让rear ++</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MAXSIZE == Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">Q.base[Q.rear] = e; <span class="comment">// 赋值</span></span><br><span class="line">Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE; <span class="comment">// 更新尾指针</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）-出队"><a href="#（5）-出队" class="headerlink" title="（5） 出队"></a>（5） 出队</h3><p><strong>思路：</strong> 看看是不是队空，不空就记录一下马上删的元素也就是队头front的元素，然后让front++</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">e = Q.base[Q.front];</span><br><span class="line">Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（6）-取队头元素"><a href="#（6）-取队头元素" class="headerlink" title="（6） 取队头元素"></a>（6） 取队头元素</h3><p><strong>思路：</strong> 没有思路</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">GetHead</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front != Q.rear) <span class="comment">// 说明非空队</span></span><br><span class="line"><span class="keyword">return</span> Q.base[Q.front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-链式存储-1"><a href="#2-链式存储-1" class="headerlink" title="2. 链式存储"></a>2. 链式存储</h2><p>是长这个样子滴，front 和 rear 不存数值</p><img src="/posts/1994ad8a/1.png" class><h3 id="（1）-结构体定义-3"><a href="#（1）-结构体定义-3" class="headerlink" title="（1） 结构体定义"></a>（1） 结构体定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">QueuePtr front; <span class="comment">// 队头指针</span></span><br><span class="line">QueuePtr rear; <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h3 id="（2）-初始化空队-1"><a href="#（2）-初始化空队-1" class="headerlink" title="（2） 初始化空队"></a>（2） 初始化空队</h3><p><strong>思路：</strong> 构造一个单独的结点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.front = Q.rear = <span class="keyword">new</span> QNode;</span><br><span class="line">Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）-入队"><a href="#（3）-入队" class="headerlink" title="（3） 入队"></a>（3） 入队</h3><p><strong>思路：</strong> 分配一个结点空间接到队伍后面，不要忘记修改尾指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="keyword">new</span> QNode;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Q.rear-&gt;next = p; <span class="comment">// 修改尾指针</span></span><br><span class="line">Q.rear = p;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）-出队"><a href="#（4）-出队" class="headerlink" title="（4） 出队"></a>（4） 出队</h3><p><strong>思路：</strong> 先看看是不是空队，不是就记录下要删掉的结点，修改头指针，最后判断下删掉的是不是队列中最后一个元素，是的话也修改一下尾指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">p = Q.front-&gt;next; <span class="comment">// 记录队头</span></span><br><span class="line">e = p-&gt;data; <span class="comment">// 记录队头数据</span></span><br><span class="line">Q.front-&gt;next = p-&gt;next; <span class="comment">// 修改头指针</span></span><br><span class="line"><span class="keyword">if</span> (Q.rear == p) Q.rear = Q.front;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）取队头元素"><a href="#（5）取队头元素" class="headerlink" title="（5）取队头元素"></a>（5）取队头元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">GetHead</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front != Q.rear) <span class="comment">// 如果队列不空</span></span><br><span class="line"><span class="keyword">return</span> Q.front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构期末复习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 课内 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】线性表_复习笔记总结</title>
      <link href="/posts/5772d335.html"/>
      <url>/posts/5772d335.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、顺序存储"><a href="#一、顺序存储" class="headerlink" title="一、顺序存储"></a>一、顺序存储</h1><ul><li>简单理解就是<del>用结构体存着的数组</del></li></ul><h2 id="1-结构体定义"><a href="#1-结构体定义" class="headerlink" title="1. 结构体定义"></a>1. 结构体定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> * PtrToLNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElmenetType Data[ MAXSIZE ]; <span class="comment">// 存储数据信息</span></span><br><span class="line">    Position Last; <span class="comment">// 存储线性表最后一个元素的位置</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br></pre></td></tr></table></figure><h2 id="2-初始化空表"><a href="#2-初始化空表" class="headerlink" title="2. 初始化空表"></a>2. 初始化空表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List PtrL; <span class="comment">// 定义线性表的头结点</span></span><br><span class="line">    PtrL = (List )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode)); <span class="comment">// 为整个线性表分配空间</span></span><br><span class="line">    PtrL-&gt;Last = <span class="number">-1</span>; <span class="comment">// 此时线性表为空，最后一个元素指向-1</span></span><br><span class="line">    <span class="keyword">return</span> PtrL; <span class="comment">// 返回头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-查找元素"><a href="#3-查找元素" class="headerlink" title="3. 查找元素"></a>3. 查找元素</h2><blockquote><p>在线性表 PtrL 中查找给定元素 X</p></blockquote><p><strong>思路：</strong> 遍历整个线性表，找到就返回 X 所在位置 i ，找不到就返回 -1</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(ElementType X, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从第一个元素遍历到最后一个元素，若数值等于X就跳出</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i] != X ) i ++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; PtrL-&gt;Last ) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 线性表中没有X，返回-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-插入元素"><a href="#4-插入元素" class="headerlink" title="4. 插入元素"></a>4. 插入元素</h2><blockquote><p>将给定元素 X 插入到线性表 PtrL 的第 i 个位置</p></blockquote><p><strong>思路：</strong> 线性表&#x3D;&#x3D;从后往前&#x3D;&#x3D;，把第 i 个位置到最后一个位置（也就是 Last - 1 的位置）的数全往后挪一个，目的是把第 i 个位置腾出来放新插入的元素，最后记得让Last ++</p><ul><li>关于为什么从后往前呢？ 因为从后往前挪才能保证每个元素都没有丢失，从前往后挪，前一个元素会把后一个元素的值覆盖掉<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(ElementType X, <span class="type">int</span> i, List PtrL )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (PtrL-&gt;Last == MAXSIZE - <span class="number">1</span>) <span class="comment">// 此时表示线性表存满，不能插入元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;FULL.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last + <span class="number">2</span>) <span class="comment">// 此时给定的位置 i 不合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The location is not legal.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = PtrL-&gt;Last; j &gt;= i - <span class="number">1</span>; j -- ) <span class="comment">// 第i个元素其实是在数列中的第i-1啦</span></span><br><span class="line">        PtrL-&gt;Data[j + <span class="number">1</span>] = PtrL-&gt;Data[j];</span><br><span class="line">    PtrL-&gt;Data[i - <span class="number">1</span>] = X; <span class="comment">// 挪完之后赋值</span></span><br><span class="line">    PtrL-&gt;Last ++; <span class="comment">// 不要忘了把线性表最后一个元素的位置也往后挪一个</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-删除元素"><a href="#5-删除元素" class="headerlink" title="5. 删除元素"></a>5. 删除元素</h2><blockquote><p>删除线性表 PtrL 中第 i 个元素</p></blockquote><p><strong>思路：</strong> 线性表&#x3D;&#x3D;从前往后&#x3D;&#x3D;，把从第 i + 1 个元素开始到最后一个元素全部往前挪一位，覆盖掉第 i 个位置的元素，相当于删掉了第 i 个元素</p><ul><li>为什么不从后往前挪的原因和上面那条一样<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> i, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last + <span class="number">1</span>) <span class="comment">// 此时给定的位置 i 不合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The location is not legal.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &lt;= PtrL-&gt;Last; j ++ )</span><br><span class="line">        PtrL-&gt;Data[j - <span class="number">1</span>] = PtrL-&gt;Data[j];</span><br><span class="line">    PtrL-&gt;Last -- ; <span class="comment">// 挪完不要忘了把最后一个元素的位置也往前挪一个</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二、链式存储"><a href="#二、链式存储" class="headerlink" title="二、链式存储"></a>二、链式存储</h1><ul><li>简单理解就是把每个数据分别存在一个方块里，然后用线（也就是指针）把这些方块串起来</li></ul><h2 id="1-结构体定义-1"><a href="#1-结构体定义-1" class="headerlink" title="1. 结构体定义"></a>1. 结构体定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> *List;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    ElementType Data; <span class="comment">// 存这个方块里的数</span></span><br><span class="line">    List Next; <span class="comment">// 这个指针存的是下一个方块的位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-求表长"><a href="#2-求表长" class="headerlink" title="2. 求表长"></a>2. 求表长</h2><p><strong>思路：</strong> 就是很简单的遍历一遍…</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">(List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = PtrL; <span class="comment">// p在表头位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 表长初始化为0</span></span><br><span class="line">    <span class="keyword">while</span> (p) <span class="comment">// 只要p不为NULL就继续循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        j ++; <span class="comment">// 表长++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-查找元素-1"><a href="#3-查找元素-1" class="headerlink" title="3. 查找元素"></a>3. 查找元素</h2><p><strong>思路：</strong> 很显然就是遍历单链表</p><h3 id="（1）查找指定的数值-X"><a href="#（1）查找指定的数值-X" class="headerlink" title="（1）查找指定的数值 X"></a>（1）查找指定的数值 X</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">Find</span><span class="params">(ElementType X, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = PtrL; <span class="comment">// p指向表头</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;Data != X)</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 找到了就会返回X所在的指针，没找到正好会返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）查找指定的位置-K"><a href="#（2）查找指定的位置-K" class="headerlink" title="（2）查找指定的位置 K"></a>（2）查找指定的位置 K</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="type">int</span> K, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = PtrL; <span class="comment">// p指向表头</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// 表示目前正在遍历第 i 个位置</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; i &lt; K)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == K) <span class="keyword">return</span> p; <span class="comment">// 找到返回该位置的指针</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 找不到返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-插入元素-1"><a href="#4-插入元素-1" class="headerlink" title="4.  插入元素"></a>4.  插入元素</h2><blockquote><p>在线性表 PtrL 中插入元素 X 到第 i 个位置</p></blockquote><p><strong>思路：</strong> 先找到要插入位置的前一个位置（也就是第 i - 1 个位置），把这个新结点的 Next 指针指向前一个结点的 Next ，然后再将前一个结点的 Next 指向这个新结点，就完成啦~</p><img src="/posts/5772d335/2.png" class><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(ElementType X, <span class="type">int</span> i, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p, s;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="comment">// 如果要在第一个位置插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = PtrL; <span class="comment">// 让这个新结点指向头结点就好啦</span></span><br><span class="line">        <span class="keyword">return</span> s; <span class="comment">// 这个新结点变成新的头结点，返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="built_in">FindKth</span>(i - <span class="number">1</span>, PtrL); <span class="comment">// 如果不是第一个结点，先找到前一个结点，用p指向前一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="comment">// 前一个结点不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Illegal.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = p-&gt;Next;</span><br><span class="line">        p-&gt;Next = s;</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-删除元素-1"><a href="#5-删除元素-1" class="headerlink" title="5. 删除元素"></a>5. 删除元素</h2><blockquote><p>在线性表 PtrL 中插入第 i 个元素</p></blockquote><p><strong>思路：</strong> 找到被删除元素的前一个位置，让前一个位置的 Next 指向被删除元素的 Next ，释放掉被删除元素，完成~</p><img src="/posts/5772d335/1.png" class><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">(<span class="type">int</span> i, List PtrL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p, s;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="comment">// 删除的是第一个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = PtrL; <span class="comment">// s指向单链表第一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (PtrL != <span class="literal">NULL</span>) PtrL = PtrL-&gt;Next; <span class="comment">// 表不为空，就让PtrL指向下一个作为头结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 表为空，没法删去</span></span><br><span class="line">        <span class="built_in">free</span>(s); <span class="comment">// 释放s的内存</span></span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="built_in">FindKth</span>(i - <span class="number">1</span>, PtrL); <span class="comment">// 找到被删除元素的前一个位置，赋为p</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="comment">// 前一个位置不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Illegal.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;Next == <span class="literal">NULL</span>) <span class="comment">// 删除的位置不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Illegal.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = p-&gt;Next; <span class="comment">// s指向被删除元素</span></span><br><span class="line">        p-&gt;Next = s-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、-顺序存储和链式存储的比较"><a href="#三、-顺序存储和链式存储的比较" class="headerlink" title="三、 顺序存储和链式存储的比较"></a>三、 顺序存储和链式存储的比较</h1><ul><li><strong>顺序存储</strong><ul><li>&#x3D;&#x3D;需要完整连续的一片空间存储&#x3D;&#x3D;</li><li>可以在 O(1) 的时间复杂度内访问查找</li><li>插入删除效率低</li><li>大小固定，不能随意拓展</li></ul></li><li><strong>链式存储</strong><ul><li>内存利用率高，&#x3D;&#x3D;不需要连续的空间存储&#x3D;&#x3D;</li><li>查找访问效率低，需要从表头开始遍历</li><li>插入删除方便</li><li>大小不固定，可以随意拓展</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构期末复习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 课内 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】期末复习遗漏知识点记录</title>
      <link href="/posts/fe764c71.html"/>
      <url>/posts/fe764c71.html</url>
      
        <content type="html"><![CDATA[<p>一学期没怎么听数构的大学生记录一下期末复（yu）习过程中一些容易遗漏的知识点QAQ</p><h1 id="Part1-数据结构"><a href="#Part1-数据结构" class="headerlink" title="Part1 数据结构"></a>Part1 数据结构</h1><ol><li>常见的四类基本数据结构有：线性结构、树形结构、集合结构和图形结构。[ 逻辑结构 ]</li><li>物理存储结构有：顺序存储结构、链式存储结构。</li><li><strong>判断：</strong> 由于链式存储结构不要求逻辑上相邻的元素在物理位置上也相邻，因此，它具有随机存取的优点。<br><strong>答案：</strong> 错，不能随机存取！！</li><li><strong>判断：</strong> 数组是一种复杂的数据结构，数组元素之间的关系既不是线性的也不是树形的。<br><strong>答案：</strong> 错，线性是对的</li><li>通常从四个方面评价算法的质量：正确性、易读性、强壮性、高效率</li></ol><h1 id="Part2-线性表"><a href="#Part2-线性表" class="headerlink" title="Part2 线性表"></a>Part2 线性表</h1><ol><li>顺序表中在第 i 位前添加元素，i 可以是<strong>1—length + 1</strong> 的任何数。</li><li>双向循环链表 <img src="/posts/fe764c71/1.png" class> 指向前面一个结点的prior，指向后面一个结点的next，其他都与单链表类似。</li><li>设指针变量p指向单链表中结点A，若删除单链表中结点A，则需要修改指针的操作序列为（ <strong>A</strong> ）。<br> (A) q&#x3D;p-&gt;next；p-&gt;data&#x3D;q-&gt;data；p-&gt;next&#x3D;q-&gt;next；free(q)；<br> (B) q&#x3D;p-&gt;next；q-&gt;data&#x3D;p-&gt;data；p-&gt;next&#x3D;q-&gt;next；free(q)；<br> (C) q&#x3D;p-&gt;next；p-&gt;next&#x3D;q-&gt;next；free(q)；<br> (D) q&#x3D;p-&gt;next；p-&gt;data&#x3D;q-&gt;data；free(q)；</li><li>若某线性表最常用的操作是存取<strong>任一指定序号的元素</strong>和在最后进行插入和删除运算，则利用<strong>顺序表</strong>存储方式最节省时间。</li><li>线性表L在需不断对L进行删除插入的情况下适用于使用链式结构实现。</li></ol><h1 id="Part3-栈和队列"><a href="#Part3-栈和队列" class="headerlink" title="Part3 栈和队列"></a>Part3 栈和队列</h1><ol><li>在有表头指针的循环单链中，链表为空的条件为头结点的指针指向自身。</li><li>栈是限定仅在 &#x3D;&#x3D;<strong>表尾</strong>&#x3D;&#x3D; 进行插入或删除操作的线性表。</li><li>用链接方式存储的队列，在进行插入运算时<strong>头、尾指针可能都要修改</strong>。</li><li>利用大小为n的数组（下标从 0 到 n - 1）存储一个栈时，假定栈从数组另一头开始且 top &#x3D;&#x3D; n 表示栈空，则向这个栈插入一个元素时，修改top指针应当执行 top –。</li><li>设一个堆栈的入栈顺序是1、2、3、4、5。若第一个出栈的元素是4，则最后一个出栈的元素必定是<strong>1或者5</strong>。</li></ol><h1 id="Part4-树"><a href="#Part4-树" class="headerlink" title="Part4 树"></a>Part4 树</h1><ol><li>哈夫曼树是指带权路径长度WPL最小的二叉树。一般而言，在给定条件下构造出的哈夫曼树不是唯一的。</li><li>在二叉排序树中插入一个结点的时间复杂度为O(n)。</li><li>某二叉树的前序和中序遍历序列正好一样，则该二叉树中的任何结点一定都无左孩子。</li><li>若一个结点是某二叉树的中序遍历序列的最后一个结点，它不一定是该树的前序遍历序列中的最后一个结点。</li><li><strong>判断：</strong> 存在一棵总共有2016个结点的二叉树，其中有16个结点只有一个孩子。<br><strong>答案：</strong> 错误。<br>n<del>0</del> + n<del>1</del> + n<del>2</del> &#x3D; 2016<br>∵n₀ &#x3D; n₂ + 1<br>⇨n₂ + 1 + 16 + n₂ &#x3D; 2016<br>⇨2 n₂ &#x3D; 1999<br>n₂ 除不尽，所以答案错误。</li><li><strong>判断：</strong> 一棵树中，某结点位置上方各层中的所有结点都是该结点的祖先。<br><strong>答案：</strong> 错误。</li><li>任何一棵二叉树的叶结点在先序、中序和后序遍历序列中的相对次序不发生改变。</li><li>某二叉树的中序序列和后序序列正好相反，则该二叉树一定是<strong>任一结点无左孩子</strong>。</li><li>已知一棵完全二叉树的第6层（设根为第1层）有8个叶结点，则该完全二叉树的结点个数最多是111。</li><li>有一个四叉树，度2的结点数为3，度3的结点数为2，度4的结点数为4，该树的叶结点个数是20。</li><li>对于任意一棵高度为 5 且有 10 个结点的二叉树，若采用顺序存储结构保存，每个结点占 1 个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存储单元的数量至少是 31。</li><li>若根节点为高度1，一棵具有 1025 个结点的二叉树的高度为 <strong>11～1025</strong> 之间。</li></ol><h1 id="Part5-图"><a href="#Part5-图" class="headerlink" title="Part5 图"></a>Part5 图</h1><ol><li>具有n个顶点的无相连通图至少有 n - 1条边。</li><li>路径长度最长的路径为关键路径。（虽然看着很像错的但它是正确的！！！）</li><li>图的深度优先搜索类似于二叉树的<strong>先序遍历</strong>，图的广度优先搜索类似于二叉树的<strong>层序遍历</strong>。</li><li>AOV网是一种<strong>有向无回路</strong>的图。</li><li>设某有向图中有n个顶点，则该有向图对应的邻接表中有 n 个表头结点。</li><li>设某强连通图中有n个顶点，则该强连通图中至少有 <strong>n</strong> 条边。</li><li>Prim算法是维护一个森林，每一步把两棵树合并成一棵。</li><li>如果 e 是有权无向图 G 唯一的一条最短边，那么边 e 一定会在该图的最小生成树上。</li></ol><h1 id="Part6-查找排序"><a href="#Part6-查找排序" class="headerlink" title="Part6 查找排序"></a>Part6 查找排序</h1><ol><li>快速排序在<strong>被排序数据完全无序</strong>的情况下最易发挥其长处。</li><li>使用折半查找时，静态查找表必须不仅是<strong>有序表</strong>，并且<strong>连续存储</strong>。</li><li>在待排序的元素序列基本有序的前提下，效率最高的排序方法是<strong>插入排序</strong>。</li><li>每次直接或通过基准元素间接比较两个元素，若出现逆序排列时就交换它们的位置，此种排序方法叫做<strong>快速排序</strong>。</li><li>在堆排序的过程中，对任一分支结点进行筛运算的时间复杂度为O(logn)，整个堆排序过程的时间复杂度为O(nlogn)。</li><li>为了能有效地应用HASH查找技术，必须解决的两个问题是<strong>构造一个好的HASH函数</strong>和<strong>确定解决冲突的方法</strong>。</li><li>设有n个待排序的记录关键字，则在堆排序中需要 <strong>1</strong> 个辅助记录单元。</li><li>设二叉排序树中有n个结点，则在二叉排序树的平均平均查找长度为<strong>log<del>2</del>n</strong>。</li><li>所有的排序算法中，基数排序不需要进行关键字的比较操作。</li><li>堆是完全二叉树，完全二叉树不一定是堆。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构期末复习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 课内 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于数据类型</title>
      <link href="/posts/e719afa7.html"/>
      <url>/posts/e719afa7.html</url>
      
        <content type="html"><![CDATA[<p>随时更新 ~ 记录写题过程中遇到的问题，方便之后查询&amp;复习</p><hr><p><strong>答案爆long long时怎么办</strong></p><p>八成是你写错了（bs<br>如果只有正整数情况，可以考虑用<code>unsigned long long</code>，比<code>long long</code>多一倍范围</p><p><strong>关于强制类型转换</strong></p><p>int 转 long long 时<br>建议直接在要转换的式子之前乘<code>1LL</code><br>如果用<code>(LL)</code>放在整个式子之前转换的话，可能会在计算中途爆 int 导致 wa</p>]]></content>
      
      
      <categories>
          
          <category> 记录遇到的问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷】p1825 [USACO11OPEN] Corn Maze S</title>
      <link href="/posts/53013696.html"/>
      <url>/posts/53013696.html</url>
      
        <content type="html"><![CDATA[<p>从快吃中饭开始看题，一直到晚上七点半终于AC了！！！！！！！！！</p><p>写篇题解记录一下这个激动人心的时刻</p><h1 id="题目：-USACO11OPEN-Corn-Maze-S"><a href="#题目：-USACO11OPEN-Corn-Maze-S" class="headerlink" title="题目：[USACO11OPEN] Corn Maze S"></a>题目：[USACO11OPEN] Corn Maze S</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>奶牛们去一个 $N\times M$ 玉米迷宫，$2 \leq N \leq 300,2 \leq M \leq300$。</p><p>迷宫里有一些传送装置，可以将奶牛从一点到另一点进行瞬间转移。这些装置可以双向使用。</p><p>如果一头奶牛处在这个装置的起点或者终点，这头奶牛就<strong>必须</strong>使用这个装置。</p><p>玉米迷宫除了唯一的一个出口都被玉米包围。</p><p>迷宫中的每个元素都由以下项目中的一项组成：</p><ol><li>玉米，<code>#</code> 表示，这些格子是不可以通过的。</li><li>草地，<code>.</code> 表示，可以简单的通过。</li><li>传送装置，每一对大写字母 $\tt{A}$ 到 $\tt{Z}$ 表示。</li><li>出口，<code>=</code> 表示。</li><li>起点， <code>@</code> 表示</li></ol><p>奶牛能在一格草地上可能存在的四个相邻的格子移动，花费 $1$ 个单位时间。从装置的一个结点到另一个结点不花时间。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>This past fall, Farmer John took the cows to visit a corn maze. But this wasn’t just any corn maze: it featured several gravity-powered teleporter slides, which cause cows to teleport instantly from one point in the maze to another. The slides work in both directions: a cow can slide from the slide’s start to the end instantly, or from the end to the start. If a cow steps on a space that hosts either end of a slide, she must use the slide.</p><p>The outside of the corn maze is entirely corn except for a single exit.</p><p>The maze can be represented by an N x M (2 &lt;&#x3D; N &lt;&#x3D; 300; 2 &lt;&#x3D; M &lt;&#x3D; 300) grid. Each grid element contains one of these items:</p><p>* Corn (corn grid elements are impassable) </p><p>* Grass (easy to pass through!) </p><p>* A slide endpoint (which will transport a cow to the other endpoint) </p><p>* The exit</p><p>A cow can only move from one space to the next if they are adjacent and neither contains corn. Each grassy space has four potential neighbors to which a cow can travel. It takes 1 unit of time to move from a grassy space to an adjacent space; it takes 0 units of time to move from one slide endpoint to the other.</p><p>Corn-filled spaces are denoted with an octothorpe (#). Grassy spaces are denoted with a period (.). Pairs of slide endpoints are denoted with the same uppercase letter (A-Z), and no two different slides have endpoints denoted with the same letter. The exit is denoted with the equals sign (&#x3D;).</p><p>Bessie got lost. She knows where she is on the grid, and marked her current grassy space with the ‘at’ symbol (@). What is the minimum time she needs to move to the exit space?</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：两个用空格隔开的整数 $N$ 和 $M$。</p><p>第 $2\sim N+1$ 行：第 $i+1$ 行描述了迷宫中的第 $i$ 行的情况（共有$M$个字符，每个字符中间没有空格）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示起点到出口所需的最短时间。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">###=##</span><br><span class="line">#.W.##</span><br><span class="line">#.####</span><br><span class="line">#.@W##</span><br><span class="line">######</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>例如以下矩阵，$N&#x3D;5,M&#x3D;6$。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###=##</span><br><span class="line">#.W.##</span><br><span class="line">#.####</span><br><span class="line">#.@W##</span><br><span class="line">######</span><br></pre></td></tr></table></figure><p>唯一的一个装置的结点用大写字母 $\tt{W}$ 表示。</p><p>最优方案为：先向右走到装置的结点，花费一个单位时间，再到装置的另一个结点上，花费 $0$ 个单位时间，然后再向右走一个，再向上走一个，到达出口处，总共花费了 $3$ 个单位时间。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这一题！我！看到题目！想都没想！就是双端队列！</p><p>但是！不行！！（一会儿对这一点解释一下）</p><p>以下是这一题的正解思路：</p><ol><li>首先找到起点终点并记录下来</li><li>然后找到对应的传送门，可以用map&lt;PII, PII&gt;来存，要把对应的两个门都存起来，因为对应的两个传送门可以相互传送</li><li>最后最关键的就是开始BFS了：<br>先把起点存进队列，然后每次取出队头搜索<br>如果队头是终点，直接输出队头坐标的<code>dist</code>即可<br>如果不是，那就遍历上下左右四个操作，删去不能走的路和不合法的位置这两种情况后，还会出现以下两种情况：<br>a.是传送门<br>那么！请注意！不能直接更新当前这个门！！！<br>因为走到这个门时直接传到另一边门了，是没办法在这个门停住的！<br>所以，更新另一边对应门的<code>dist</code>和<code>st</code>！<br>有同学可能会问那么当前点的<code>dist</code>和<code>st</code>怎么办呢？<br>我们考虑什么时候会在当前点停住呢？对啦，传到另一个点之后随便走一步再回来，就会回到当前这个点啦（太！坑！了！），当前这个点会在那个时候更新的<br>b.是普通草地<br>直接更新当前点<code>dist</code>和<code>st</code>即可</li></ol><p>再说一下为什么不用双端队列呢？</p><img src="/posts/53013696/1.png" class><p>看上面这个图</p><p>其实从点到下面的传送门，可以直接理解为从点到上面的传送门，不经过下面的传送门<br>这样每走一步的权重还是1，走不走传送门根本没有权重上的差别，也就不需要用双端队列了</p><p>接下来看AC代码吧~（虽然写的是双端队列但是只是因为懒得改掉，没有用双端队列特有的函数）</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">27</span>, M = <span class="number">1010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> sx, sy, ex, ey;</span><br><span class="line"><span class="type">char</span> g[M][M];</span><br><span class="line"><span class="type">bool</span> st[M][M];</span><br><span class="line">map&lt;PII, PII&gt; door;</span><br><span class="line"><span class="type">int</span> dist[M][M];</span><br><span class="line"></span><br><span class="line"><span class="function">PII <span class="title">search_door</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == a &amp;&amp; !(i == x &amp;&amp; j == y)) <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;; <span class="comment">// 返回-1说明没搜到对应的门，这个门就看成草地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;sx, sy&#125;);</span><br><span class="line">    dist[sx][sy] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = t.ft, y = t.sd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 搜到终点</span></span><br><span class="line">        <span class="keyword">if</span> (x == ex &amp;&amp; y == ey) <span class="keyword">return</span> dist[x][y];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span> || a &gt;= n || b &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (door.<span class="built_in">count</span>(&#123;a, b&#125;)) <span class="comment">// 当前点是传送门</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> c = door[&#123;a, b&#125;].ft, d = door[&#123;a, b&#125;].sd; <span class="comment">// 对应门的坐标</span></span><br><span class="line">                <span class="keyword">if</span> (st[c][d]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                st[c][d] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push_back</span>(&#123;c, d&#125;);</span><br><span class="line">                dist[c][d] = dist[x][y] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                st[a][b] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">                dist[a][b] = dist[x][y] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            dist[i][j] = inf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起点终点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>) sx = i, sy = j; <span class="comment">// 起点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;=&#x27;</span>) ex = i, ey = j; <span class="comment">// 终点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传送门</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; g[i][j] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> (!door.<span class="built_in">count</span>(&#123;i, j&#125;)) <span class="comment">// 这一对门没被标记过</span></span><br><span class="line">                &#123;</span><br><span class="line">                    PII temp = <span class="built_in">search_door</span>(i, j, g[i][j]); <span class="comment">// 找另外一个门</span></span><br><span class="line">                    <span class="keyword">if</span> (temp != <span class="built_in">make_pair</span>(<span class="number">-1</span>, <span class="number">-1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 两个门都标记</span></span><br><span class="line">                        door[&#123;i, j&#125;] = temp;</span><br><span class="line">                        door[temp] = &#123;i, j&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(sx, sy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 洛谷 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZAFUACM - 23.8.5个人赛补题</title>
      <link href="/posts/f3c1cb9d.html"/>
      <url>/posts/f3c1cb9d.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-Lucky-Conversion"><a href="#A-Lucky-Conversion" class="headerlink" title="A - Lucky Conversion"></a>A - Lucky Conversion</h1><p><a href="https://codeforces.com/problemset/problem/145/A">原题链接</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出两个只包含“4”和“7”的字符串，每次操作可以任选其一：</p><ul><li>把“4”变成“7”或者把“7”变成“4”</li><li>交换两个数位置</li></ul><p>问从第一个字符串至少经过多少次操作能变成第二个字符串</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历字符串，存储：<br><code>cnt</code>：两个字符串有多少位上的数字不一样<br><code>a4</code>：a 字符串中有多少个4<br><code>b4</code>：b 字符串中有多少个4</p><p>然后看两个字符串4和7的个数是否一样：</p><ul><li>如果一样就只需要靠交换顺序来变换：最少的操作数就是<code>cnt / 2</code>，因为每交换一次可以改变两个位置</li><li>如果不一样要先把个数调整成一样：调整的原则是，改变那些对应位置上数字不一样的，也就需要调整<code>abs(a4 - b4)</code>次，如果此时还有对应位置上数字不一样的情况，就进行内部交换，再加上<code>(cnt - abs(a4 - b4)) / 2</code>次</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a4 = <span class="number">0</span>, b4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != b[i]) cnt ++ ;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">&#x27;4&#x27;</span>) a4 ++ ;</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="string">&#x27;4&#x27;</span>) b4 ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a4 == b4) cout &lt;&lt; cnt / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        ans += <span class="built_in">abs</span>(a4 - b4);</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="built_in">abs</span>(a4 - b4)) ans += (cnt - <span class="built_in">abs</span>(a4 - b4)) / <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Constanze’s-Machine"><a href="#B-Constanze’s-Machine" class="headerlink" title="B - Constanze’s Machine"></a>B - Constanze’s Machine</h1><p><a href="https://codeforces.com/problemset/problem/1245/C">原题链接</a></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>机器会让所有的“m”变成“nn”，所有的“w”变成“uu”<br>现在给出一个字符串，判断这个字符串本来有多少种可能的样子<br>如果这不可能是机器输出的字符串就输出0</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先判断字符串中有没有“w”或者“m”，有的话直接输出0，因为机器不可能输出这两个字母</p><p>然后找到并记录每个连续的“u”序列或者“n”序列，最后的方案数就是每一段序列的方案数的乘积</p><p>现在要解决的问题变成了每一段的方案数是多少，稍微枚举一下就能发现，这一段有几个连续的“w”或“n”，这一段的方案数就是斐波那契数列<code>f[i]</code>，于是问题就解决了~</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> i64 mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打表算出斐波那契数列</span></span><br><span class="line">    i64 f[N];</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>, f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= N; i ++ )</span><br><span class="line">        f[i] = (f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>]) % mod;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;w&#x27;</span> || s[i] == <span class="string">&#x27;m&#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>] &amp;&amp; (s[i] == <span class="string">&#x27;n&#x27;</span> || s[i] == <span class="string">&#x27;u&#x27;</span>)) flag ++ ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt.<span class="built_in">push_back</span>(f[flag]);</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt.<span class="built_in">push_back</span>(f[flag]);</span><br><span class="line">    i64 ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        ans = ans * (i64)cnt[i] % mod;</span><br><span class="line">    cout &lt;&lt; ans % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Maximum-Median"><a href="#C-Maximum-Median" class="headerlink" title="C - Maximum Median"></a>C - Maximum Median</h1><p><a href="https://codeforces.com/problemset/problem/1201/C">原题链接</a></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组和最大操作次数，每次操作可以任选一个元素加1，问经过操作后最大的中位数是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p><del>&#x3D;&#x3D;<strong>这！题！卡！int！</strong>&#x3D;&#x3D;</del></p><p>我的思路就是首先对数组排序，之后就只用从中位数遍历后面的元素即可</p><p>观察数组发现，从中位数开始，如果当前遍历的数和比后面的数小，就可以只将当前的数加1（也能保证当前的数还是中位数），当前的数如果和后面的数一样大，就需要将后面一样大的数也一起加1（才能保证中位数也加了1）</p><p>定义的三个变量含义如下：<br><code>cnt</code>：目前一次需要对几个数操作（才能让中位数加1）<br><code>ans</code>：目前一共操作了多少次<br><code>idx</code>：中位数在原基础上加了多少</p><p>遍历每个数时，中位数可以在原基础上加<code>a[i] - a[i - 1]</code>次，操作次数就需要加<code>cnt * (a[i] - a[i - 1])</code>次（因为每次可能要不止操作一个数），当<code>ans</code>大于最大操作次数时，跳出循环即可</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    i64 cnt = <span class="number">0</span>; <span class="comment">// 现在一次动几个</span></span><br><span class="line">    i64 ans = <span class="number">0</span>; <span class="comment">// 目前操作多少次</span></span><br><span class="line">    i64 idx = <span class="number">0</span>; <span class="comment">// 中位数加了多少次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() / <span class="number">2</span> + <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cnt ++ ;</span><br><span class="line">        idx += a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">        ans += cnt * (a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans -= cnt * (a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">            idx -= a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">            cnt -- ;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt ++ ;</span><br><span class="line">    cout &lt;&lt; a[a.<span class="built_in">size</span>() / <span class="number">2</span>] + idx + (k - ans) / cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Remove-Extra-One"><a href="#D-Remove-Extra-One" class="headerlink" title="D - Remove Extra One"></a>D - Remove Extra One</h1><p><a href="https://codeforces.com/problemset/problem/900/C">原题链接</a></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组，如果某个元素之前的任何一个元素都比这个元素大，那就叫这个元素 record，现在要删去一个元素，让这个数组的 record 最多，问删去哪个元素</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>赛时：八成是逆序对…看某一个元素和其他元素之间能够成多少逆序对…然后这样那样就能做了…&#x2F;兴奋.jpg<br>赛后：</p><img src="/posts/f3c1cb9d/1.png" class><p><del>？？？被世界欺骗</del></p><p>本题属于思维题和逆序对毛线关系没有，遍历一遍数组就能得到答案</p><p>遍历数组时，记录下数组从开头到目前遍历位置的<strong>最大值</strong>和<strong>次大值</strong>，再定义一个数组 $x[i]$，存储删去元素 $i$ 后，整个数组 record 数量的变化</p><p>每遍历一个元素——</p><ul><li>如果这个元素比记录下来的最大值还要大，说明这个元素就是 record，删去这个元素的话，整个数组的 record 数量会减 1，因此需要进行的操作是：<code>x[i] --</code>以及更新目前的最大值与次大值</li><li>如果这个元素处于记录下来的最大值与次大值之间，说明这个元素是目前的次大值，只要删去目前的最大值，当前遍历的这个元素就会变成 record（也就会让整个数组的 record 数量加 1 ），因此需要进行的操作是：<code>x[max] ++</code>，以及更新目前的次大值‘’</li><li>如果这个元素小于目前记录的次大值，无论删去哪一个元素都不会对数组的 record 数量有影响，就不用管它</li></ul><p>最后，在$x[N]$里找到最大的删去即可</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">x</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m1st = <span class="number">0</span>, m2nd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; m1st)</span><br><span class="line">        &#123;</span><br><span class="line">            x[a[i]] -- ;</span><br><span class="line">            m2nd = m1st;</span><br><span class="line">            m1st = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; m2nd)</span><br><span class="line">        &#123;</span><br><span class="line">            x[m1st] ++ ;</span><br><span class="line">            m2nd = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">-0x3f3f3f3f</span>, ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x[i] &gt; cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt = x[i];</span><br><span class="line">            ans = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-A-Determined-Cleanup"><a href="#E-A-Determined-Cleanup" class="headerlink" title="E - A Determined Cleanup"></a>E - A Determined Cleanup</h1><p><a href="https://codeforces.com/problemset/problem/933/B">原题链接</a></p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>已知$f(x)&#x3D;q(x)(x+k)+p$，求出合适的$q(x)$使得多项式$f(x)$中的每一项系数都大于等于0且小于给定的k，输出$f(x)$系数</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>设 $f(x)$ 每一项为 $a_ix^i$，$q(x)$ 每一项为 $b_ix^i$，那么可以得到以下规律：<br>$a_0&#x3D;b_0k+p$<br>$a_1&#x3D;b_1k+b_0$<br>$a_2&#x3D;b_2k+b_1$<br>……<br>$a_n&#x3D;b_nk+b_{n-1}$</p><p>因为多项式的最高次数为 n，所以 $b_n$ 必须为0，否组会让多项式的最高次数变成 n+1,<br>那么 $a_n&#x3D;b_{n-1}$，所有的答案都在整数范围内取</p><p>现在关注第一个式子 $a_0&#x3D;b_0k+p$，$a_0$又要小于$k$，所以可以直接得到 $a_0&#x3D;p%k$，又因为 $a_0&gt;&#x3D;0$，所以如果 $p%k$ 是负数的话，直接在它的基础上加 k 即可</p><p>同时，因为 $0&lt;&#x3D;a_0&lt;k$，把 $a_0$ 代入，得到 $0&lt;&#x3D;b_0k+p&lt;k$，化简可得 $b_0&#x3D;-\frac{p}{k}$，当然如果之前的 $p%k$ 是负数的话，也要将这里的 p 加1（正负平衡）</p><p>按照这个思路一直往下做，直到找到一个 $b_i&#x3D;0$ 为止（在上面说了 $b_n&#x3D;0$， 所以找到一个等于0的 b 就可以默认找到答案了）</p><p>最后注意开 long long</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i64 p, k;</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    vector&lt;i64&gt; ans;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(p % k);</span><br><span class="line">        p = -p / k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ans[cnt] &lt; <span class="number">0</span>) ans[cnt] += k, p ++ ;</span><br><span class="line">        cnt ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-Minimal-k-covering"><a href="#F-Minimal-k-covering" class="headerlink" title="F - Minimal k-covering"></a>F - Minimal k-covering</h1><p><a href="https://codeforces.com/problemset/problem/976/F">原题链接</a></p><p>（网络流好难 勉强理解个大概但是搞不出这题……开摆！！！</p>]]></content>
      
      
      <categories>
          
          <category> 杂题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZAFU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZAFUACM - 7.11个人赛补题 A - F &amp; H</title>
      <link href="/posts/508731ad.html"/>
      <url>/posts/508731ad.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-111-CodeForces-659A"><a href="#A-111-CodeForces-659A" class="headerlink" title="A - 111 - CodeForces - 659A"></a>A - 111 - CodeForces - 659A</h1><p><a href="https://codeforces.com/problemset/problem/659/A">题目链接</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个人绕着圆柱体建筑走路，每个点按序标号，给出正数就往标号大的方向走，负数就往标号小的方向走，问最后停在哪</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题挂了一遍就是对我抢时间连题目都没好好看的惩罚QAQ<br>很简单，注意负数情况不要搞错就行</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) a += <span class="number">100</span> * n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">abs</span>((a + b) % n);</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>) ans = n;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-扣1-CodeForces-740B"><a href="#B-扣1-CodeForces-740B" class="headerlink" title="B - 扣1 - CodeForces - 740B"></a>B - 扣1 - CodeForces - 740B</h1><p><a href="https://codeforces.com/problemset/problem/740/B">题目链接</a></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>从序列中取出若干子序列，再从子序列中选择若干个，要求让原序列中的每个数乘他们选择的子序列里出现的次数之和最大</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>也很简单，一眼看出是前缀和加差分，然后按这个思路做就没问题</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    s[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (s[r] - s[l - <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        d[l] ++ ;</span><br><span class="line">        d[r + <span class="number">1</span>] -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) d[i] += d[i - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) ans += a[i] * d[i];</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-拱坝-CodeForces-707B"><a href="#C-拱坝-CodeForces-707B" class="headerlink" title="C - 拱坝 - CodeForces - 707B"></a>C - 拱坝 - CodeForces - 707B</h1><p><a href="https://codeforces.com/problemset/problem/707/B">题目链接</a></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一个无向带权图，标出若干个特殊点，求特殊点之外离任意一个特殊点最近的点到该特殊点的距离</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p> 有点类似Kruskal的简化版？把特殊点放在一个点集，其余点各成点集，按边权从小到大排序，找到第一个连接一个特殊点和一个普通点的边输出权值即可</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; edges[i].a &gt;&gt; edges[i].b &gt;&gt; edges[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u;</span><br><span class="line">        cin &gt;&gt; u;</span><br><span class="line">        p[u] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">        <span class="keyword">if</span> ((p[a] == <span class="number">0</span> &amp;&amp; p[b] != <span class="number">0</span>) || (p[b] == <span class="number">0</span> &amp;&amp; p[a] != <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; w;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-河坝-CodeForces699C"><a href="#D-河坝-CodeForces699C" class="headerlink" title="D - 河坝 - CodeForces699C"></a>D - 河坝 - CodeForces699C</h1><p><a href="https://codeforces.com/problemset/problem/699/C">题目链接</a></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>每天记为0 &#x2F; 1 &#x2F; 2 &#x2F; 3, 0 表示休息，1 表示可以打比赛，2 表示可以锻炼，3 表示既可以打比赛也可以锻炼，不能连续两天打比赛 or 连续两天锻炼，有一个人不想休息，问休息天数最小是多少</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这题赛时给我整崩溃了，思路错了整场都没反应过来， 比赛时光想着贪心了，实际用二维dp啊啊<br><code>q[i][j]</code>表示第 i 天干第 j 件事的情况下，前 i 天不休息的天数最大值<br>然后就看代码吧~</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q[i][<span class="number">0</span>] = <span class="built_in">max</span>(&#123;q[i - <span class="number">1</span>][<span class="number">1</span>], q[i - <span class="number">1</span>][<span class="number">2</span>], q[i - <span class="number">1</span>][<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q[i][<span class="number">1</span>] = <span class="built_in">max</span>(q[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>, q[i - <span class="number">1</span>][<span class="number">2</span>] + <span class="number">1</span>);</span><br><span class="line">            q[i][<span class="number">0</span>] = <span class="built_in">max</span>(&#123;q[i - <span class="number">1</span>][<span class="number">0</span>], q[i - <span class="number">1</span>][<span class="number">1</span>], q[i - <span class="number">1</span>][<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q[i][<span class="number">2</span>] = <span class="built_in">max</span>(q[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>, q[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            q[i][<span class="number">0</span>] = <span class="built_in">max</span>(&#123;q[i - <span class="number">1</span>][<span class="number">0</span>], q[i - <span class="number">1</span>][<span class="number">1</span>], q[i - <span class="number">1</span>][<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q[i][<span class="number">1</span>] = <span class="built_in">max</span>(q[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>, q[i - <span class="number">1</span>][<span class="number">2</span>] + <span class="number">1</span>);</span><br><span class="line">            q[i][<span class="number">2</span>] = <span class="built_in">max</span>(q[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>, q[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            q[i][<span class="number">0</span>] = <span class="built_in">max</span>(&#123;q[i - <span class="number">1</span>][<span class="number">0</span>], q[i - <span class="number">1</span>][<span class="number">1</span>], q[i - <span class="number">1</span>][<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">max</span>(&#123;q[n][<span class="number">0</span>], q[n][<span class="number">1</span>], q[n][<span class="number">2</span>]&#125;);</span><br><span class="line">    cout &lt;&lt; n - ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-和蔼-CodeForces-659E"><a href="#E-和蔼-CodeForces-659E" class="headerlink" title="E - 和蔼! - CodeForces - 659E"></a>E - 和蔼! - CodeForces - 659E</h1><p><a href="https://codeforces.com/problemset/problem/659/E">题目链接</a></p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>把给定无向图的每条边换成有向边，问最少有多少个点没有入边</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>问入边就直接想到顶点的度了<br>先把无向图每个顶点的度存下来，先找到度为 1 的点存进队列，让这个点连接的这条边直接指向这个点，将被指向的点度赋为无穷大，另一个点度数减去 1，最后再更新度为 1 的点存进队列，队列为空时判断有多少点度为 0，这个数量就是答案（因为度为 1 ，主动被指向的点都被赋为无穷大了，度为 0 的只能是没有被指向的） </p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        d[a] ++ ;</span><br><span class="line">        d[b] ++ ;</span><br><span class="line">        g[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        g[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">if</span> (d[i] == <span class="number">1</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (d[t] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[t].<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[t][i] != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> p = g[t][i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[p].<span class="built_in">size</span>(); i ++ )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (g[p][i] == t)</span><br><span class="line">                        &#123;</span><br><span class="line">                            g[p][i] = <span class="number">0</span>;</span><br><span class="line">                            d[t] = inf;</span><br><span class="line">                            d[p] -- ;</span><br><span class="line">                            <span class="keyword">if</span> (d[p] == <span class="number">1</span>) q.<span class="built_in">push</span>(p);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] == <span class="number">0</span>) ans ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-抽象-CodeForces-740C"><a href="#F-抽象-CodeForces-740C" class="headerlink" title="F - 抽象 - CodeForces - 740C"></a>F - 抽象 - CodeForces - 740C</h1><p><a href="https://codeforces.com/problemset/problem/740/C">题目链接</a></p><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给定长度序列中取出任意子序列，要求所有子序列中未出现的最小非负整数值最大，输出最大值并构造序列</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>赛时被 D 题整到崩溃甚至都没花太多时间想这题，最后想到个有点小麻烦的思路，但是时间不够了没能敲完，回去洗衣服洗到一半脑子一嗡忽然知道这题怎么做了，太弱智了！！！</p><p>首先输出的最大值一定是给出的所有序列中最短的那个序列的长度 + 1</p><p>为什么呢？因为想让未出现的最小非负整数最大，那肯定是从小到大填充序列，但是比如说最短的那个子序列长度是 2 ，那么两个位置分别填上 0 1，未出现的值一定是 2，最大值也只能是 2，因为已经没有比这么填更好的方式了</p><p>然后！重点是怎么构造序列！！！</p><p>我一开始想得太复杂了，哪个序列怎么填充给自己绕的晕头转向，但是后来突然想到，从前到后直接按顺序填 0 - 最大的非负整数 不就可以了吗TAT，这样不管怎么取子序列都是满足条件的啊…</p><p>然后就AC啦~</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, l, r;</span><br><span class="line"><span class="type">int</span> d[N], a[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        d[i].first = lr[i].second - lr[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(d, d + m);</span><br><span class="line">    ans = d[<span class="number">0</span>];</span><br><span class="line">    cout &lt;&lt; ans + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; k &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        k ++ ;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; ans) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="H-冰！-CodeForces-740D"><a href="#H-冰！-CodeForces-740D" class="headerlink" title="H - 冰！- CodeForces - 740D"></a>H - 冰！- CodeForces - 740D</h1><p><a href="https://codeforces.com/problemset/problem/740/D">题目链接</a></p><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给出一棵树和点权边权，一个点能控制另一个点的条件是：</p><ul><li>被控制点在控制点的子树上</li><li>控制点到被控制点的边权之和小于等于被控制点的点权</li></ul><p>问每个点能控制的点个数</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>一开始的思路是，建立带权有向图</p><p>满足第一个条件，可以用 dfs 遍历，如果从一个点能遍历到另一个说明另一个点在该点的子树上</p><p>满足第二个条件，主要问题是计算控制点到被控制点的边权，考虑到如果一个一个加肯定会爆，所以先计算出所有点到根结点 1 的路径边权（用 Dijkstra 的堆优化做），再用被控制点到根结点的边权减去控制点到根结点的边权就得到两点的路径边权</p><p>（说了这么多还是TLE了…</p><p>查了一下题解，<strong>倍增 + 树上差分 + dfs</strong><br>对代码加了点注释，还没能完全搞清楚</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line">LL a; <span class="comment">// 顶点个数</span></span><br><span class="line">LL s1[N]; <span class="comment">// 顶点权重</span></span><br><span class="line">LL head[N]; <span class="comment">// 存储i点的第一个子结点（和fa[i][0]互为逆运算）</span></span><br><span class="line">LL top;</span><br><span class="line">LL fa[N][<span class="number">20</span>]; <span class="comment">// fa[i][j] 表示i结点的第2^j个祖先结点</span></span><br><span class="line">LL dis[N], x, y, z;</span><br><span class="line">LL ans[N]; <span class="comment">// 差分数组 后面变成i能控制的点的个数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">LL last, to, dis; <span class="comment">// last：父结点的head || to：子结点 || dis：边权</span></span><br><span class="line">&#125; s[N]; <span class="comment">// DFS数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(LL l1, LL l2, LL l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top ++ ;</span><br><span class="line">s[top].last = head[l1];</span><br><span class="line">s[top].to = l2;</span><br><span class="line">s[top].dis = l3;</span><br><span class="line">head[l1] = top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL now = n;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; i ++ )</span><br><span class="line">        fa[n][i] = fa[fa[n][i<span class="number">-1</span>]][i<span class="number">-1</span>]; <span class="comment">// 维护倍增数组</span></span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span>(fa[now][i] &amp;&amp; dis[n] - dis[fa[now][i]] &lt;= s1[n])</span><br><span class="line">            now = fa[now][i]; <span class="comment">// 寻找第一个不满足条件的祖宗（的父结点就是满足条件的</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 差分</span></span><br><span class="line">ans[fa[now][<span class="number">0</span>]] -- ;</span><br><span class="line">ans[fa[n][<span class="number">0</span>]] ++ ;</span><br><span class="line">    <span class="comment">// DFS</span></span><br><span class="line"><span class="keyword">for</span> (LL i = head[n]; i; i = s[i].last )</span><br><span class="line">    &#123;</span><br><span class="line">dis[s[i].to] = dis[n] + s[i].dis;</span><br><span class="line"><span class="built_in">dfs</span>(s[i].to);</span><br><span class="line">ans[n] += ans[s[i].to]; <span class="comment">// 维护答案</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a);</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= a; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;s1[i]);</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">2</span>; i &lt;= a; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;fa[i][<span class="number">0</span>], &amp;x); <span class="comment">// fa[i][0]就是i的父结点</span></span><br><span class="line"><span class="built_in">add</span>(fa[i][<span class="number">0</span>], i, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= a; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZAFU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZAFUACM - 7.10个人赛补题 A - C &amp; E &amp; H</title>
      <link href="/posts/5b53d481.html"/>
      <url>/posts/5b53d481.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-黑崎x护-CodeForces-501B"><a href="#A-黑崎x护-CodeForces-501B" class="headerlink" title="A - 黑崎x护 - CodeForces 501B"></a>A - 黑崎x护 - CodeForces 501B</h1><p><a href="https://codeforces.com/problemset/problem/501/B">题目链接</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出任意组数据，每组包含两个字符串，当 A 组的第二个字符串等于 B 组的第一个字符串时，将 A 组的第一个字符串转换成 B 组的第二个字符串，输出全部转换后还剩多少组数据，每组数据分别是什么</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二重循环，每修改一次就把被修改的那一组做个标记（我是把被修改的那组的第一个字符串换成‘ ’表示这一组一会儿不用输出了）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line">string s[N][<span class="number">2</span>];</span><br><span class="line">string ans[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i ++ )</span><br><span class="line">        cin &gt;&gt; s[i][<span class="number">0</span>] &gt;&gt; s[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i][<span class="number">0</span>] != <span class="string">&quot; &quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            string ss = s[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; q; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ss == s[j][<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    s[j][<span class="number">0</span>] = <span class="string">&quot; &quot;</span>;</span><br><span class="line">                    ss = s[j][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[num][<span class="number">0</span>] = s[i][<span class="number">0</span>];</span><br><span class="line">            ans[num][<span class="number">1</span>] = ss;</span><br><span class="line">            num ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ans[i][<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans[i][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-中野x乃-CodeForces-519C"><a href="#B-中野x乃-CodeForces-519C" class="headerlink" title="B - 中野x乃 - CodeForces 519C"></a>B - 中野x乃 - CodeForces 519C</h1><p><a href="https://codeforces.com/problemset/problem/519/C">题目链接</a></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>分组每组三个人，必须是一个大佬 + 两个菜鸡 or 一个菜鸡 + 两个大佬，给出大佬菜鸡的人数，问最多能组多少队</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>贪心，每次判断大佬和菜鸡人数多少，当前大佬多就选2大佬1菜鸡，否则相反</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; m == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= <span class="number">2</span> * n) cout &lt;&lt; n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">2</span> * m) cout &lt;&lt; m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (n &gt;= m)</span><br><span class="line">                &#123;</span><br><span class="line">                    n -= <span class="number">2</span>;</span><br><span class="line">                    m -= <span class="number">1</span>;</span><br><span class="line">                    ans ++ ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    n -= <span class="number">1</span>;</span><br><span class="line">                    m -= <span class="number">2</span>;</span><br><span class="line">                    ans ++ ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span> || (n == <span class="number">1</span> &amp;&amp; m == <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-x笠·阿克曼-CodeForces-501C"><a href="#C-x笠·阿克曼-CodeForces-501C" class="headerlink" title="C - x笠·阿克曼 - CodeForces 501C"></a>C - x笠·阿克曼 - CodeForces 501C</h1><p><a href="https://codeforces.com/problemset/problem/501/C">题目链接</a></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出点的个数，每个点给出两个信息 d 和 s，d 表示度，s 表示与该点相邻的所有点的异或和，问这个图长啥样</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>参考了某大佬的代码，先找到所有度为 1 的点，这些点的 s 就等于该点的邻接点，然后修改邻接点的 d 和 s，继续操作直到没有度为 1 的点</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; d[i] &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] == <span class="number">1</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;PII&gt; g;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (d[t] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g.<span class="built_in">push_back</span>(&#123;t, s[t]&#125;);</span><br><span class="line">            <span class="type">int</span> u = s[t];</span><br><span class="line">            s[u] ^= t;</span><br><span class="line">            d[u] -- ;</span><br><span class="line">            <span class="keyword">if</span> (d[u] == <span class="number">1</span>) q.<span class="built_in">push</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; g.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; g[i].first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; g[i].second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-x条悟-CodeForces-405D"><a href="#E-x条悟-CodeForces-405D" class="headerlink" title="E - x条悟 - CodeForces 405D"></a>E - x条悟 - CodeForces 405D</h1><p><a href="https://codeforces.com/problemset/problem/405/D">题目链接</a></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定 s &#x3D; 1e6，给出若干个 x，要求 <code>Σ(x - 1) = Σ(s - y)</code>，x y 不能重复，输出 y 的数量和 y 的值</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>与 <code>i</code> 对应的就是 <code>s - i + 1</code> ，如果这个值不在 x 中，直接输出，如果在，就输出两个等距离的没被用过的</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> s = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> x[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; available;</span><br><span class="line"><span class="type">int</span> need;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x[i];</span><br><span class="line">        st[x[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span> / <span class="number">2</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i] &amp;&amp; !st[s - i + <span class="number">1</span>]) available.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st[i] &amp;&amp; !st[s - i + <span class="number">1</span>]) cout &lt;&lt; s - i + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!st[i] &amp;&amp; st[s - i + <span class="number">1</span>]) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> need ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; need; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; available[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s + <span class="number">1</span> - available[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="H-比企谷x幡-CodeForces-710E"><a href="#H-比企谷x幡-CodeForces-710E" class="headerlink" title="H - 比企谷x幡 - CodeForces 710E"></a>H - 比企谷x幡 - CodeForces 710E</h1><p><a href="https://codeforces.com/problemset/problem/710/E">题目链接</a></p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>一个人只会打一个字母，添加或删除一个字母耗时 x，复制已经写过的耗时 y，这个人一共要打 n 个字母，问最短耗时</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这题赛时耗了好久，开始摆烂，最后一分钟改了个炸裂的写法提交了，居！然！AC！了！<br>（炸裂的写法放在最后）</p><p>接下来是参考的大佬的思路：贪心，分奇偶讨论，具体看代码吧~</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> i64 inf = <span class="number">0x3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x, y; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, inf)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="built_in">min</span>(f[i], f[i - <span class="number">1</span>] + x);</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) f[i] = <span class="built_in">min</span>(&#123;f[i], f[(i - <span class="number">1</span>) / <span class="number">2</span>] + y + x, f[(i + <span class="number">1</span>) / <span class="number">2</span>] + x + y&#125;);</span><br><span class="line">        <span class="keyword">else</span> f[i] = <span class="built_in">min</span>(f[i], f[i / <span class="number">2</span>] + y);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经不知道自己怎么会这么写的代码了…</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, x, y;</span><br><span class="line">vector&lt;LL&gt; cost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    cost.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    cost.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cost.<span class="built_in">push_back</span>(<span class="built_in">min</span>(cost[i / <span class="number">2</span>] + y, cost[i - <span class="number">1</span>] + x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cost.<span class="built_in">push_back</span>(cost[i - <span class="number">1</span>] + x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag || idx)</span><br><span class="line">    &#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cost[i] &gt; cost[i + <span class="number">1</span>] + x)</span><br><span class="line">        &#123;</span><br><span class="line">            cost[i] = cost[i + <span class="number">1</span>] + x;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cost[i] &gt; cost[i / <span class="number">2</span>] + y)</span><br><span class="line">            &#123;</span><br><span class="line">                cost[i] = cost[i / <span class="number">2</span>] + y;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cost[i] &gt; cost[i - <span class="number">1</span>] + x)</span><br><span class="line">            &#123;</span><br><span class="line">                cost[i] = cost[i - <span class="number">1</span>] + x;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cost[i] &gt; cost[i - <span class="number">1</span>] + x)</span><br><span class="line">            &#123;</span><br><span class="line">                cost[i] = cost[i - <span class="number">1</span>] + x;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cost[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZAFU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZAFUACM - 7.9个人赛补题 A - C E G H</title>
      <link href="/posts/ac229277.html"/>
      <url>/posts/ac229277.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-CodeForces-495B"><a href="#A-CodeForces-495B" class="headerlink" title="A CodeForces - 495B"></a>A CodeForces - 495B</h1><p><a href="https://codeforces.com/problemset/problem/495/B">题目链接</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个 a 一个 b ，求出有多少不同的 x 满足 a mod x &#x3D; b，输出 x 个数，如果有无数个就输出 “infinity”</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>当 a &#x3D; b 时，有无穷多个可以取的 x</li><li>当 a &lt; b 时，x 取任何数都不成立</li><li>当 a &gt; b 时，就是求 a - b 有多少个大于 b 的因子</li></ul><p>为了防止TLE，求因子个数时，循环结束条件应该写 sqrt(a - b) （痛</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (a == b) cout &lt;&lt; <span class="string">&quot;infinity&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b) cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> diff = a - b;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (diff / i &gt;= <span class="built_in">sqrt</span>(diff))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (diff % i == <span class="number">0</span>) <span class="comment">// i 是 diff 的一个因子</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (diff / i &gt; b) ans ++ ; <span class="comment">// 加的是因子 diff / i</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; b)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans ++ ; <span class="comment">// 加的是因子 i</span></span><br><span class="line">                    <span class="keyword">if</span> (diff == i * i) ans -- ; <span class="comment">// 当 i == diff / i 删去重复加的</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-CodeForces-495A"><a href="#B-CodeForces-495A" class="headerlink" title="B CodeForces - 495A"></a>B CodeForces - 495A</h1><p><a href="https://codeforces.com/contest/495/problem/A">题目链接</a></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>火柴棒摆数字，给出两个数字，给出的数字可能是某个数字缺少火柴棒后的结果，输出这两个数字有多少种可能的情况</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul><li>给出的数字是 8 时分别有 1 种情况</li><li>给出的数字是 0 &#x2F; 2 &#x2F; 6 &#x2F; 9 时分别有 2 种情况</li><li>给出的数字是 3 &#x2F; 4 时分别有 3 种情况</li><li>给出的数字是 5 时分别有 4 种情况</li><li>给出的数字是 7 时分别有 5 种情况</li><li>给出的数字是 1 时分别有 7 种情况</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> a = s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> b = s[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> || a == <span class="number">2</span> || a == <span class="number">6</span> || a == <span class="number">9</span>) a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) a = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span> || a == <span class="number">4</span>) a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">5</span>) a = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">7</span>) a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">8</span>) a = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span> || b == <span class="number">2</span> || b == <span class="number">6</span> || b == <span class="number">9</span>) b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">1</span>) b = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">3</span> || b == <span class="number">4</span>) b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">5</span>) b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">7</span>) b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">8</span>) b = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; a * b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-CodeForces-495C"><a href="#C-CodeForces-495C" class="headerlink" title="C CodeForces - 495C"></a>C CodeForces - 495C</h1><p><a href="https://codeforces.com/contest/495/problem/C">题目链接</a></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出一个字符串，包含三个字符 ‘(‘ ‘)’ ‘#’<br>每一个 ‘#’ 都可以替换成 &gt;&#x3D; 1 个 ‘)’<br>对于任意一个 i 都满足以下条件：</p><ul><li>前 i 个字符中，’(‘ 的数量大于等于 ‘)’ 的数量</li><li>整个字符串中，’(‘ 和 ‘)’ 的数量相等</li></ul><p>求每个 ‘#’ 要替换成多少个 ‘)’，输出任意一种情况</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这一题本人wa了三次才过，debug到想哭 TAT</p><p>首先遍历，求出每个字符的个数<br>如果 ‘(‘ 的个数比 ‘)’ 少或二者相等，直接输出 -1，因为 ‘#’ 还会变成 ‘)’，不可能保证两者相等<br>否则，判断 ‘(‘ 与 ‘)’ 数量的差值，如果差值小于 ‘#’ 的个数，直接输出 -1，理由同上</p><p>我们假设除了最后一个 ‘#’ 之外的所有 ‘#’ 都只替换成一个 ‘)’，少的 ‘)’ 全部由最后一个 ‘#’ 补全<br>那么重新遍历替换后的字符串，看看有没有不满足条件的地方，有就输出 -1，没有就按照上面的思路输出</p><p>说一下我自己debug过程中发现的容易漏掉的点：</p><ul><li>在第一遍还没有替换的遍历时就要判断是不是满足条件<br>否则会过不了类似于 “( ) ) ( ( #”</li><li>如果 ‘(‘ ‘)’ 的差值与 ‘#’ 的个数相等，也要重新遍历判断在每一个位置上是否满足条件<br>否则会过不了类似于 “( # ) ( ( )”</li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>（ 比赛赶时间想到哪写哪了所以写的可能会比较乱，欢迎大佬提供更简洁的思路~</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> suma = <span class="number">0</span>, sumb = <span class="number">0</span>, sumc = <span class="number">0</span>, diff;</span><br><span class="line">    <span class="comment">// 第一轮遍历 得出三种字符的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) suma ++ ;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) sumb ++ ;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;#&#x27;</span>) sumc ++ ;</span><br><span class="line">        <span class="keyword">if</span> (suma &lt; sumb) <span class="comment">// 判断当前位置是否满足条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (suma &lt;= sumb) cout &lt;&lt; <span class="string">&quot;-1&quot;</span>; <span class="comment">// 判断整个字符串是否满足条件</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        diff = suma - sumb;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; sumc) <span class="comment">// 判断条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff == sumc) <span class="comment">// 这种情况所有的&#x27;#&#x27;都替换成一个&#x27;)&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) a ++ ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> || s[i] == <span class="string">&#x27;#&#x27;</span>) b ++ ;<span class="keyword">if</span> (a &lt; b) <span class="comment">// 判断当前位置是否满足条件</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sumc; i ++ ) cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sa = <span class="number">0</span>, sb = <span class="number">0</span>, sc = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历替换后的字符串</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) sa ++ ;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) sb ++ ;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sc ++ ;</span><br><span class="line">                    <span class="keyword">if</span> (sc == sumc) sb += diff - sumc + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> sb ++ ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sa &lt; sb) <span class="comment">// 判断当前位置是否满足条件</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sumc - <span class="number">1</span>; i ++ )</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; diff - sumc + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-CodeForces-495D"><a href="#D-CodeForces-495D" class="headerlink" title="D CodeForces - 495D"></a>D CodeForces - 495D</h1><p><a href="https://codeforces.com/contest/495/problem/D">题目链接</a><br>（复习完KMP和dp再来补）</p><h1 id="E-CodeForces-198B"><a href="#E-CodeForces-198B" class="headerlink" title="E CodeForces - 198B"></a>E CodeForces - 198B</h1><p><a href="https://codeforces.com/problemset/problem/198/B">题目链接</a></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>两面竖着的墙，墙上不同区域有的能走有的不能走，每次可以在同一面墙上向上 1m 或者向下 1m 或者跳到另一面墙上高度升高给定的值，另外还有不断上升的水位，人每跳一次水上升 1m，给出墙的高度问能不能跳出去</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>深搜，每次只要满足：</p><ol><li>当前位置能走</li><li>当前位置没走过</li><li>水没淹过当前位置</li></ol><p>就可以继续搜<br>注意！！！这个地方调到崩溃：深搜时顺序是先看向下 1m 的再看其他两个向上的（因为考虑到水位上涨，先要尽可能往下搜）</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, water;</span><br><span class="line"><span class="type">char</span> wall[<span class="number">2</span>][N];</span><br><span class="line"><span class="type">bool</span> visit[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (wall[pos][x] == <span class="string">&#x27;X&#x27;</span> || x &lt; water || visit[pos][x]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    visit[pos][x] = <span class="literal">true</span>;</span><br><span class="line">    water ++ ;</span><br><span class="line">    <span class="type">bool</span> capable = (<span class="built_in">dfs</span>(pos, x - <span class="number">1</span>) || <span class="built_in">dfs</span>(<span class="number">1</span> - pos, x + k) || <span class="built_in">dfs</span>(pos, x + <span class="number">1</span>));</span><br><span class="line">    water -- ;</span><br><span class="line">    <span class="keyword">return</span> capable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    water = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; wall[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; wall[<span class="number">1</span>][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>)) cout &lt;&lt; <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-CodeForces-466E"><a href="#F-CodeForces-466E" class="headerlink" title="F CodeForces - 466E"></a>F CodeForces - 466E</h1><p><a href="https://codeforces.com/problemset/problem/466/E">题目链接</a></p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>三个操作：</p><ol><li>输入 x y，y 是 x 的 boss</li><li>输入 x，第 i 个文件从 x 手上开始传</li><li>输入 x y，询问文件 y 能不能传到 x 手上</li></ol><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>赛时想到了并查集，可惜代码实现能力太菜也没有并查集的板子导致寄了<br>补题时想到是不是能用遍历做，y 是 x 的 boss 就相当于建立一条 x -&gt; y 的边，询问时看看能不能从文件 y 的第一个持有人走到 x 即可，然后用 bfs 写了一下，TLE了<br>还是得用并查集进行路径压缩，但是有个问题：并非 x y 的祖先结点一样就能从 x 走到 y，因为可能出现这样的情况：</p><img src="/posts/ac229277/1.png" class><p>这个问题还没有想到解决方法，希望之后能补上</p><h1 id="G-CodeForces-546D"><a href="#G-CodeForces-546D" class="headerlink" title="G CodeForces - 546D"></a>G CodeForces - 546D</h1><p><a href="https://codeforces.com/problemset/problem/546/D">题目链接</a></p><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给出 a b 两个数，求 a! &#x2F; b! 每次除以任意一个数最多可以除多少次</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>（ 赛时刚看到题的内心 be like：寄 先预定一个TLE<br>之后果然成功TLE了~<br>嗯……这题主要还是预先打表（不要暴力打表） + 前缀和<br>题目是要求 (b + 1) * (b + 2) * … * a 的质因子个数，那就求出每个数的质因子，再整个前缀和数组，然后用 s[a] - s[b] 就快乐AC啦~（实际上既不快乐也没有AC &#x2F; QAQ）</p><p>（ps.还会卡cin…</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5000010</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> yz[N]; <span class="comment">// i的质因子个数</span></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i ++ )    </span><br><span class="line">        <span class="keyword">if</span> (yz[i] == <span class="number">0</span>)    </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; N; j += i )    </span><br><span class="line">                yz[j] = yz[j / i] + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 生成前缀和数组    </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ ) yz[i] += yz[i - <span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (t -- )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, yz[a] - yz[b]);<span class="comment">//利用了a!/b!的特性</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="H-CodeForces-849C"><a href="#H-CodeForces-849C" class="headerlink" title="H CodeForces - 849C"></a>H CodeForces - 849C</h1><p><a href="https://codeforces.com/problemset/problem/849/C">题目链接</a></p><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>序列中每两个部分合并会消耗相同字母在两个部分中数量的乘积之和<br>比如合并 ‘a’ ‘a’ ，在第一个部分中 a 出现了 1 次，第二个部分中 a 也出现了一次，没有其他字母出现，所以这一步就消耗 1 * 1 &#x3D; 1<br>再比如合并 ‘a’ ‘b’ ，在第一个部分 a 出现了 1 次，第二个部分没有出现 a，第一部分 b 出现了 0 次，第二部分出现了 1 次，所以这一步消耗 1 * 0 + 0 * 1 &#x3D; 0<br>给定一个值，要求给出一个序列，起初序列中的每个字母单独为一个部分，从开始到形成连续序列消耗的数量为给定值</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>我首先是考虑到，需要自己输出的题目不会出现特别复杂的字母组合，所以先枚举一下：</p><ul><li>‘a’ ‘a’ 合并消耗 1</li><li>‘a’ ‘a’ ‘a’ 合并消耗 3 (&#x3D; 1 + 2) （先合并 ‘a’ + ‘a’ &#x3D; 1，再合并 ‘a a’ + ‘a’ &#x3D; 2）</li><li>‘a’ ‘a’ ‘a’ ‘a’ 合并消耗 6 (&#x3D; 1 + 2 + 3)</li></ul><p>所以总结出规律，n 个 a 合并需要消耗 1 + 2 + … + (n - 1)，也就是 (1 + (n - 1)) * (n - 1) &#x2F; 2，化简后为 n * (n - 1) &#x2F; 2<br>每当添加进不同字母，只会在原来的基础上加上添加进来的字符串所消耗的数量（动手试试就知道）<br>所以我们可以按照字母从小到大开始输出字符串，也就是先只使用 a，构造出小于等于给定值的最大值，再使用 b，……依此类推</p><p>注意要特判 n &#x3D;&#x3D; 0 ！！！</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">sqrt</span>(n * <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> diff = n - (x * (x - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>; <span class="comment">// k 表示目前添加到哪一个字母了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i ++ ) cout &lt;&lt; <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (diff != <span class="number">0</span>) <span class="comment">// diff 等于0就表示构造完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (diff == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c%c&quot;</span>, <span class="string">&#x27;a&#x27;</span> + k, <span class="string">&#x27;a&#x27;</span> + k);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = <span class="built_in">sqrt</span>(diff * <span class="number">2</span>);</span><br><span class="line">        diff = diff - (x * (x - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;a&#x27;</span> + k);</span><br><span class="line">        k ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZAFU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-11 关键活动</title>
      <link href="/posts/feeaa54c.html"/>
      <url>/posts/feeaa54c.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>原题链接</p><p><a href="https://pintia.cn/problem-sets/1399202744970727424/problems/1418527362277498881">https://pintia.cn/problem-sets/1399202744970727424/problems/1418527362277498881</a></p><p>假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。</p><p>比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。</p><p>但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。</p><p>任务调度问题中，如果还给出了完成每个子任务需要的时间，则我们可以算出完成整个工程需要的最短时间。在这些子任务中，有些任务即使推迟几天完成，也不会影响全局的工期；但是有些任务必须准时完成，否则整个项目的工期就要因此延误，这种任务就叫“关键活动”。</p><p>请编写程序判定一个给定的工程项目的任务调度是否可行；如果该调度方案可行，则计算完成整个工程项目需要的最短时间，并输出所有的关键活动。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入第1行给出两个正整数N(≤100)和M，其中N是任务交接点（即衔接相互依赖的两个子任务的节点，例如：若任务2要在任务1完成后才开始，则两任务之间必有一个交接点）的数量。交接点按1<del>N编号，M是子任务的数量，依次编号为1</del>M。随后M行，每行给出了3个正整数，分别是该任务开始和完成涉及的交接点编号以及该任务所需的时间，整数间用空格分隔。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>如果任务调度不可行，则输出0；否则第1行输出完成整个工程项目需要的时间，第2行开始输出所有关键活动，每个关键活动占一行，按格式“V-&gt;W”输出，其中V和W为该任务开始和完成涉及的交接点编号。关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。</p><h1 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">4</span></span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">6</span></span><br><span class="line"><span class="number">6</span>-&gt;<span class="number">7</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>小白在csdn上的第一篇题解，送给这道好不容易弄懂的数构题！！</p><h2 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h2><p>在写这道题之前，先复习一下 <strong>AOE网</strong> 的相关知识：（大佬自行跳过~）</p><p>AOE网，简单来说就是工程的带权有向图，其中：</p><ul><li>顶点：活动开始或者结束的<strong>事件</strong></li><li>边：<strong>活动</strong></li><li>边的权值：完成该活动所需的<strong>时间</strong></li></ul><p>在AOE网中，想要完成一项活动，必须要先完成在该活动前面的所有活动，例如下图中，想要完成活动e，必须要先完成活动abcd，完成活动a和c所需时间为3 + 2 &#x3D; 5，完成活动b和d所需时间为5 + 4 &#x3D; 9，二者取大，因此任务e的最早开始时间为9。 </p><img src="/posts/feeaa54c/1.png" class><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>由此我们可以知道，整个工程从开始到结束所需要花费的时间是起始点到终止点的最大路径长度（因为这样才可以保证在终止点前的所有任务都完成了），这个有最大路径长度的路径就是<strong>关键路径</strong>，关键路径上的活动就叫做<strong>关键活动。</strong></p><p>然后来看题吧！！</p><p>题目要求我们输出整个工程项目所需时间和所有关键活动。</p><h2 id="Problem-1：求整个工程项目所需时间"><a href="#Problem-1：求整个工程项目所需时间" class="headerlink" title="Problem 1：求整个工程项目所需时间"></a>Problem 1：求整个工程项目所需时间</h2><p>首先，题目没有告诉我们从哪个点开始到哪个点结束，所以需要先记录一下每个点的入度和出度，入度为0的点是起始点，出度为0的点就是终止点啦。</p><p>然后，用early数组记录每个点（事件）的最早发生时间，假设有事件i和j，它们之间有关系j -&gt; i，那么事件i的最早发生时间early[i] &#x3D; max(early[i], early[j] + weight&lt;i, j&gt;)，（因为i前面的所有活动全部完成才能开始i，所以在前面的路径中选取最大值），这样到最后，early数组中的最大值就是整个工程的最早完成时间啦。</p><h2 id="Problem-2：判断哪些是关键路径上的活动"><a href="#Problem-2：判断哪些是关键路径上的活动" class="headerlink" title="Problem 2：判断哪些是关键路径上的活动"></a>Problem 2：判断哪些是关键路径上的活动</h2><p>话不多说举个栗子（还是以上面的图为例吧（才不是懒得画图））——</p><img src="/posts/feeaa54c/2.png" class><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> 结点4的最早发生时间上面说过啦是9，因为需要在活动abcd全部完成之后才能到结点4，换一种说法，就是在9的时间里，需要完成1-&gt;2-&gt;4和1-&gt;3-&gt;4这两段：</p><ul><li>先来看1-&gt;3-&gt;4这一段，1-&gt;3花费时间5，3-&gt;4花费时间4，所以想要在9时到达4，必须要在5时到达3，也就是事件3的最晚发生时间是5（如果5时没有到达事件3，那就不可能在9时到达事件4）</li><li>再来看1-&gt;2-&gt;4这一段，1-&gt;2花费时间3，2-&gt;4花费时间2，我们知道只要在9时到达事件4即可，所以【最迟】可以在7时到达事件2（当然比7时早也没什么关系），也就是在7时到达事件2，可以保证我们9时能够到达事件4，从而不耽误整个工程</li></ul><p>综上所述，事件2的最早发生时间是3，最晚发生时间是7，事件3的最早发生时间是5，最晚发生时间还是5.</p><p><strong>当同一个事件的【最早发生时间】与【最晚发生时间】相等，就证明这个事件就是关键路径上的结点****（很重要！！！）</strong></p><p> 在problem1中我们求出了每个结点的最早发生时间early，可以利用early求出每个结点的最晚发生时间late，它们之间的关系是（前提：i-&gt;j）事件i的最晚发生时间late[i] &#x3D; early[j] - weight[i, j]</p><p>现有事件 i 和 j （i -&gt; j），当它们满足以下三点：</p><ol><li>i 和 j 之间有边</li><li>i 和 j 的最早发生时间分别等于各自的最晚发生时间</li><li>j的最早发生时间late[j] &#x3D; i的最早发生时间early[i] + ij之间的边的权值weight[i, j]</li></ol><p>就可以判断i-&gt;j是一个关键活动啦！！</p><h2 id="problem-3：如何按题目要求输出"><a href="#problem-3：如何按题目要求输出" class="headerlink" title="problem 3：如何按题目要求输出"></a>problem 3：如何按题目要求输出</h2><p>题目中要求：</p><blockquote><p>关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。</p></blockquote><p> 因此输出中两层循环：</p><ol><li>第一层从小到大，保证任务开始的交接点从小到大</li><li>第二层从大到小，保证起点编号相同情况下，与输入的顺序相反</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> edge[N][N]; <span class="comment">// 记录两边之间的权值</span></span><br><span class="line"><span class="type">int</span> in[N], out[N]; <span class="comment">// 分别记录每个点的入度与出度</span></span><br><span class="line"><span class="type">int</span> early[N], late[N]; <span class="comment">// 记录每个事件的最早发生时间和最晚发生时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">earlysolve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="comment">// q中存储入度为0的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// i入度为0就将i存入q</span></span><br><span class="line">        <span class="keyword">if</span> (in[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) <span class="comment">// 当q不为空时进入循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>(); <span class="comment">// 可以将t看作是起点</span></span><br><span class="line">        idx ++ ; <span class="comment">// 记录已经遍历的结点个数</span></span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">// 将取出的t从q中删去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[t][i] != INF)</span><br><span class="line">            &#123;</span><br><span class="line">                in[i] -- ; <span class="comment">// 记录下来t-&gt;i这条边之后就删去这条边</span></span><br><span class="line">                early[i] = <span class="built_in">max</span>(early[i], early[t] + edge[t][i]); <span class="comment">// 找到和i相邻的最大边</span></span><br><span class="line">                <span class="keyword">if</span> (in[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i); <span class="comment">// 记录下i相邻的所有边之后就把i当做入度为0存进q中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历点的个数与点的总个数不相等 说明无法完成</span></span><br><span class="line">    <span class="keyword">if</span> (idx != n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-2e9</span>; <span class="comment">// res是所有事件最早发生时间的最大值 也就是完成整个工程所需的时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            res = <span class="built_in">max</span>(res, early[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">latesolve</span><span class="params">(<span class="type">int</span> res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="comment">// q存储出度为0的事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (out[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果出度为0，说明是终点，最晚完成时间就等于整个工程的所需时间</span></span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            late[i] = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>(); <span class="comment">// t可以看作是当前子段的终点</span></span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">// 从q中删去已经取出的t</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i][t] != INF)</span><br><span class="line">            &#123;</span><br><span class="line">                out[i] -- ;</span><br><span class="line">                late[i] = <span class="built_in">min</span>(late[i], late[t] - edge[i][t]); <span class="comment">// 要保证最长的i-&gt;t能完成，所以取min</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (out[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i); <span class="comment">// 记录下i相邻的所有边之后就把i当做入度为0存进q中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        late[i] = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">            edge[i][j] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        edge[a][b] = c;</span><br><span class="line">        in[b] ++ ;</span><br><span class="line">        out[a] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">earlysolve</span>(); <span class="comment">// 完成所有任务所需时间</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">latesolve</span>(res);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j -- )</span><br><span class="line">            <span class="keyword">if</span> (edge[i][j] != INF &amp;&amp; late[j] - early[i] == edge[i][j])</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
      
      
      <categories>
          
          <category> 杂题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOE网 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cf】CodeForces Round 905（Div.3）题解</title>
      <link href="/posts/4e51d0c7.html"/>
      <url>/posts/4e51d0c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-Morning"><a href="#A-Morning" class="headerlink" title="A. Morning"></a>A. Morning</h1><p><a href="https://codeforces.com/contest/1883/problem/A">原题链接</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个人要打字，光标现在停在1，键盘顺序是1234567890，挪动一个位置和按下这个键都需要花费1s，问打完给定字符串最少需要几秒</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题有个需要注意的点是，到0之后想打别的键是往左走，不可以往右直接到1，注意这个其他就没什么了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    i64 ans = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i ++ ) pos[i] = i;</span><br><span class="line">    pos[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    ans = <span class="built_in">abs</span>(pos[s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>] - pos[<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        ans += <span class="built_in">abs</span>(pos[s[i] - <span class="string">&#x27;0&#x27;</span>] - pos[s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="comment">// t = 1;</span></span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Chemistry"><a href="#B-Chemistry" class="headerlink" title="B. Chemistry"></a>B. Chemistry</h1><p><a href="https://codeforces.com/contest/1883/problem/B">原题链接</a></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定字符串，问能不能删掉k个字符，然后对整个字符串重新排列，使得新字符串对称</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>不同字母个数都是偶数，或者只有一个字母个数是奇数的情况下，可以让整个字符串对称，所以判断一下删掉k个字符之后能不能使得奇数个数的字符小于等于1个就可以了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cnt[s[i]] ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = t.second;</span><br><span class="line">        <span class="keyword">if</span> (m % <span class="number">2</span> != <span class="number">0</span>) idx ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx - k &gt; <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>  cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="comment">// t = 1;</span></span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Raspberries"><a href="#C-Raspberries" class="headerlink" title="C. Raspberries"></a>C. Raspberries</h1><p><a href="https://codeforces.com/contest/1883/problem/C">原题链接</a></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组，每次操作可以将任意一位加一，问最少操作多少次能让数组中所有元素的乘积是k的倍数</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>因为k是2&#x2F;3&#x2F;4&#x2F;5,235都是素数，所以只要数组中出现了他们的倍数即可，如果k是4，那么有两种情况，一种是有一个数是4的倍数，那么直接整除，另一种情况是有两个数是2的倍数，也可以让整体的乘积凑出4的倍数</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> ans = k;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, cnt1 = <span class="number">0</span>, t = <span class="number">5</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] % k == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="number">4</span>) t = k - (a[i] % k);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] % <span class="number">2</span> == <span class="number">0</span>) cnt ++ ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((a[i] + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span>) cnt1 ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k != <span class="number">4</span>) cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt1 != <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">2</span> - cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="comment">// t = 1;</span></span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-In-Love"><a href="#D-In-Love" class="headerlink" title="D. In Love"></a>D. In Love</h1><p><a href="https://codeforces.com/contest/1883/problem/D">原题链接</a></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出多个子段的左右端点，问加入或删去当前字段后，还是否存在完全不重合的两个子段</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>用multiset存（今天是长见识了qaq），可以存重复元素的set（默认升序），跑起来也会比map快</p><p>只要最大的开头元素小于最小的末尾元素，就可以说明有不重复的子段</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a.<span class="built_in">insert</span>(l);</span><br><span class="line">            b.<span class="built_in">insert</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a.<span class="built_in">erase</span>(a.<span class="built_in">find</span>(l));</span><br><span class="line">            b.<span class="built_in">erase</span>(b.<span class="built_in">find</span>(r));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">size</span>() &amp;&amp; *a.<span class="built_in">rbegin</span>() &gt; *b.<span class="built_in">begin</span>()) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Look-Back"><a href="#E-Look-Back" class="headerlink" title="E. Look Back"></a>E. Look Back</h1><p><a href="https://codeforces.com/contest/1883/problem/E">原题链接</a></p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组，每次操作可以将任意一个数乘2，问最少经过多少次操作，可以把数组变成非递减的数组</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>先打表把2的次方存进数组</p><p>先骂自己，第一思路居然直接开始暴力模拟，让数组中的元素实时变化，不爆才怪啊、、、</p><p>实际上只需要记录下每个元素需要乘的2的数量，之后如果有后一个数比前一个数大的情况，可以看看大多少倍，用之前的2抵消</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;i64&gt; <span class="title">xsl</span><span class="params">(<span class="number">63</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;i64&gt; <span class="title">xsl_re</span><span class="params">(<span class="number">63</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    i64 ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[i - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> diff = <span class="number">1.0</span> * a[i - <span class="number">1</span>] / a[i];</span><br><span class="line">            <span class="type">int</span> tmp = <span class="built_in">lower_bound</span>(xsl.<span class="built_in">begin</span>(), xsl.<span class="built_in">end</span>(), diff) - xsl.<span class="built_in">begin</span>();</span><br><span class="line">            t += tmp;</span><br><span class="line">            ans += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> diff = a[i] / a[i - <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> tmp = <span class="built_in">lower_bound</span>(xsl_re.<span class="built_in">begin</span>(), xsl_re.<span class="built_in">end</span>(), diff, <span class="built_in">greater</span>&lt;i64&gt;()) - xsl_re.<span class="built_in">begin</span>();</span><br><span class="line">            tmp = <span class="number">62</span> - tmp;</span><br><span class="line">            t = <span class="built_in">max</span>(<span class="number">0</span>, t - tmp);</span><br><span class="line">            ans += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    i64 res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">63</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        xsl[i] = res;</span><br><span class="line">        res *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xsl_re = xsl;</span><br><span class="line">    <span class="built_in">reverse</span>(xsl_re.<span class="built_in">begin</span>(), xsl_re.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="comment">// t = 1;</span></span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-You-Are-So-Beautiful"><a href="#F-You-Are-So-Beautiful" class="headerlink" title="F. You Are So Beautiful"></a>F. You Are So Beautiful</h1><p><a href="https://codeforces.com/contest/1883/problem/F">原题链接</a></p><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组，问存在多少个子数组，使得数组中只能找到一个子序列和子数组相等</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这题很狡诈啊、、、专门来坑分不清子序列和子数组的笨比TAT</p><p>子数组一定是要连续的，但子序列不用连续！只要相对位置不改变就可以！！</p><p>所以这个子数组存在，当且仅当它的左端点第一次出现在数组中且右端点最后一次出现在数组中（真的很妙）</p><p>（另外在确定算法的时间复杂度没有问题的时候真的可以考虑一下是不是可以把<code>unordered_map</code>换成<code>map</code>，第二次遇到<code>map</code>比<code>unordered_map</code>快了</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        last[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i64 ans = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; idx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!idx.<span class="built_in">count</span>(a[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            pre ++ ;</span><br><span class="line">            idx.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (last[a[i]] == i) ans += pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="comment">// t = 1;</span></span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G1-Dances-Easy-version"><a href="#G1-Dances-Easy-version" class="headerlink" title="G1. Dances (Easy version)"></a>G1. Dances (Easy version)</h1><p><a href="https://codeforces.com/contest/1883/problem/G1">原题链接</a></p><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给出两个数组，可以任意排序，每次操作可以同时在两个数组中分别删去一个元素，问至少多少操作才能让所有<code>a[i] &lt; b[i]</code></p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>先排序，然后双指针从前往后遍历，遇到不满足情况的就从b的开头和a的末尾删</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    a[<span class="number">0</span>] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    i64 cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ia = <span class="number">0</span>, ib = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ib = <span class="number">0</span>; ib &lt; n; ib ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[ia] &gt;= b[ib]) cnt ++ ;</span><br><span class="line">        <span class="keyword">else</span> ia ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="comment">// t = 1;</span></span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G2-Dances-Hard-Version"><a href="#G2-Dances-Hard-Version" class="headerlink" title="G2. Dances (Hard Version)"></a>G2. Dances (Hard Version)</h1><p><a href="https://codeforces.com/contest/1883/problem/G2">原题链接</a></p><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>和上一题一样，m换了范围</p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>不考虑是否满足情况，所有情况的个数<code>n x m</code>，原本就满足<code>a &lt; b</code>的删去，可以和 m 组合使得符合条件的删去，剩下的就是不符合条件的了</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i64 n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    multiset&lt;i64&gt; bb;</span><br><span class="line">    i64 cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) bb.<span class="built_in">insert</span>(b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = bb.<span class="built_in">upper_bound</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span> (pos != bb.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            bb.<span class="built_in">erase</span>(pos);</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i64 ans = cnt * m;</span><br><span class="line">    i64 tmp = *bb.<span class="built_in">rbegin</span>();</span><br><span class="line">    ans += <span class="built_in">min</span>(m, tmp - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; m * n - ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="comment">// t = 1;</span></span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cf】CodeForces Edu Round 153（Div.2）题解 A - C</title>
      <link href="/posts/d1c2c290.html"/>
      <url>/posts/d1c2c290.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-Not-a-Substring"><a href="#A-Not-a-Substring" class="headerlink" title="A. Not a Substring"></a>A. Not a Substring</h1><p><a href="https://codeforces.com/contest/1860/problem/A">原题链接</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一段长度为 n 的仅由<code>(</code>和<code>)</code>组成的字符串，要求输出一段长度为 2*n 的不包含给定字串的字符串，其中<code>()</code>要对应，比如说不能<code>)(</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题还是想了一会儿，最后发现其实只有<code>()</code>的情况不能输出，其余情况可以按照以下规则输出：</p><ul><li>如果给出的子串中有两个相同括号相连，比如说<code>((</code>或者<code>))</code>，那只要连着输出<code>()</code>就可以使最终结果不包含两个相同的括号相邻</li><li>如果给出的子串没有两个相同括号相连，那只要在输出时让相同括号相连就好了，输出 n 个<code>(</code>和 n 个<code>)</code>即可</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;()&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag1 = <span class="literal">false</span>, flag2 = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            flag1 = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ ) cout &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ ) cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Fancy-Coins"><a href="#B-Fancy-Coins" class="headerlink" title="B. Fancy Coins"></a>B. Fancy Coins</h1><p><a href="https://codeforces.com/contest/1860/problem/B">原题链接</a></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>这个人要买 m 元钱的东西，只能付给商家 m 元不能多给</p><p>他现在有 <code>a1</code>个面值为 1 元的普通硬币和无数个面值为 1 元的特殊硬币，还有<code>ak</code>个面值为 k 元的普通硬币和无数个面值为 k 元的特殊硬币</p><p>现在问他需要付的最少的特殊硬币的数量是多少</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>读题花了我好久啊读不懂题太emo了</p><p>一开始看题很容易想成先用普通硬币全付掉然后剩下的用特殊硬币来付，于是成功wa了一发…</p><p>要注意他想让特殊硬币的数量最少而不是面值最小，举个栗子如果用普通硬币付完之后还剩下20元需要付，此时k&#x3D;7，那可以先付两个特殊硬币也就是14元，还剩下6元用6个面值为1元的特殊硬币付（？仔细思考一下是这样吗）显然不是，此时可以少付一枚面值为1的普通硬币，这样需要用特殊硬币来付的金额就变成了21元，只需要3枚特殊硬币即可</p><p>所以这一题首先判断一下能不能用普通硬币来付完所有的金额（需要注意并不是普通硬币的总金额达到了就可以付，要看看两种不同面值的普通硬币能不能组合为需要付款的金额），如果能付完那就不需要用特殊硬币直接输出0，如果不能就进入下一步</p><p>先用普通硬币付尽可能多的金额，剩下的钱再用特殊硬币中面值为 k 的付款，最后剩下小于 k 的金额没有付款，看看这个金额距离 k 还有多少，能不能用普通硬币组合而成（如果能用普通硬币组合，我们就可以少付这么多普通硬币，从而让最后剩余的金额变为 k ，直接付一枚特殊硬币），如果能的话直接在原答案基础上加1，不能就加上多出的那一部分（多出来的全部用面值为1的特殊硬币付）</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(i64 sum, i64 a1, i64 ak, i64 k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; a1 + ak * k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (ak * k &gt;= sum) sum -= sum / k *k;</span><br><span class="line">    <span class="keyword">else</span> sum -= ak * k;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt;= a1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i64 m, k, a1, ak;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; k &gt;&gt; a1 &gt;&gt; ak;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(m, a1, ak, k))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        i64 have;</span><br><span class="line">        <span class="keyword">if</span> (m &gt;= k * ak + a1) have = k * ak + a1;</span><br><span class="line">        <span class="keyword">else</span> have = m / k * k + a1;</span><br><span class="line">        </span><br><span class="line">        i64 sum = m - have;</span><br><span class="line">        i64 cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum % k &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(k - sum % k, a1, ak, k)) cnt = sum / k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt = sum / k;</span><br><span class="line">            <span class="keyword">if</span> (sum % k != <span class="number">0</span>) cnt += sum % k;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Game-on-Permutation"><a href="#C-Game-on-Permutation" class="headerlink" title="C. Game on Permutation"></a>C. Game on Permutation</h1><p><a href="https://codeforces.com/contest/1860/problem/C">原题链接</a></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>如果点 i 和 j 满足 <code>j &lt; i</code>且 <code>a[j] &lt; a[i]</code>，则可以从 i 点移动到 j 点</p><p>问所有满足该条件的点的个数：该点前面的任何一个可以移动到的点，都不能移动到其他点</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>遍历数组时记录下当前最小值 <code>minn</code> 和当前满足条件的点的最小值，之后的数一旦小于当前最小值，说明它不能移动，必然不可能是满足条件的点，如果不小于当前最小值但大于当前满足条件的点的最小值，说明它一定可以移动到满足条件的点，它本身也就不可能是满足条件的点（因为可以移动到的点还能移到其他点）</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minn = n + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> minlose = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; minn) <span class="comment">// 小于当前最小值必输</span></span><br><span class="line">        &#123;</span><br><span class="line">            minn = a[i];</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; minlose) <span class="comment">// 大于当前稳赢的最小值必输</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res) <span class="comment">// 当前点稳赢</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            minlose = <span class="built_in">min</span>(minlose, a[i]); <span class="comment">// 更新当前稳赢最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cf】CodeForces Round 893（Div.2）题解 A - C</title>
      <link href="/posts/c56e64de.html"/>
      <url>/posts/c56e64de.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-Buttons"><a href="#A-Buttons" class="headerlink" title="A. Buttons"></a>A. Buttons</h1><p><a href="https://codeforces.com/contest/1858/problem/A">原题链接</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有三堆物品，给出每一堆物品的数量，第一个人只能从第一堆和第三堆每次拿一个，第二个人只能从第二堆和第三堆每次拿一个，谁先没东西拿谁就输，问谁能赢</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这一题一开始脑子抽了wa了一发，都想让对方输所以都得先拿第三堆的，第三堆拿完了再看第一二堆谁多谁少，注意一下奇偶即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (c % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) cout &lt;&lt; <span class="string">&quot;First\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Second\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= b) cout &lt;&lt; <span class="string">&quot;First\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Second\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-The-Walkway"><a href="#B-The-Walkway" class="headerlink" title="B. The Walkway"></a>B. The Walkway</h1><p><a href="https://codeforces.com/contest/1858/problem/B">原题链接</a></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一条路上有几个特殊点，一个人会在以下这几种情况吃一块饼干</p><ul><li>经过特殊点</li><li>在1点</li><li>已经经过k段路程没吃饼干</li></ul><p>现在可以删除一个特殊点，问这个人最少吃多少饼干以及有多少种删除方式</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我是先计算出每两个特殊点中间的距离可以让这个人吃多少饼干，存储下这个数值的前缀和</p><p>之后遍历每个特殊点，计算删除掉这个特殊点之后这个人吃的饼干数量，例如当前计算第 i 个特殊点，那就单独计算第 i-1 个特殊点到第 i+1 个特殊点之间吃的饼干数量，再加上第 i-1 个点前面的饼干数量（计算前缀和时已经将这个数值存储下来了），再加上第 i+1 个点后面的饼干数量，再加上所有特殊点的数量减1</p><p>计算时顺便存储一下这个饼干数量被算出过几次</p><p>中间有一些需要注意的地方，思路清晰之后主要还是代码实现</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;i64, i64&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, d;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">seller</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">idx</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) cin &gt;&gt; seller[i];</span><br><span class="line">    seller[m] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (seller[<span class="number">0</span>] == <span class="number">1</span>) idx[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> idx[<span class="number">0</span>] = (seller[<span class="number">0</span>] - <span class="number">2</span>) / d + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">        idx[i] = (seller[i] - seller[i - <span class="number">1</span>] - <span class="number">1</span>) / d + idx[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(idx[m] - idx[<span class="number">1</span>] + (seller[<span class="number">1</span>] - <span class="number">2</span>) / d + m);</span><br><span class="line">    cnt[idx[m] - idx[<span class="number">1</span>] + (seller[<span class="number">1</span>] - <span class="number">2</span>) / d + m] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res = idx[i - <span class="number">1</span>] + idx[m] - idx[i + <span class="number">1</span>] + (seller[i + <span class="number">1</span>] - seller[i - <span class="number">1</span>] - <span class="number">1</span>) / d + m - <span class="number">1</span>;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">        <span class="keyword">if</span> (!cnt.<span class="built_in">count</span>(res)) cnt[res] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> cnt[res] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cnt[ans[<span class="number">0</span>]] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Yet-Another-Permutation-Problem"><a href="#C-Yet-Another-Permutation-Problem" class="headerlink" title="C. Yet Another Permutation Problem"></a>C. Yet Another Permutation Problem</h1><p><a href="https://codeforces.com/contest/1858/problem/C">原题链接</a></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>求出一种排列使得相邻两数的最小公约数数量最多</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>从1开始，让后一个数一直是前一个数的两倍，这样可以保证出现新的最大公约数，直到两倍已经不在给定的n内就换下一个没用过的数</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">2</span>, temp;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">idx</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">2</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (k &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = i * j;</span><br><span class="line">        <span class="keyword">while</span> (temp &lt;= n &amp;&amp; !idx[temp])</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            k ++ ;</span><br><span class="line">            idx[temp] = <span class="literal">true</span>;</span><br><span class="line">            j *= <span class="number">2</span> ;</span><br><span class="line">            temp = i * j;</span><br><span class="line">        &#125;</span><br><span class="line">        j = <span class="number">1</span>;</span><br><span class="line">        i ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; ans.<span class="built_in">size</span>(); cnt ++ ) cout &lt;&lt; ans[cnt] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cf】CodeForces Round 892（Div.2）题解 A - D</title>
      <link href="/posts/da2f945a.html"/>
      <url>/posts/da2f945a.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-United-We-Stand"><a href="#A-United-We-Stand" class="headerlink" title="A. United We Stand"></a>A. United We Stand</h1><p><a href="https://codeforces.com/contest/1859/problem/A">原题链接</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组a，把数组a中的元素分给两个空数组，要求第一个数组中的每个元素都不能是第二个数组中元素的倍数，输出一种分法</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，对a排序，只要出现了1，一定是放在b数组里，否则放在c里，b中就一定会出现1的倍数</p><p>然后不是1的第一个元素一定要放在c中，因为要求bc都非空</p><p>之后因为数据范围比较小，就是暴力枚举了，这个数如果是c中元素的倍数就放到c，不是就放到b</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">1</span> || a[i] == a[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            b.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            c.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = a[i];</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k % c[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c.<span class="built_in">push_back</span>(k);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) b.<span class="built_in">push_back</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">empty</span>() || c.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i ++ ) cout &lt;&lt; b[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.<span class="built_in">size</span>(); i ++ ) cout &lt;&lt; c[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Olya-and-Game-with-Arrays"><a href="#B-Olya-and-Game-with-Arrays" class="headerlink" title="B. Olya and Game with Arrays"></a>B. Olya and Game with Arrays</h1><p><a href="https://codeforces.com/contest/1859/problem/B">原题链接</a></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出多个数组，对于每个数组都可以将它其中的任意一个元素挪到另一个数组，问操作后的 【数组最小值之和】 最大是多少</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这一题只和每个数组的最小的两个数有关，所以无需记录下全部元素</p><p>因为可以随便移动，我们发现，所有数组元素中最小的一个（后文叫它x）无论移到哪都是最小的，其他数组中最小的元素只要移到那个包含x的数组中，那个数组中最小的元素还是x，而其他数组中最小的元素都变成了原来第二小的元素</p><p>所以最大值就应该是所有数组中最小元素中的最小的元素加上所有数组中第二小元素之和删去第二小元素中最小的元素</p><p>另外要注意一下，如果只有一个数组，那只能输出该数组中最小的元素</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;i64, i64&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ ) cin &gt;&gt; a[j];</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        b.<span class="built_in">push_back</span>(a[<span class="number">0</span>]);</span><br><span class="line">        c.<span class="built_in">push_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">    i64 sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        sum += b[i];</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) cnt += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    cnt += b[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) cout &lt;&lt; b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; cnt;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Another-Permutation-Problem"><a href="#C-Another-Permutation-Problem" class="headerlink" title="C. Another Permutation Problem"></a>C. Another Permutation Problem</h1><p><a href="https://codeforces.com/contest/1859/problem/C">原题链接</a></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>排列表示一个长度为n的数组包含1-n这n个数字</p><p>现在给出n，要求一种排列使得 【所有位数乘该位上的元素之和】减去【位数乘该位上的元素之和的最大值】这个结果最大，输出最大值</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>先找到规律，发现所有最大值的情况都是后面一部分数组逆序，然后直接暴力枚举</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) a[i] = i;</span><br><span class="line"></span><br><span class="line">    i64 ans = <span class="number">0</span>, maxx = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>() + i + <span class="number">1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            maxx = <span class="built_in">max</span>(maxx, (i64)(a[j] * j));</span><br><span class="line">            temp += a[j] * j;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (i64)(temp - maxx));</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>() + i + <span class="number">1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Andrey-and-Escape-from-Capygrad"><a href="#D-Andrey-and-Escape-from-Capygrad" class="headerlink" title="D. Andrey and Escape from Capygrad"></a>D. Andrey and Escape from Capygrad</h1><p><a href="https://codeforces.com/contest/1859/problem/D">原题链接</a></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出若干个组区间 l、r、a、b，在 l - r 中的点可以传到 a - b，现给出若干个起始点，求最终能传送到的离原点的最远位置是哪个</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>只需要关注 l b，因为在 b - r 中的点传送后最远只能到 b，因此就无需传送，只需要将所有 l - b 中的点传到 b 即可，进行区间合并，输入询问直接输出结果</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;PII&gt; <span class="title">trans</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> rr, aa;</span><br><span class="line">        cin &gt;&gt; trans[i].first &gt;&gt; rr &gt;&gt; aa &gt;&gt; trans[i].second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(trans.<span class="built_in">begin</span>(), trans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; l, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = trans[i].first, y = trans[i].second;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; trans[i].first &lt;= y)</span><br><span class="line">        &#123;</span><br><span class="line">            y = <span class="built_in">max</span>(y, trans[i].second);</span><br><span class="line">            i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        l.<span class="built_in">push_back</span>(x);</span><br><span class="line">        b.<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">upper_bound</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), x) - l.<span class="built_in">begin</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || b[k] &lt;= x) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; b[k] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cf】CodeForces Round 891（Div.3）题解</title>
      <link href="/posts/fedda15a.html"/>
      <url>/posts/fedda15a.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-Array-Coloring"><a href="#A-Array-Coloring" class="headerlink" title="A. Array Coloring"></a><a href="https://codeforces.com/contest/1857/problem/A">A. Array Coloring</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组，把这个数组中的元素分成两部分，使得每一部分的和都是奇数或者都是偶数，问能不能分</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接判断整个数组的元素和是奇数还是偶数，如果是奇数直接输出NO，偶数直接输出YES，因为奇数&#x3D;奇数+偶数，偶数既可以等于偶数加偶数，也可以等于奇数加偶数</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    i64 sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Maximum-Rounding"><a href="#B-Maximum-Rounding" class="headerlink" title="B. Maximum Rounding"></a><a href="https://codeforces.com/contest/1857/problem/B">B. Maximum Rounding</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一个数x，位数从右到左，可以选择k进行操作，每轮操作如下;</p><ul><li>如果第k-1个位置&gt;&#x3D;5，那么将第k个位置的数加1</li><li>如果在操作前第k个位置就是9，那么将其前面第一个小于9的数直接加1</li><li>上述两操作完成后，将第k位后面的所有数字都变成0</li></ul><p>问经过操作使得原来的x可能变为的最大值是多少</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这题好难理解，读题花了我半天，题目读不懂的时候要崩溃</p><p>自己写的代码太复杂，这里参考了蒋老师的，大佬的思路好清晰TAT</p><p>大概步骤就是，存字符一样倒着存x，定义一个flag标记进位，k记录最后一位进位的位置，然后从第一项开始遍历，一旦遇到加上进位大于等于5的数就更新flag和k，遇到小于5的就把进位情况加上，然后恢复进位flag为false</p><p>然后将所有在最后一位进位的位置k后的数字全部标注成0，如果此时还有进位就把第一位从0标记成1，然后输出即可</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">ss</span><span class="params">(s.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        ss[i] = s[s.<span class="built_in">size</span>() - <span class="number">1</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    ss[s.<span class="built_in">size</span>()] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        <span class="keyword">if</span> (ss[i] + flag &gt;= <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ss[i] += flag;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i ++ ) ss[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) ss[s.<span class="built_in">size</span>()] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span> + flag; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; ss[i];</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Assembly-via-Minimums"><a href="#C-Assembly-via-Minimums" class="headerlink" title="C. Assembly via Minimums"></a><a href="https://codeforces.com/contest/1857/problem/C">C. Assembly via Minimums</a></h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>在数组a中选择任意两个个数的所有组合中，把两个数里较小的数形成数组b，现在给出数组b，求可能的一种数组a</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p><del>（怎么感觉这题比上一题简单！</del></p><p>先用个例子模拟我的思路过程——</p><p>数组b：7 5 3 5 3 3</p><p>统计每个数字出现的次数，按照数字从小到大排序，得到：<br>3 -&gt; 3<br>5 -&gt; 2<br>7 -&gt; 1</p><p>首先明确一点，在数组b中出现过的数字一定会在数组a中出现（因为数组b就是数组a中的元素组成的，这个应该很好理解）</p><p>从大到小看，7出现了1次，这1次是怎么得到的呢，一定是数组a中大于等于7的这一部分得到的（因为只要小于7，被保留到b中的数字就不会是7了）</p><p>我们设数组a中大于等于7的数字有n个，在这n个数字中两两组合，得到了数组b中的1个7，所以 $C_n^2&#x3D;1$，也就是 $\frac{n*(n-1)}{2}&#x3D;1$ ，解得 $n&#x3D;2$，也就是数组a中有2个数字大于等于7，（我们为了方便全部取7），把2个7存到数组a里</p><p>然后看第二个数5,数字5出现了2次，这2次一定是数组a中大于等于5的部分得到的</p><p>我们设数组a中大于等于5的数字有n个，在这n个数字中两两组合，得到了数组b中的2个5，所以 $C_n^2&#x3D;2$，也就是 $\frac{n*(n-1)}{2}&#x3D;2$ ，解得 $n&#x3D;3$，也就是数组a中有3个数字大于等于5，我们的数组a现在是{7,7}，已经有两个数字比5大了，所以再增加一个大于等于5的数字即可，（为了方便再加进去一个5）</p><p>然后看第三个数3,数字3出现了3次，这3次一定是数组a中大于等于3的部分得到的</p><p>我们设数组a中大于等于3的数字有n个，在这n个数字中两两组合，得到了数组b中的3个3，所以 $C_n^2&#x3D;3$，也就是 $\frac{n*(n-1)}{2}&#x3D;3$ ，解得 $n&#x3D;4$，也就是数组a中有4个数字大于等于3，我们的数组a现在是{7,7,5}，已经有3个数字比3大了，所以再增加一个大于等于3的数字即可，（为了方便再加进去一个3）</p><p>然后…结束了啊，输出a就可以啦</p><p><strong>具体实现步骤如下：</strong></p><p>统计b中每个数字出现的次数（用map统计，map的key代表数字的值，value代表数字出现的次数）（正好map可以按照key排序）</p><p>（key出现的次数也就代表着，&#x3D;&#x3D;<strong>原数组a中有多少元素大于等于 key</strong>&#x3D;&#x3D;，大于等于嘛，所以我们直接将原数组中大于等于key的值都赋为key就好了）</p><p>因为map会按照key从小到大排序，所以我们从后往前遍历map即可，对于当前的 key 来说，设原数组 $a$ 中有 $n$ 个元素&gt;&#x3D;key，因此会在b中形成 <strong>value 个 key</strong> 和 <strong>sum 个比 key 大的数</strong>（sum是数组b大于当前key的数字的个数），因此在 a 数组中就有 second+sum 个大于等于 first 的数，可以得到 $second+sum&#x3D;\frac{(n-1)<em>n}{2}$，这个式子里只有 n 是未知数，根据一元二次方程求解公式就可以得到 $n&#x3D;\frac{1+\sqrt{8</em>(sum+second)+1}}{2}$，所以就可以直接求出原数组中&gt;&#x3D; key的元素个数 n，目前原数组 a 中有 cnt 个数（且这 cnt 个数都是大于等于当前 key 的，因为我们是按照 key 从大到小遍历的），现在算出有 n 个数&gt;&#x3D; key，我们就把 cnt 到 n 这一段还没有填充的位置用当前的 key 填上即可，这样遍历到数组结束就可以得到一种可能的 a 了</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">((n - <span class="number">1</span>) * n / <span class="number">2</span>)</span></span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b; <span class="comment">// 统计每个数字出现了多少次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (n - <span class="number">1</span>) * n / <span class="number">2</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; temp[i];</span><br><span class="line">        <span class="keyword">if</span> (!b.<span class="built_in">count</span>(temp[i])) b[temp[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> b[temp[i]] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从后往前遍历map</span></span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::reverse_iterator it = b.<span class="built_in">rbegin</span>(); it != b.<span class="built_in">rend</span>(); it ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res = (<span class="number">1</span> + <span class="built_in">sqrt</span>(<span class="number">8</span> * (it-&gt;second + sum) + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = cnt; j &lt; res; j ++ ) ans[cnt ++ ] = it-&gt;first;</span><br><span class="line">        sum += it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="D-Strong-Vertices"><a href="#D-Strong-Vertices" class="headerlink" title="D. Strong Vertices"></a><a href="https://codeforces.com/contest/1857/problem/D">D. Strong Vertices</a></h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出两个数组 a 和 b，如果存在 $u, v$ 使得 $a_u-a_v&gt;&#x3D;b_u-b_v$，就说明 u 点可以到 v 点，如果一个点能到其他所有点就叫它 strong，现在问有多少点 strong ，分别是哪些点</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p><del>（是我的错觉吗怎么感觉这题更简单了啊喂</del></p><p>首先肯定是化简 $a_u-a_v&gt;&#x3D;b_u-b_v$，把它变成 $a_u-b_u&gt;&#x3D;a_v-b_v$，然后定义一个数组 c，$c_i&#x3D;a_i-b_i$，（c 中元素存pair&lt;int, int&gt;，first 存$a_i-b_i$，second 存 i），然后对 c 排序，由于差值较大的点可以连向差值较小的点，所以 first 越大的点能到达的点的数量就越多，而 first 最大的点就是所谓的 strong 点了</p><p>计算最大的first有多少个，输出他们的second即可</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;PII&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] = <span class="built_in">make_pair</span>(a[i] - b[i], i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n - <span class="number">1</span>) res.<span class="built_in">push_back</span>(c[i].second);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[i].first == c[i + <span class="number">1</span>].first) res.<span class="built_in">push_back</span>(c[i].second);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; res[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Power-of-Points"><a href="#E-Power-of-Points" class="headerlink" title="E. Power of Points"></a><a href="https://codeforces.com/contest/1857/problem/E">E. Power of Points</a></h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组，分别以数组中的每个元素为 s，统计 [s 与数组中每个元素形成的区间内][不同数字出现的次数之和]，输出以当前元素为 s 的结果</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这题也不难，显然的前缀和</p><p>首先排序！</p><p>想到把每个数作为 s，然后和数组中所有数形成区间，进行差分运算，但是这样时间复杂度就是O(n^2^)，显然会出问题</p><p>然后开始考虑，我们只需要所有元素出现的次数总和，并不需要某一个元素出现了多少次，所以直接拿大数减小数加1即可，举个例子说明吧：</p><p>排好序后的数组为 1 1 2 5 7<br>假设当前的 s &#x3D; 5<br>对于 5 之前的数，出现次数和是 5 * 3 - (1 + 1 + 2) + 3<br>对于 5 之后的数，出现次数和是 -5 * 1 + 7 + 1<br>还有 5 本身 出现次数和 1</p><p>按照这个思路，其中 5 前后的数可以用前缀和计算，这样整个算法的复杂度就是O(n)了</p><p>注意爆 int 0.0</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;i64, i64&gt; PII;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;PII&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i].first;</span><br><span class="line">        a[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    res[<span class="number">0</span>] = a[<span class="number">0</span>].first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ ) res[i] = res[i - <span class="number">1</span>] + a[i].first;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;PII&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) ans[i].second = i * a[i].first - res[i - <span class="number">1</span>] - (n - i - <span class="number">1</span>) * a[i].first + res[n - <span class="number">1</span>] - res[i] + n;</span><br><span class="line">        <span class="keyword">else</span> ans[i].second = i * a[i].first - (n - i - <span class="number">1</span>) * a[i].first + res[n - <span class="number">1</span>] - res[i] + n;</span><br><span class="line">        ans[i].first = a[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; ans[i].second &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cf】CodeForces Round 890（Div.2）题解 A - C</title>
      <link href="/posts/9d70cdf6.html"/>
      <url>/posts/9d70cdf6.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-Tales-of-a-Sort"><a href="#A-Tales-of-a-Sort" class="headerlink" title="A. Tales of a Sort"></a><a href="https://codeforces.com/contest/1856/problem/A">A. Tales of a Sort</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组，每次操作可以将 <strong>&#x3D;&#x3D;所有&#x3D;&#x3D;</strong> 元素 $a[i]$ 变成 $max(0,a_i-i)$，问至少操作多少次能将数组变成递增数组</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这一题卡很久，最后发现踩了两个坑</p><ol><li>题目读错了，每次操作会改变所有元素，而不是指定元素！</li><li>元素 $a[i]&gt;&#x3D;0$ ，不用考虑负数情况！</li></ol><p>我的思路是，另外开一个数组存储原数组排好序的结果，然后从后往前遍历两个数组，计算出原数组末尾有多少元素是已经排好序的，我们在操作的时候就可以不考虑这些元素，直接将未排序的部分全部变成 0 即可，答案就是未排序部分的最大值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = a;</span><br><span class="line">    <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 原数组末尾有多少元素已经有序</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; a[i] == b[i]) <span class="comment">// 原数组本身就有序</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[i]) cnt ++ ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = b[n - <span class="number">1</span> - cnt]; <span class="comment">// 答案就是无序部分的最大值</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Good-Arrays"><a href="#B-Good-Arrays" class="headerlink" title="B. Good Arrays"></a><a href="https://codeforces.com/contest/1856/problem/B">B. Good Arrays</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组a</p><p>如果数组b满足：</p><ul><li>ab的相同位上元素都不相等</li><li>ab数组元素的总和相等</li></ul><p>就称b是good数组</p><p>现在问是否存在一个good的数组b</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这题的思路超级简单，在输入数组a中元素的时候记录下<strong>数组a元素的总和<code>sum</code></strong> 和<strong>数组a中有多少个1</strong>，在数组a中是1的位置上，数组b能填的最小值是2，在数组a不是1的位置上，数组b能填的最小值是1，如果数组b能填的最小值的总和小于数组a元素的总和<code>sum</code>，就说明不存在这样的数组b，反之则存在</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    i64 sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        sum += x;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) res += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> res += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || res &gt; sum) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-To-Become-Max"><a href="#C-To-Become-Max" class="headerlink" title="C. To Become Max"></a><a href="https://codeforces.com/contest/1856/problem/C">C. To Become Max</a></h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组，每次操作可以把其中一个比它后方相邻元素小的元素加1，问最多 k 次操作后数组中的最大值是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p><strong>二分</strong>查找答案，首先可以确定答案的最小值<code>lb</code>就是原数组中的最大值（一次都不操作的情况下），答案的最大值<code>ub</code>就是原数组中最大值+最大操作次数（所有的操作次数全部用在了最大值上），每次取<code>mid = lb + ub &gt;&gt; 1</code>作为当前的最大值</p><p>然后从 0 到 n - 1 遍历每一个元素 $a[i]$，判断如果最后的数组中最大值是 $a[i]$ 的话，$a[i]$ 能否在 k 次操作内变成 $mid$</p><p>这应该怎么判断呢？</p><p>经过观察我们可以发现，对 $a[i]$ 进行操作的前提是 $a[i]&lt;&#x3D;a[i+1]$，所以想要让 $a[i]$ 变成 $mid$，$a[i+1]$ 至少要是 $mid-1$，$a[i+2]$ 至少要是 $mid - 2$，以此类推，$a[j]$ 至少要是 $mid-(j-i)$</p><ul><li>如果 $a[j]$ 满足条件也就是 $a[j]&gt;&#x3D;mid-(j-i)$，那么当前的 $a[i]$ 一定可以变成 $mid$，直接返回 true</li><li>如果 $a[j]&lt;mid-(j-i)$，那我们要想办法把 $a[j]$ 变成 $mid-(j-i)$，因此需要对 $a[j]$ 操作 $mid-(j-i)-a[j]$ 次，由于操作次数有限，如果此时我们剩余的操作次数不够了，就说明 $a[j]$ 不能变成我们想要的数，也就意味着 $a[i]$ 不能变成当前最大值 $mid$</li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> maxx = *<span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 找数组中最大值</span></span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; binary = [&amp;](<span class="type">int</span> goal)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 遍历每一个元素 把这个元素变成goal</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> rest = k; <span class="comment">// 还剩余的操作次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> require = goal - (j - i); <span class="comment">// 把a[i]变成goal需要把a[j]变成require</span></span><br><span class="line">                <span class="keyword">if</span> (require &lt;= a[j]) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果a[j]本来就比require大那肯定成立</span></span><br><span class="line">                <span class="type">int</span> need = <span class="built_in">max</span>(require - a[j], <span class="number">0</span>); <span class="comment">// a[j]需要操作的次数</span></span><br><span class="line">                <span class="keyword">if</span> (rest &lt; need) <span class="keyword">break</span>; <span class="comment">// 剩余操作次数不满足就不成立</span></span><br><span class="line">                rest -= need; <span class="comment">// 原来的操作次数的基础上减去当前步骤操作次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lb = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ub = maxx + k;</span><br><span class="line">    <span class="keyword">while</span> (lb &lt; ub)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = lb + ub + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">binary</span>(mid)) lb = mid; <span class="comment">// 答案在右侧</span></span><br><span class="line">        <span class="keyword">else</span> ub = mid - <span class="number">1</span>; <span class="comment">// 答案在左侧</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; lb &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cf】CodeForces Round 887（Div.2）题解 A - C</title>
      <link href="/posts/9e36a8f.html"/>
      <url>/posts/9e36a8f.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-Desorting"><a href="#A-Desorting" class="headerlink" title="A. Desorting"></a>A. Desorting</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个数列，每次操作可以把前一部分每个数加1，后一部分每个数减1，问至少操作多少次可以让数列非递增</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先遍历每一个数，如果有逆序的直接输出0</p><p>否则找到相邻元素最小的差值，最少的操作次数就是让这个最小的差值的两个元素变成逆序，除以2加1即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="type">int</span> l, r, minn = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] - a[i - <span class="number">1</span>] &lt; minn)</span><br><span class="line">            &#123;</span><br><span class="line">                minn = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">                l = i - <span class="number">1</span>, r = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = minn / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Fibonaccharsis"><a href="#B-Fibonaccharsis" class="headerlink" title="B. Fibonaccharsis"></a>B. Fibonaccharsis</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定斐波那契数列的第 k 项是 n，问存在多少这样的数列</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>设第一个数是 x，第二个数是 y<br>那么第三个数 <code>x + y</code> ，第四个数<code>x + 2 * y</code>，第五个数<code>2 * x + 3 * y</code>…<br>可以推出，x 的系数是 0 1 1 2 3 5 …，y 的系数是 1 1 2 3 5 8…<br>现有斐波那契数列（下标从1开始） 0 1 1 2 3 5 8…<br>那么 x 的系数 a 就是 <code>fib[i - 1]</code> y 的系数 b 就是<code>fib[i]</code><br>于是问题转换成了<code>a * x + b * y = n</code>，求xy有多少种取值情况，要求xy均为整数且 <code>x &lt;= y</code>，对 x 逐项枚举即可</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fib</span><span class="params">(<span class="number">31</span>)</span></span>;</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; init = [&amp;](<span class="type">void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fib[<span class="number">1</span>] = <span class="number">0</span>, fib[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">30</span>; i ++ )</span><br><span class="line">            fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">30</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        a = fib[k - <span class="number">1</span>], b = fib[k];</span><br><span class="line">        <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt;= n / <span class="number">2</span>; x ++ )</span><br><span class="line">            <span class="keyword">if</span> ((n - (a * x)) % b == <span class="number">0</span> &amp;&amp; (n - (a * x)) / b &gt;= x) ans ++ ;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Ntarsis’-Set"><a href="#C-Ntarsis’-Set" class="headerlink" title="C. Ntarsis’ Set"></a>C. Ntarsis’ Set</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>有个从1开始逐渐递增的集合，每次操作给出任意个位数，删去给出位数上的数字，得到新数列，现给出操作次数和每次操作删去的位数，求操作完后的第一位是几</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>从每一轮当前的第一位数字开始遍历，如果当前遍历到的这位数字位于<code>a[i]</code>和<code>a[i - 1]</code>之间，那么它的前 i 个位置都会被删去</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">LL a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    LL j = <span class="number">0</span>, ans = <span class="number">1</span>; <span class="comment">// ans表示目前的第一位 j表示截至目前已经处理过的位数</span></span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; a[j] &lt;= ans + j) j++;</span><br><span class="line">        ans += j; <span class="comment">// 更新该轮结束后的第一位，也就是该轮刚开始时的第一位加上该轮已处理过的位数</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cf】CodeForces Round 886（Div.4）题解</title>
      <link href="/posts/2acd301f.html"/>
      <url>/posts/2acd301f.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-To-My-Critics"><a href="#A-To-My-Critics" class="headerlink" title="A. To My Critics"></a>A. To My Critics</h1><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>签到题，问输入的三个数里较大两数之和是否大于等于10</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>存进数组然后排序，取较大的两个数相加和10比较</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">        cin &gt;&gt; a[<span class="number">0</span>] &gt;&gt; a[<span class="number">1</span>] &gt;&gt; a[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">sort</span>(a, a + <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] + a[<span class="number">2</span>] &gt;= <span class="number">10</span>) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Ten-Words-of-Wisdom"><a href="#B-Ten-Words-of-Wisdom" class="headerlink" title="B. Ten Words of Wisdom"></a>B. Ten Words of Wisdom</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>每组输入两个数，判断在第一个数小于等于10的情况下，最大的第二个数的序号</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>用<code>vector&lt;pari&lt;int, int&gt;&gt;</code>存数据，first存第二个输入的数，second存输入序号，当第一个数小于等于10时就将其存入，然后对vector排序，输出最大的第二个数的编号</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        vector&lt;PII&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= <span class="number">10</span>) a.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(y, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        cout &lt;&lt; a[a.<span class="built_in">size</span>() - <span class="number">1</span>].second + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Word-on-the-Paper"><a href="#C-Word-on-the-Paper" class="headerlink" title="C. Word on the Paper"></a>C. Word on the Paper</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>8x8的矩阵中，输出所有竖着排列的字符串</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>遍历整个矩阵，遇到非<code>.</code>时就将其和下方的所有非<code>.</code>元素输出</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">8010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> grid[N][<span class="number">8</span>];</span><br><span class="line"><span class="type">bool</span> st[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j ++ )</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k ++ )</span><br><span class="line">                cin &gt;&gt; grid[j][k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; !st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> h = i;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (h &lt; <span class="number">8</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[h][j] != <span class="string">&#x27;.&#x27;</span>) cout &lt;&lt; grid[h][j];</span><br><span class="line">                        h ++ ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Balanced-Round"><a href="#D-Balanced-Round" class="headerlink" title="D. Balanced Round"></a>D. Balanced Round</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出一串数字，可以任意交换他们的位置，要求删掉最小个数的数字，让连续的两个数字差值小于给定的 k</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>先从大到小排序，用dp做，<code>f[i][j]</code>表示在前 i 个数字内能选择的最大个数，j 表示第 i 个数有没有选，1表示选了，0表示没选，从前往后更新<code>f[i][j]</code>，<code>f[n][1]</code>和<code>f[n][0]</code>的较大值为能选择的最大数字个数，用总个数减去最大个数就是删去的最小个数</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] - a[i - <span class="number">1</span>] &lt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(f[n - <span class="number">1</span>][<span class="number">1</span>], f[n - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        cout &lt;&lt; n - ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Cardboard-for-Pictures"><a href="#E-Cardboard-for-Pictures" class="headerlink" title="E. Cardboard for Pictures"></a>E. Cardboard for Pictures</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>有一组已知边长的正方形，现在要将每个正方形的边长加上同一个w，问w是多少能满足所有新正方形的面积等于给定值c</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>一开始路走歪了…不知道怎么就去解一元二次方程去了，然后因为double的误差wa了<br>实际很简单~ 二分就可以啦~<br>首先利用倍增思想，把每个正方形边长都加上 2^j^，求出最小的 j 使总面积第一次大于 c<br>然后就在1到 j 之间二分求出 w</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        i64 n, sum;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; sum;</span><br><span class="line">        <span class="function">vector&lt;i64&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        i64 l = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i64 res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res += (a[i] + <span class="number">2</span> * r) * (a[i] + <span class="number">2</span> * r);</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= sum) <span class="keyword">break</span>;</span><br><span class="line">            r *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            i64 mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            i64 res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res += (a[i] + <span class="number">2</span> * mid) * (a[i] + <span class="number">2</span> * mid);</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= sum) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; r &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-We-Were-Both-Children"><a href="#F-We-Were-Both-Children" class="headerlink" title="F. We Were Both Children"></a>F. We Were Both Children</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>每个青蛙都可以跳到它弹跳能力的整数倍上，人能到达的最远距离是青蛙的个数，现在人要待在一个位置逮青蛙，问待在那个位置逮到的青蛙最多</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>先标记每个青蛙第一次跳到的位置，之后从后往前更新每个青蛙能跳到的小于 n 的位置，选择有最多青蛙能跳到的位置输出</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= n) cnt[a[i]] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i -- ) <span class="comment">// 从大到小遍历是为了防止前面的更新对后面产生影响</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * <span class="number">2</span>; j &lt;= n; j += i)</span><br><span class="line">                cnt[j] += cnt[i];</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; *<span class="built_in">max_element</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G-The-Morning-Star"><a href="#G-The-Morning-Star" class="headerlink" title="G. The Morning Star"></a>G. The Morning Star</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>从所有给的坐标里面选择两个坐标，一个放a，一个放b，这两个坐标要在同一条直线上</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>遍历给定的坐标，只要这个坐标同一行 &#x2F; 同一列 &#x2F; 对角线 &#x2F; 反对角线上有坐标，这个坐标就是可以选的，所以只要判断上面列举的四种情况有没有对应的坐标，有就加上，之后再更新遍历到的这个点<br>最后不要忘记*2，因为ab可以交换</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        map&lt;i64, <span class="type">int</span>&gt; a; <span class="comment">// 横</span></span><br><span class="line">        map&lt;i64, <span class="type">int</span>&gt; b; <span class="comment">// 竖</span></span><br><span class="line">        map&lt;i64, <span class="type">int</span>&gt; c; <span class="comment">// 对角线</span></span><br><span class="line">        map&lt;i64, <span class="type">int</span>&gt; d; <span class="comment">// 反对角线</span></span><br><span class="line">        i64 ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            i64 x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            ans += a[x] + b[y] + c[x - y] + d[x + y];</span><br><span class="line">            a[x] ++ ;</span><br><span class="line">            b[y] ++ ;</span><br><span class="line">            c[x - y] ++ ;</span><br><span class="line">            d[x + y] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans * <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="H-The-Third-Letter"><a href="#H-The-Third-Letter" class="headerlink" title="H. The Third Letter"></a>H. The Third Letter</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>给定士兵个数和信息条数，每条信息告诉两个士兵的相对位置，判断所有的信息是否矛盾</p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>把和每个点有关的信息存到vector&lt;pair&lt;int, int&gt;&gt;里面，存完后逐个士兵dfs判断是否矛盾</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n, q;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;i64&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">st</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        vector&lt;vector&lt;PII&gt;&gt; <span class="built_in">g</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            g[a].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(b, c));</span><br><span class="line">            g[b].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(a, -c));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u)</span><br><span class="line">        &#123;</span><br><span class="line">            st[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[u].<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = g[u][i].first;</span><br><span class="line">                <span class="type">int</span> w = g[u][i].second;</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[j] = d[u] + w;</span><br><span class="line">                    <span class="built_in">dfs</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (d[j] != d[u] + w) flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flag) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cf】Codeforces Round 885（ Div.2）题解 A - D</title>
      <link href="/posts/41048bc7.html"/>
      <url>/posts/41048bc7.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-Vika-and-Her-Friends"><a href="#A-Vika-and-Her-Friends" class="headerlink" title="A. Vika and Her Friends"></a>A. Vika and Her Friends</h1><p><a href="https://codeforces.com/contest/1848/problem/A">题目链接</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出矩形长宽，给出Vika所在地坐标，给出她的 k 个朋友所在地坐标，每一步他们可以到达与他们坐标相邻的地方，每轮 Vika 先走一步，她的每个朋友再走一步，如果有一轮结束后，她的任意一个朋友和她的位置重合，输出“NO”，否则输出“YES”</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过找规律可以发现，当 Vika 和另一个人的横竖坐标之差加起来是奇数，就不可能重合，偶数就一定有办法重合<br>但这里应该只判断偶数，只要 Vika 与他的任意一个朋友横竖坐标之差加起来是偶数，就一定会重合</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> H, V; cin &gt;&gt; H &gt;&gt; V;</span><br><span class="line">    <span class="type">int</span> k; cin &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> dist = <span class="built_in">abs</span>(a - x) + <span class="built_in">abs</span>(b - y);</span><br><span class="line">        <span class="keyword">if</span> (dist % <span class="number">2</span> == <span class="number">0</span>) flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Vika-and-the-Bridge"><a href="#B-Vika-and-the-Bridge" class="headerlink" title="B. Vika and the Bridge"></a>B. Vika and the Bridge</h1><p><a href="https://codeforces.com/contest/1848/problem/B">题目链接</a></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>有一条路的不同位置被涂上不同颜色，Vika 只能走同一种颜色（遇到不同颜色就跳过去），但是她可以改变路的任意一个位置的颜色（也可以不改变），问她怎么走能让跳跃的距离最短，输出最短的跳跃距离</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先记录所有颜色所在位置之间的差值，对这个数组排序<br>很容易理解，当我们选择这一种颜色时，会将改变距离最大的一段中点的颜色（如果这不是一段连续的颜色相同的路径的话），此时跳跃的最大距离即为<strong>距离最大的一段除以2</strong>和<strong>距离第二大的一段</strong>中更大的一个<br>所以我们选择每一种颜色需要跳跃的最大距离中最小的一个，输出即可</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">location</span>(k + <span class="number">1</span>); <span class="comment">// 每个颜色所在位置</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(k + <span class="number">1</span>); <span class="comment">// 每个颜色相隔距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ ) location[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">        location[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">        dist[x].<span class="built_in">push_back</span>(i - <span class="number">1</span> - location[x][location[x].<span class="built_in">size</span>() - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ )</span><br><span class="line">    dist[i].<span class="built_in">push_back</span>(n - location[i][location[i].<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ )</span><br><span class="line">    <span class="built_in">sort</span>(dist[i].<span class="built_in">begin</span>(), dist[i].<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="type">int</span> minn = <span class="number">0x3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> color = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ )</span><br><span class="line">    res[i] = <span class="built_in">max</span>(dist[i][<span class="number">0</span>] / <span class="number">2</span>, dist[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ )</span><br><span class="line">    minn = <span class="built_in">min</span>(minn, res[i]);</span><br><span class="line">    cout &lt;&lt; minn &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Vika-and-Price-Tags"><a href="#C-Vika-and-Price-Tags" class="headerlink" title="C. Vika and Price Tags"></a>C. Vika and Price Tags</h1><p><a href="https://codeforces.com/contest/1848/problem/C">题目链接</a></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出两个相同长度的数组 a 和 b，建立数组 c<br>每一轮操作将 a 和 b 每一项的差值赋给 c，再将 b 赋给 a，c 赋给 b<br>问多轮操作后能不能使 a 全部变为 0</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>直接循环肯定T，所以需要找到变化中的规律<br>单独看每一项，观察得到<strong>三轮一循环</strong>的规律：<br>我们将 a 数组的数记为 x，b 数组的数记为 y</p><ul><li>当 <code>x &gt;= 2 * y</code> ，经过三轮后，<code>x = x - 2 * y</code></li><li>当 <code>y &gt;= 2 * x</code> ，经过三轮后，<code>y = y - 2 * x</code></li></ul><p>当然，如果 x 一直大于 2 * y，那就会一直减下去，所以最后得到的其实是 <code>x % (2 * y)</code>，第二种情况也一样<br>进行上述两项操作直到不满足上面的任何一条时，我们再进行简单的求 x y 差值的步骤</p><p>由于三轮一循环，我们记录回合数时只用 0 - 2 记录，每进行一次求x y 差值的步骤时，就将回合数 + 1（其实是+1%3）</p><p>根据上面的思路，我们可以得到 a b 数组的每一位变为 0 时需要的回合数，当不同位上所需回合数不同时，就一定不能将 a 全变为 0</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span> &amp;&amp; b[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        PII pt = &#123;a[i], b[i]&#125;;</span><br><span class="line">        <span class="built_in">tie</span>(x, y) = pt;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> round = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">2</span> * y &amp;&amp; y != <span class="number">0</span>) x %= <span class="number">2</span> * y;</span><br><span class="line">            <span class="keyword">if</span> (y &gt;= <span class="number">2</span> * x &amp;&amp; x != <span class="number">0</span>) y %= <span class="number">2</span> * x;</span><br><span class="line">            <span class="built_in">tie</span>(x, y) = <span class="built_in">make_tuple</span>(y, <span class="built_in">abs</span>(x - y));</span><br><span class="line">            round = (round + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">-1</span> &amp;&amp; round != t)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t = round;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Vika-and-Bonuses"><a href="#D-Vika-and-Bonuses" class="headerlink" title="D. Vika and Bonuses"></a>D. Vika and Bonuses</h1><p><a href="https://codeforces.com/contest/1848/problem/D">题目链接</a></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定一个 s 和一个 k，每次可以进行如下两个操作中的一个：</p><ul><li>将 s 加上 s 最末尾的一个数字</li><li>将答案加上 s</li></ul><p>问在 k 次操作后答案的最大值是多少</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先明确一点，如果要进行操作1，那所有的操作1必须要在操作2之前进行<br>然后，我们可以找到规律，如果一直进行操作1，最后一定会陷入循环0、0…或者2、4、8、6、…</p><p>先处理陷入循环0、0、…的情况，如果末尾数字是5，直接先进行一轮操作1，让末尾变为0，之后全部进行操作2<br>然后处理陷入循环2、4、8、6、…的情况，记2 4 8 6为一次循环，设经过 x 次循环答案最大（每次循环可以让 s 增加 20），输出的答案则为<code>ans = (s + 20 * x) * (k - 4 * x)</code>，整理后得到<code>ans = -80 * x^2 + (20 * k - 4 * s) * x + s * k</code>，转换成了求一元二次函数最大值的问题，直接求解即可</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">cle</span><span class="params">(i64 n, i64 k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i64 ans = n * k;</span><br><span class="line"></span><br><span class="line">    i64 a, b, c; <span class="comment">// 系数</span></span><br><span class="line">a = <span class="number">-80</span>;</span><br><span class="line">b = <span class="number">20</span> * k - <span class="number">4</span> * n;</span><br><span class="line">c = n * k;</span><br><span class="line"></span><br><span class="line">i64 x = -b / (<span class="number">2</span> * a);</span><br><span class="line">x = <span class="built_in">min</span>(x, k / <span class="number">4</span>); <span class="comment">// x不能大于 k / 4;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, a * x * x + b * x + c);</span><br><span class="line">    <span class="comment">// 因为x取了整数，所以x + 1和x - 1都检查一下</span></span><br><span class="line">x = <span class="built_in">min</span>(x + <span class="number">1</span>, k / <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, a * x * x + b * x + c);</span><br><span class="line">    x -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, a * x * x + b * x + c);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i64 n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    i64 ans = n * k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">10</span> == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n += <span class="number">5</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, n * (k - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">10</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n += n % <span class="number">10</span>;</span><br><span class="line">            k -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">cle</span>(n, k));</span><br><span class="line">            k -- ;</span><br><span class="line">            n += n % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cf】Codeforces Round 883（Div.3）题解 A - E1</title>
      <link href="/posts/e62cb5ef.html"/>
      <url>/posts/e62cb5ef.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-Rudolph-and-Cut-the-Rope"><a href="#A-Rudolph-and-Cut-the-Rope" class="headerlink" title="A. Rudolph and Cut the Rope"></a>A. Rudolph and Cut the Rope</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>签到题，就是看有多少个钉子上系的绳子长度比钉子高度短</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; a) ans ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Rudolph-and-Tic-Tac-Toe"><a href="#B-Rudolph-and-Tic-Tac-Toe" class="headerlink" title="B. Rudolph and Tic-Tac-Toe"></a>B. Rudolph and Tic-Tac-Toe</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你 3x3 网格的结果，问什么图案在行列或对角线一样，如果是“.”或者都没有就输出“DRAW”</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>没想出啥好办法，暴力做了<br>（555代码被hack了我是大傻子…记得有三个“.”同排和三个其他字符同排时取其他字符！！</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n;</span><br><span class="line"><span class="type">char</span> a[<span class="number">4</span>], b[<span class="number">4</span>], c[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ ) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ ) cin &gt;&gt; c[i];</span><br><span class="line"><span class="comment">// 判断列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[i] &amp;&amp; b[i] == c[i])</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 判断行</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] == a[<span class="number">1</span>] &amp;&amp; a[<span class="number">1</span>] == a[<span class="number">2</span>])</span><br><span class="line">   <span class="keyword">if</span> (a[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (b[<span class="number">0</span>] == b[<span class="number">1</span>] &amp;&amp; b[<span class="number">1</span>] == b[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">if</span> (b[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; b[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (c[<span class="number">0</span>] == c[<span class="number">1</span>] &amp;&amp; c[<span class="number">1</span>] == c[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">if</span> (c[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; c[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 判断对角线</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">1</span>] &amp;&amp; a[<span class="number">0</span>] == c[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">2</span>] == b[<span class="number">1</span>] &amp;&amp; b[<span class="number">1</span>] == c[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">2</span>] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DRAW&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Rudolf-and-the-Another-Competition"><a href="#C-Rudolf-and-the-Another-Competition" class="headerlink" title="C. Rudolf and the Another Competition"></a>C. Rudolf and the Another Competition</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出算竞中的参赛人数、题数、时间和每一位选手做出每一题所需要的时间，求第一位选手最终排名</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>算出每一位选手的过题数和罚时，得出第一位选手排名<br>注意罚时要记得开 long long &#x2F; 痛</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n, m, h;</span><br><span class="line"><span class="type">int</span> s[N], num[N];</span><br><span class="line">LL pa[N]; <span class="comment">// 罚时</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span> num);</span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">0</span>, <span class="keyword">sizeof</span> pa);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ ) cin &gt;&gt; s[j];</span><br><span class="line">        <span class="built_in">sort</span>(s, s + m);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 选手用时</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            sum += s[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; h) <span class="keyword">break</span>;</span><br><span class="line">            num[i] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num[i]; j ++ ) pa[i] += (num[i] - j) * s[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> place = <span class="number">1</span>; <span class="comment">// 目前排名，每出现一位比他成绩好的就将排名++</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] &gt; num[<span class="number">0</span>]) place ++ ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[i] == num[<span class="number">0</span>] &amp;&amp; pa[i] &lt; pa[<span class="number">0</span>]) place ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; place &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Rudolph-and-Christmas-Tree"><a href="#D-Rudolph-and-Christmas-Tree" class="headerlink" title="D. Rudolph and Christmas Tree"></a>D. Rudolph and Christmas Tree</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一个等腰三角形大小，给出三角形底边高度，问重叠之后总面积</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>从下到上遍历每个三角形，后一个三角形覆盖了前一个就计算未被覆盖的面积，没覆盖就计算等腰三角形总面积，相加得出结果<br>（但这里本人犯了一个超级无敌蠢的错误导致wa了，浮点型除法乘1.0记得放在式子最开头哇！！</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n, d, h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d &gt;&gt; h;</span><br><span class="line">    <span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    cin &gt;&gt; temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="type">int</span> x = a - temp;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; h)</span><br><span class="line">            s += <span class="number">1.0</span> * (<span class="number">2</span> * d - <span class="number">1.0</span> * d * x  / h) * x / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s += <span class="number">1.0</span> * d * h / <span class="number">2</span>;</span><br><span class="line">        temp = a;</span><br><span class="line">    &#125;</span><br><span class="line">    s += <span class="number">1.0</span> * d * h/ <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E1-Rudolf-and-Snowflakes-simple-version"><a href="#E1-Rudolf-and-Snowflakes-simple-version" class="headerlink" title="E1. Rudolf and Snowflakes (simple version)"></a>E1. Rudolf and Snowflakes (simple version)</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>雪花的构成：中间一个点，这个点可以向旁边发出 k （&gt;&#x3D;2）个点，发出的点又可以向外发出 k 个点，以此类推，问给定数目的点能不能构成一片雪花</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>点的个数一定要是 1 + x + x^2^ + x^3^ + …<br>遍历所有的 x ，直到大于给定数目</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        LL sum = <span class="number">1</span> + i + i * i;</span><br><span class="line">        LL temp = i * i;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (sum &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            temp *= i;</span><br><span class="line">            sum += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == n)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cf】Codeforces Round 882（Div.2）题解 A - C</title>
      <link href="/posts/86adcfdb.html"/>
      <url>/posts/86adcfdb.html</url>
      
        <content type="html"><![CDATA[<h1 id="A-The-Man-who-became-a-God"><a href="#A-The-Man-who-became-a-God" class="headerlink" title="A. The Man who became a God"></a>A. The Man who became a God</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>把一个长度为 n 的数组分成 k 段，要求每一段中相邻元素差值之和相加起来最小</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把相邻元素的差值全部算出来排序，因为可以分成 k 段，中间有（k - 1）个间隔，所以删去最大的（k - 1）个，输出其余元素的和</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n, k;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">b.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ ) b.<span class="built_in">push_back</span>(<span class="built_in">abs</span>(a[i] - a[i - <span class="number">1</span>]));</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - k; i ++ ) ans += b[i];</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t -- )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Hamon-Odyssey"><a href="#B-Hamon-Odyssey" class="headerlink" title="B. Hamon Odyssey"></a>B. Hamon Odyssey</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>把一个长度为 n 的数组分成任意段，要求每一段取 &amp; 的值相加最小，输出可以分成的最大段数</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>看整个数组能分成多少个取 &amp; 为 0 的段，每出现一段为 0 的就将 ans + 1，如果整段取 &amp; 都不为 0 就输出 1</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) temp = a[i];</span><br><span class="line">        <span class="keyword">else</span> temp = a[i] &amp; temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) ans ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>) ans = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Vampiric-Powers-anyone"><a href="#C-Vampiric-Powers-anyone" class="headerlink" title="C. Vampiric Powers, anyone?"></a>C. Vampiric Powers, anyone?</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>在数组中每次取最后任意长度的子序列，求异或和，将这个值加到数列末尾，求任意次操作后能加到末尾的最大值是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>（思路参考了榜单第一的代码<br>任意长度子序列都可以通过给定操作消去<br>比如说结尾两个数是 1, 2，只要在后面添上 1, 2 的异或和，就可以消去结尾的 1, 2 对新添加的数产生的影响<br>根据这个性质，题目就转换成，数列中任意元素异或和的最大值</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; X;</span><br><span class="line">    X.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> curr_xor = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">curr_xor ^= a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : X) ans = <span class="built_in">max</span>(ans, curr_xor ^ x);</span><br><span class="line">X.<span class="built_in">insert</span>(curr_xor);</span><br><span class="line">     &#125;</span><br><span class="line"> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t -- )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】迭代器的用法总结</title>
      <link href="/posts/23b17bb1.html"/>
      <url>/posts/23b17bb1.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>可以简单理解成<strong>指针</strong><br>定义：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">container&lt;type&gt;::iterator it;</span><br></pre></td></tr></table></figure><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>可以分成<strong>输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器</strong><br>这里只介绍使用较多的<strong>双向迭代器</strong>和<strong>随机访问迭代器</strong><br>双向迭代器和随机访问迭代器都可以进行 ++、–、&#x3D;&#x3D;、!&#x3D; 的运算，但随机访问迭代器还可以进行&lt;、&gt;、+&#x3D;x、-&#x3D;x 的运算<br><strong>举个栗子</strong><br>遍历容器时，双向迭代器和随机访问迭代器都可以使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it ++ )</span><br></pre></td></tr></table></figure><p>只有随机访问迭代器可以使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it ++ )</span><br><span class="line"><span class="keyword">for</span> (it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it += <span class="number">1</span> )</span><br></pre></td></tr></table></figure><p>且只有随机访问迭代器支持下标运算符，也就是把数据容器当做数组这种表示方式（e.g. a[3]）</p><ul><li>随机访问迭代器：vector、deque</li><li>双向迭代器：set &#x2F; multiset、list、map &#x2F; multimap</li><li>不支持迭代器：stack、queue</li></ul><h1 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h1><h2 id="advance（it，-n）"><a href="#advance（it，-n）" class="headerlink" title="advance（it， n）"></a>advance（it， n）</h2><p>将迭代器 it 向后移动 n 位（n 可以是负数）</p><h2 id="distance（it1，-it2）"><a href="#distance（it1，-it2）" class="headerlink" title="distance（it1， it2）"></a>distance（it<del>1</del>， it<del>2</del>）</h2><p>输出it<del>1</del>、it<del>2</del>之间的距离</p><h2 id="iter-swap（it1-it2）"><a href="#iter-swap（it1-it2）" class="headerlink" title="iter_swap（it1,  it2）"></a>iter_swap（it<del>1</del>,  it<del>2</del>）</h2><p>交换it<del>1</del>、it<del>2</del>指向的值</p><h1 id="特殊的迭代器"><a href="#特殊的迭代器" class="headerlink" title="特殊的迭代器"></a>特殊的迭代器</h1><h2 id="begin-和-end"><a href="#begin-和-end" class="headerlink" title="begin() 和 end()"></a>begin() 和 end()</h2><p>返回 iterator<br><strong>begin()：</strong>返回一个指向容器第一个元素位置的指针<br><strong>end()：</strong>返回一个指向容器最后一个元素后一个位置的指针<br>可以利用 *(container.begin()) 来修改容器中的元素</p><h2 id="cbegin-和-cend"><a href="#cbegin-和-cend" class="headerlink" title="cbegin() 和 cend()"></a>cbegin() 和 cend()</h2><p>返回 const_iterator<br><strong>cbegin()：</strong>返回一个指向容器第一个元素位置的指针<br><strong>cend()：</strong>返回一个指向容器最后一个元素后一个位置的指针<br>const <strong>不</strong>可以利用 *(container.cbegin()) 来修改容器中的元素</p><h2 id="rbegin-和-rend"><a href="#rbegin-和-rend" class="headerlink" title="rbegin() 和 rend()"></a>rbegin() 和 rend()</h2><p>逆序迭代器 返回 iterator<br><strong>rbegin()：</strong>返回一个指向容器最后一个元素位置的指针<br><strong>rend()：</strong>返回一个指向容器第一个元素前一个位置的指针<br>可以利用 *(container.rbegin()) 来修改容器中的元素</p><h2 id="crbegin-和-crend"><a href="#crbegin-和-crend" class="headerlink" title="crbegin() 和 crend()"></a>crbegin() 和 crend()</h2><p>const 修饰的逆序迭代器 返回 const_iterator<br><strong>crbegin()：</strong>返回一个指向容器最后一个元素位置的指针<br><strong>crend()：</strong>返回一个指向容器第一个元素前一个位置的指针<br>const <strong>不</strong>可以利用 *(container.crbegin()) 来修改容器中的元素</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> C++ </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划】最长上升子序列LIS</title>
      <link href="/posts/2ec3d24c.html"/>
      <url>/posts/2ec3d24c.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题的开始：最长上升子序列"><a href="#问题的开始：最长上升子序列" class="headerlink" title="问题的开始：最长上升子序列"></a>问题的开始：最长上升子序列</h1><p><a href="https://www.acwing.com/problem/content/897/">原题链接</a></p><p>给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</p><p><strong>输入格式</strong></p><p>第一行包含整数 N。</p><p>第二行包含 N 个整数，表示完整序列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大长度。</p><p><strong>数据范围</strong></p><p>$1≤N≤1000，$<br>$−109≤数列中的数≤109$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><img src="/posts/2ec3d24c/4.png" class><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="怪盗基德的滑翔翼"><a href="#怪盗基德的滑翔翼" class="headerlink" title="怪盗基德的滑翔翼"></a>怪盗基德的滑翔翼</h1><p><a href="https://www.acwing.com/problem/content/1019/">原题链接</a></p><p>怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。</p><p>而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。</p><p>有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。</p><p>不得已，怪盗基德只能操作受损的滑翔翼逃脱。</p><p>假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。</p><p>初始时，怪盗基德可以在任何一幢建筑的顶端。</p><p>他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。</p><p>因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。</p><p>他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。</p><p>请问，他最多可以经过多少幢不同建筑的顶部(包含初始时的建筑)？</p><p><strong>输入格式</strong></p><p>输入数据第一行是一个整数K，代表有K组测试数据。</p><p>每组测试数据包含两行：第一行是一个整数N，代表有N幢建筑。第二行包含N个不同的整数，每一个对应一幢建筑的高度h，按照建筑的排列顺序给出。</p><p><strong>输出格式</strong></p><p>对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。</p><p><strong>数据范围</strong></p><p>$1≤K≤100,$<br>$1≤N≤100,$<br>$0&lt;h&lt;10000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">300</span> <span class="number">207</span> <span class="number">155</span> <span class="number">299</span> <span class="number">298</span> <span class="number">170</span> <span class="number">158</span> <span class="number">65</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">65</span> <span class="number">158</span> <span class="number">170</span> <span class="number">298</span> <span class="number">299</span> <span class="number">155</span> <span class="number">207</span> <span class="number">300</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一排楼房，怪盗基德可以选择任意一个开始，只能往一个方向跳到比当前所在楼房低的楼房，问他最多能跳多少楼房</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>因为只能往一个方向跳，做两个方向的最长上升子序列即可</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 正向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[j]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt; i; j -- )</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[j]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="登山"><a href="#登山" class="headerlink" title="登山"></a>登山</h1><p><a href="https://www.acwing.com/problem/content/1016/">原题链接</a></p><p>五一到了，ACM队组织大家去登山观光，队员们发现山上一共有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。</p><p>同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。</p><p>队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？</p><p><strong>输入格式</strong></p><p>第一行包含整数N，表示景点数量。</p><p>第二行包含N个整数，表示每个景点的海拔。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最多能浏览的景点数。</p><p><strong>数据范围</strong></p><p>$2≤N≤1000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">186</span> <span class="number">186</span> <span class="number">150</span> <span class="number">200</span> <span class="number">160</span> <span class="number">130</span> <span class="number">197</span> <span class="number">220</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一群人浏览几个景点，满足以下规则：</p><ul><li>按照编号递增顺序浏览</li><li>相邻两景点高度不能相同</li><li>一旦开始下降就不能上升了</li></ul><p>目标：最多浏览多少景点</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>条件1：必须是子序列<br>条件2、3：路径形状先上升再下降</p><p>目标：求所有形状满足要求的子序列长度最大值</p><p>上升选择什么不影响我们下降时选择什么，因此两段完全独立，分别求出从左往右和从右往左的上升子序列最大值，求出<code>f[i] + g[i] - 1</code>即可</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], g[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        g[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt; i; j -- )</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) g[i] = <span class="built_in">max</span>(g[i], g[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[i] + g[i] - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="友好城市"><a href="#友好城市" class="headerlink" title="友好城市"></a>友好城市</h1><p><a href="https://www.acwing.com/problem/content/1014/">原题链接</a></p><p>Palmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。</p><p>北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。</p><p>每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。</p><p>编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。</p><p><strong>输入格式</strong></p><p>第1行，一个整数N，表示城市数。</p><p>第2行到第n+1行，每行两个整数，中间用1个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。</p><p><strong>输出格式</strong></p><p>仅一行，输出一个整数，表示政府所能批准的最多申请数。</p><p><strong>数据范围</strong></p><p>$1≤N≤5000,$<br>$0≤x_i≤10000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">22</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">15</span> <span class="number">12</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span></span><br><span class="line"><span class="number">17</span> <span class="number">17</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>河的南北两岸有很多城市，友好城市之间可以建桥，满足以下原则：</p><ul><li>条件1：每个城市只能建一座桥</li><li>条件2：桥与桥间不能相交</li><li>条件3：只能在友好城市间建桥</li></ul><p>目标：最多建多少桥</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>题目直接转化成给出多条边，选择最多的边数两边不相交</p><p>按下面自变量大小排序，只要上面的自变量是上升子序列，就一定满足情况</p><img src="/posts/2ec3d24c/2.png" class><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">PII q[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i].first &gt;&gt; q[i].second;</span><br><span class="line">    <span class="built_in">sort</span>(q, q + n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (q[i].second &gt; q[j].second) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拦截导弹"><a href="#拦截导弹" class="headerlink" title="拦截导弹"></a>拦截导弹</h1><p><a href="https://www.acwing.com/problem/content/1012/">原题链接</a></p><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。</p><p>但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。</p><p>某天，雷达捕捉到敌国的导弹来袭。</p><p>由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p><p>输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数，导弹数不超过1000），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p><p><strong>输入格式</strong></p><p>共一行，输入导弹依次飞来的高度。</p><p><strong>输出格式</strong></p><p>第一行包含一个整数，表示最多能拦截的导弹数。</p><p>第二行包含一个整数，表示要拦截所有导弹最少要配备的系统数。</p><p><strong>数据范围</strong></p><p>雷达给出的高度数据是不大于 30000 的正整数，导弹数不超过 1000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">389</span> <span class="number">207</span> <span class="number">155</span> <span class="number">300</span> <span class="number">299</span> <span class="number">170</span> <span class="number">158</span> <span class="number">65</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出一个序列代表不同导弹高度，导弹拦截系统每次只能拦截比上一次拦截的导弹低的</p><p>第一问：一次最多拦截多少个导弹<br>第二问：需要多少拦截系统才能把所有导弹拦截</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>第一问：就是求最长下降子序列</p><p>第二问：<strong>贪心</strong>，用样例说明</p><p>389 207 155 300 299 170 158 65<br>首先389一定要新开一个系统<br>然后207有两个选择：<br>（1）接在现有的某个系统序列之后<br>（2）创建一个新系统<br>直觉思路：<br>要使得每个子序列的末尾最大（这样之后就能接上更大的数）</p><p>流程：<br>从前往后扫描每个数，对于每个数：</p><ul><li>情况1: 如果现有的子序列的结尾都小于当前数，则创建新子序列</li><li>情况2: 将当前数放到结尾大于等于它的最小的子序列后面</li></ul><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; q[n]) n ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (q[j] &gt;= q[i]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; cnt &amp;&amp; g[k] &lt; q[i]) k ++; <span class="comment">// g[i]存储第i个子序列末尾的数</span></span><br><span class="line">        g[k] = q[i];</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= cnt) cnt ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="导弹防御系统"><a href="#导弹防御系统" class="headerlink" title="导弹防御系统"></a>导弹防御系统</h1><p><a href="https://www.acwing.com/problem/content/189/">原题链接</a></p><p>为了对抗附近恶意国家的威胁，R 国更新了他们的导弹防御系统。</p><p>一套防御系统的导弹拦截高度要么一直<strong>严格单调</strong>上升要么一直<strong>严格单调</strong>下降。</p><p>例如，一套系统先后拦截了高度为 3 和高度为 4 的两发导弹，那么接下来该系统就只能拦截高度大于 4 的导弹。</p><p>给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。</p><p><strong>输入格式</strong></p><p>输入包含多组测试用例。</p><p>对于每个测试用例，第一行包含整数 n，表示来袭导弹数量。</p><p>第二行包含 n 个不同的整数，表示每个导弹的高度。</p><p>当输入测试用例 n&#x3D;0 时，表示输入终止，且该用例无需处理。</p><p><strong>输出格式</strong></p><p>对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。</p><p><strong>数据范围</strong></p><p>$1≤n≤50$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> </span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>样例解释</strong></p><p>对于给出样例，最少需要两套防御系统。</p><p>一套击落高度为 3,4 的导弹，另一套击落高度为 5,2,1 的导弹。</p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>和拦截导弹的区别就是，有两种拦截系统，一种只能越拦越高，一种只能越拦越低</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p><strong>贪心+dfs爆搜</strong></p><p>每次需要判断放到第一类系统还是第二类系统，所以只能用爆搜做</p><p>（定义全局变量实时更新or迭代加深都可以做</p><p>详见下方代码</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N], h[N];</span><br><span class="line"><span class="type">int</span> up[N], down[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// todo 下方做法为更新全局最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> su, <span class="type">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (su + sd &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = su + sd;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上升</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; su &amp;&amp; up[k] &gt;= q[u]) k ++ ;</span><br><span class="line">    <span class="type">int</span> temp = up[k];</span><br><span class="line">    up[k] = q[u];</span><br><span class="line">    <span class="keyword">if</span> (k &lt; su) <span class="built_in">dfs</span>(u + <span class="number">1</span>, su, sd);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, su + <span class="number">1</span>, sd);</span><br><span class="line">    up[k] = temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下降</span></span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; sd &amp;&amp; down[k] &lt;= q[u]) k ++ ;</span><br><span class="line">    temp = down[k];</span><br><span class="line">    down[k] = q[u];</span><br><span class="line">    <span class="keyword">if</span> (k &lt; sd) <span class="built_in">dfs</span>(u + <span class="number">1</span>, su, sd);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, su, sd + <span class="number">1</span>);</span><br><span class="line">    down[k] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">        ans = n;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// todo 下方做法为迭代加深</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> u, <span class="type">int</span> su, <span class="type">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (su + sd &gt; depth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= su; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (up[i] &lt; h[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = up[i];</span><br><span class="line">            up[i] = h[u];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth, u + <span class="number">1</span>, su, sd)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            up[i] = t;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    up[su + <span class="number">1</span>] = h[u];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth, u + <span class="number">1</span>, su + <span class="number">1</span>, sd)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sd; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (down[i] &gt; h[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = down[i];</span><br><span class="line">            down[i] = h[u];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth, u + <span class="number">1</span>, su, sd)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            down[i] = t;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    down[sd + <span class="number">1</span>] = h[u];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth, u + <span class="number">1</span>, su, sd + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; h[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">dfs</span>(depth, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) depth ++ ;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; depth &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长公共上升子序列"><a href="#最长公共上升子序列" class="headerlink" title="最长公共上升子序列"></a>最长公共上升子序列</h1><p><a href="https://www.acwing.com/problem/content/274/">原题链接</a></p><p>熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。</p><p>小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。</p><p>小沐沐说，对于两个数列 A 和 B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。</p><p>奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。</p><p>不过，只要告诉奶牛它的长度就可以了。</p><p>数列 A 和 B 的长度均不超过 3000。</p><p><strong>输入格式</strong></p><p>第一行包含一个整数 N，表示数列 A，B 的长度。</p><p>第二行包含 N 个整数，表示数列 A。</p><p>第三行包含 N 个整数，表示数列 B。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最长公共上升子序列的长度。</p><p><strong>数据范围</strong></p><p>$1≤N≤3000$,序列中的数字均不超过 $2^{31}−1$。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>找两个序列的最长公共上升子序列</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><img src="/posts/2ec3d24c/1.png" class><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> maxx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], maxx);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; b[j]) maxx = <span class="built_in">max</span>(maxx, f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
            <tag> 最长上升子序列 </tag>
            
            <tag> LIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划】数字三角形</title>
      <link href="/posts/bb05dd2a.html"/>
      <url>/posts/bb05dd2a.html</url>
      
        <content type="html"><![CDATA[<img src="/posts/bb05dd2a/3.png" class><h1 id="摘花生"><a href="#摘花生" class="headerlink" title="摘花生"></a>摘花生</h1><p><a href="https://www.acwing.com/problem/content/1017/">题目链接</a></p><p>Hello Kitty想摘点花生送给她喜欢的米老鼠。</p><p>她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。</p><p>地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。</p><p>Hello Kitty只能向东或向南走，不能向西或向北走。</p><p>问Hello Kitty最多能够摘到多少颗花生。</p><img src="/posts/bb05dd2a/2.png" class><p><strong>输入格式</strong></p><p>第一行是一个整数T，代表一共有多少组数据。</p><p>接下来是T组数据。</p><p>每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。</p><p>每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。</p><p><strong>输出格式</strong></p><p>对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。</p><p><strong>数据范围</strong></p><p>$1≤T≤100,$<br>$1≤R,C≤100,$<br>$0≤M≤1000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>从左上角走到右下角，求走过的交点最大权值和</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><code>f[i][j]</code>表示到达（i，j）点权重的最大值</p><p>因为只能向右走或向下走，所以到达（i，j）点的方式一定是：从左边的点向右走一步 &#x2F; 从上面的点向下走一步</p><p>而左边的点权重最大值是<code>f[i][j-1]</code>，上面的点权重最大值是<code>f[i-1][j]</code>，从中取较大的，加上自身权值即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">                cin &gt;&gt; w[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]) + w[i][j];</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; f[n][m] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最低通行费"><a href="#最低通行费" class="headerlink" title="最低通行费"></a>最低通行费</h1><p><a href="https://www.acwing.com/problem/content/1020/">原题链接</a></p><p>一个商人穿过一个 $N×N$ 的正方形的网格，去参加一个非常重要的商务活动。</p><p>他要从网格的左上角进，右下角出。</p><p>每穿越中间 1 个小方格，都要花费 1 个单位时间。</p><p>商人必须在 $(2N−1)$ 个单位时间穿越出去。</p><p>而在经过中间的每个小方格时，都需要缴纳一定的费用。</p><p>这个商人期望在规定时间内用最少费用穿越出去。</p><p>请问至少需要多少费用？</p><p>注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。</p><p><strong>输入格式</strong></p><p>第一行是一个整数，表示正方形的宽度 $N$。</p><p>后面 $N$ 行，每行 $N$ 个不大于 100 的正整数，为网格上每个小方格的费用。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示至少需要的费用。</p><p><strong>数据范围</strong></p><p>$1≤N≤100$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">10</span></span><br><span class="line"><span class="number">2</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">15</span> <span class="number">17</span></span><br><span class="line"><span class="number">6</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">18</span> <span class="number">20</span></span><br><span class="line"><span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">19</span> <span class="number">21</span></span><br><span class="line"><span class="number">20</span> <span class="number">23</span> <span class="number">25</span> <span class="number">29</span> <span class="number">33</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">109</span></span><br></pre></td></tr></table></figure><p><strong>样例解释</strong></p><p>样例中，最小值为 $109&#x3D;1+2+5+7+9+12+19+21+33$。</p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>从左上角走到右下角，不超过2n-1步，求权重之和最小值</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>和上一题一样，都是左上角走到右下角</p><p>步数不超过2n-1，翻译过来就是不走回头路</p><p>只是把最大值改成了最小值</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) f[i][j] = w[i][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = -inf;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">1</span>) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j] + w[i][j]);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span>) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][j - <span class="number">1</span>] + w[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方格取数"><a href="#方格取数" class="headerlink" title="方格取数"></a>方格取数</h1><p><a href="https://www.acwing.com/problem/content/1029/">题目链接</a></p><p>设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：</p><img src="/posts/bb05dd2a/1.png" class><p>某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。</p><p>在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。</p><p>此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。</p><p><strong>输入格式</strong></p><p>第一行为一个整数$N$，表示 $N×N$ 的方格图。</p><p>接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。</p><p>行和列编号从 1 开始。</p><p>一行“0 0 0”表示结束。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示两条路径上取得的最大的和。</p><p><strong>数据范围</strong></p><p>$N≤10$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">13</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">14</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">21</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">15</span></span><br><span class="line"><span class="number">7</span> <span class="number">2</span> <span class="number">14</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">67</span></span><br></pre></td></tr></table></figure><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>矩阵中有数，从左上角走到右下角，走两次，求权重最大值之和</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>摘花生问题的扩展版：走一次变成走两次</p><p>类比推广：<code>f[i1][j1][i2][j2]</code>表示所有从（1,1）分别走到（i1，j1）（i2，j2）路径的最大值</p><p>如何处理同一个格子不被重复选择呢？</p><p>因为从左上角走到右下角，走的步数都是一样的，所以<code>i1 + j1 == i2 + j2</code>一定成立</p><p>所以我们可以将<code>f[i1][j1][i2][j2]</code>降维为<code>f[k][i1][i2]</code>，k就是当前走过的步数</p><p><code>f[k][i1][i2]</code>怎么计算呢？</p><p>分为四种情况：</p><ol><li>第一条线路最后一步向下，第二条线路最后一步向下<code>f[k - 1][i1 - 1][i2 - 1]</code></li><li>第一条线路最后一步向下，第二条线路最后一步向右<code>f[k - 1][i1 - 1][i2]</code></li><li>第一条线路最后一步向右，第二条线路最后一步向下<code>f[k - 1][i1][i2 - 1]</code></li><li>第一条线路最后一步向右，第二条线路最后一步向右<code>f[k - 1][i1][i2]</code></li></ol><p>然后判断（i1，j1）和（i2，j2）是否重合，重合只用加 <code>w[i1][j1]</code>，不重合需要加<code>w[i1][j1] + w[i2][j2]</code></p><p>取最大值即可</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> f[N * <span class="number">2</span>][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c) w[a][b] = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt;= n * <span class="number">2</span>; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i1 = <span class="number">1</span>; i1 &lt;= n; i1 ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i2 = <span class="number">1</span>; i2 &lt;= n; i2 ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j1 = k - i1, j2 = k - i2;</span><br><span class="line">                <span class="keyword">if</span> (j1 &gt;= <span class="number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="number">1</span> &amp;&amp; j2 &lt;= n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> t = w[i1][j1];</span><br><span class="line">                    <span class="keyword">if</span> (i1 != i2) t += w[i2][j2];</span><br><span class="line">                    <span class="type">int</span> &amp;x = f[k][i1][i2];</span><br><span class="line"></span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2] + t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n + n][n][n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
            <tag> 数字三角形 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划】计数DP</title>
      <link href="/posts/a45a25db.html"/>
      <url>/posts/a45a25db.html</url>
      
        <content type="html"><![CDATA[<h1 id="例题-整数划分"><a href="#例题-整数划分" class="headerlink" title="例题 - 整数划分"></a>例题 - 整数划分</h1><p><a href="https://www.acwing.com/problem/content/902/">题目在这里</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个正整数 n 可以表示成若干个正整数之和，形如：n&#x3D;n1+n2+…+nk，其中 n1≥n2≥…≥nk,k≥1。</p><p>我们将这样的一种表示称为正整数 n 的一种划分。</p><p>现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。</p><p><strong>输入格式</strong></p><p>共一行，包含一个整数 n。</p><p><strong>输出格式</strong></p><p>共一行，包含一个整数，表示总划分数量。</p><p>由于答案可能很大，输出结果请对 109+7 取模。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 1000</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这个问题可以转化成完全背包问题<br>从1 - n 中选物品，每种物品有无数个，背包容量 n</p><p>状态方程：<code>f[i][j]</code>意为从<code>1 - i</code>中选，合为<code>j</code>的情况<br><code>f[i][j] = f[i - 1][j] + f[i][j - i] + f[i][j - 2 * i] + … + f[i][j - s * i] ;</code><br>（意思就是不选 i + 选一个 i + 选两个 i + ……）<br><code>f[i][j - 1] = f[i - 1][j - i] + f[i][j - 2 * i] + … + f[i][j - s * i]</code><br>发现这个式子和前面的式子后半部分重合，所以进行替换，得到状态转移方程：<br><code>f[i][j] = f[i − 1][j] + f[i][j − i]</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; f[n][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划】区间DP</title>
      <link href="/posts/213c1d61.html"/>
      <url>/posts/213c1d61.html</url>
      
        <content type="html"><![CDATA[<h1 id="例题：石子合并"><a href="#例题：石子合并" class="headerlink" title="例题：石子合并"></a>例题：石子合并</h1><p><a href="https://www.acwing.com/problem/content/284/">题目在这里</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设有 N 堆石子排成一排，其编号为 1,2,3,…,N。</p><p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。</p><p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p><p>例如有 4 堆石子分别为 1 3 5 2， 我们可以先合并 1、2 堆，代价为 4，得到 4 5 2， 又合并 1、2 堆，代价为 9，得到 9 2 ，再合并得到 11，总代价为 4+9+11&#x3D;24；</p><p>如果第二步是先合并 2、3 堆，则代价为 7，得到 4 7，最后一次合并代价为 11，总代价为 4+7+11&#x3D;22。</p><p>问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p><p><strong>输入格式</strong></p><p>第一行一个数 N 表示石子的堆数 N。</p><p>第二行 N 个数，表示每堆石子的质量(均不超过 1000)。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最小代价。</p><p><strong>数据范围</strong></p><p>1 ≤ N ≤ 300</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>状态方程：<code>f[i][j]</code>表示合并完区间 <code>[i, j]</code> 时的最小价值<br>状态转移方程需要枚举区间内的点 k ，合并 <code>[i, j]</code> 可以看做合并<code>[i, k]</code>和<code>[k + 1, j]</code>，根据这个思路即可得到转移方程<br><code>f[i][j] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1])</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len ++ ) <span class="comment">// 区间长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = i, r = i + len - <span class="number">1</span>; <span class="comment">// 区间前后端点</span></span><br><span class="line">            f[l][r] = <span class="number">1e8</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; r; k ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划】背包问题</title>
      <link href="/posts/bf2417df.html"/>
      <url>/posts/bf2417df.html</url>
      
        <content type="html"><![CDATA[<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><p>每件物品只有一个，不断对第 i 个物品的状态做出决策，0 &#x2F; 1 表示选 or 不选</p><p><a href="https://www.acwing.com/problem/content/2/">题目在这里</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有 N 件物品和一个容量是 V 的背包，每件物品只能使用一次。</p><p>第 i 件物品的体积是 v<del>i</del> ，价值是 w<del>i</del></p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong><br>第一行两个整数N，V ，用空格隔开，分别表示物品数量和背包容积。<br>接下来有 N 行，每行两个整数 v<del>i</del>,w<del>i</del> ，用空格隔开，分别表示第 i 件物品的体积和价值。</p><p><strong>输出格式</strong><br>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong><br>0 &lt; <em>N, V</em> ≤ 1000<br>0 &lt; <em>v<del>i</del>, w<del>i</del></em> ≤1000</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h3><p>首先定义 <strong><code>f[i][j]</code>：只装前 i 个物品，背包容量为 j 时的最大价值</strong></p><ul><li>如果当前背包容量小于第 i 个物品体积，那么不能选第 i 个物品，则 <code>f[i][j] = f[i - 1][j]</code></li><li>如果当前背包容量大于第 i 个物品体积，那么可以选第 i 个物品<ul><li>选第 i 个物品时，<code>f[i][j] = f[i - 1][j - v[i]] + w[i]</code></li><li>不选第 i 个物品时，<code>f[i][j] = f[i - 1][j]</code></li></ul></li></ul><p>上述两式取<code>max</code>即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N]; <span class="comment">// 体积</span></span><br><span class="line"><span class="type">int</span> w[N]; <span class="comment">// 价值 </span></span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// j体积下前i个物品的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) <span class="comment">// 当前背包容量装不进第i个物品</span></span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 能装</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;           </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h3><p>我们最终要求的只是<code>f[n][m]</code>，背包容量小于 n 时的数据并不需要存储，所以可以优化为一维<br><code>f[j]</code>就表示所有物体在背包容量为 j 时的最大价值</p><p>在这里需要注意的是，背包容量 j 循环的时候必须从大到小，因为在二维中，<code>f[i][j]</code>是通过<code>f[i - 1][j - v[i]]</code>得来的，如果从小到大循环，我们使用的<code>f[j - v[i]]</code>很有可能是第 i 轮的而不是第 i - 1 轮的，导致结果错误</p><p>下面是代码（还优化了下输入）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; <span class="comment">// n：物品数量 m：背包容积</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w; <span class="comment">// v：物品体积 w：物品价值</span></span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v; j -- ) <span class="comment">// j一定要从大到小遍历</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w); <span class="comment">// 一种情况是i-1层的f[j] 一种情况是f[j-v]+w</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><p>01背包问题的升级版，每件物品有无数个可以选，每次遍历循环表示第 i 个物品选了多少个</p><p><a href="https://www.acwing.com/problem/content/3/">题目在这里</a></p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</p><p>第 i 种物品的体积是 v<del>i</del>，价值是 w<del>i</del>。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>0 &lt; <em>N, V</em> ≤ 1000<br>0 &lt; <em>v<del>i</del>,w<del>i</del></em> ≤ 1000</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p><code>f[j]</code>表示在背包容量为 n 时，装前 j 个物品的最大价值<br>它的决策最优值的过程就是，在第 i 轮循环中，不断对第 i 物品的状态做出决策（选 0 &#x2F; 1 &#x2F; 2 …个）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 选前 i 个物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j ++ ) <span class="comment">// 背包容量为 j </span></span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><p>对物品个数继续作出限制，规定每个物品最多使用多少次，求出最大价值</p><p><a href="https://www.acwing.com/problem/content/4/">题目在这里</a></p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>0 &lt; N, V ≤ 100<br>0 &lt; v<del>i</del>, w<del>i</del>, s<del>i</del> ≤ 100</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h2><p><code>f[i][j]</code>表示只拿前i个物品,背包空间为 j 时的价值最大值<br>相当于在之前的基础上多加一层对物品个数的循环</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N]; <span class="comment">// v：体积 w：价值 s：数量</span></span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// f[i][j]表示 只拿前i个物品 背包空间为j 时的价值最大值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++ )</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>因为三层循环数据范围大很有可能挂<br>所以下面对其进行<strong>二进制优化</strong></p><p>我们知道，所有数都可以转换成 2 的次方的和（因为所有数都可以转换成二进制数）<br>比如说 7 &#x3D; 111<del>(2)</del> &#x3D; 2^0^ + 2^1^ + 2^2^<br>那我们把 7 用 1、2、4 代替，就成功把 7 个数转换成 3 个数了</p><p>之后的步骤与 01背包问题一致</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12010</span>, M = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="comment">// 二进制优化</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 分组编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ; <span class="comment">// 改变组编号</span></span><br><span class="line">            v[cnt] = a * k;</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            v[cnt] = a * s;</span><br><span class="line">            w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = cnt;</span><br><span class="line"><span class="comment">// 01背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j -- )</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h1><p>对物品数量做出了更严格的限制，对物品进行分组，同组只能选一个</p><p><a href="https://www.acwing.com/problem/content/9/">题目在这里</a></p><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>有 N 组物品和一个容量是 V 的背包。</p><p>每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。</p><p>接下来有 N 组数据：</p><ul><li>每组数据第一行有一个整数 S<del>i</del>，表示第 i 个物品组的物品数量；</li><li>每组数据接下来有 S<del>i</del> 行，每行有两个整数 v<del>ij</del>,w<del>ij</del>，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；</li></ul><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>0 &lt; N, V ≤ 100<br>0 &lt; S<del>i</del> ≤ 100<br>0&lt; v<del>ij</del>, w<del>ij</del> ≤ 100</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h2><p>一组一组来，看看每一组加哪一个物品或者是不加，其他步骤与01背包类似</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N], s[N]; <span class="comment">// s[i]表示种类数</span></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; j ++ )</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 只在前 i 组物品中选</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j -- ) <span class="comment">// 此时背包容量 j</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; s[i]; k ++ ) <span class="comment">// 目前判断第 i 组第 k 个选不选</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i][k] &lt;= j)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划】线性DP</title>
      <link href="/posts/a999fe19.html"/>
      <url>/posts/a999fe19.html</url>
      
        <content type="html"><![CDATA[<h1 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h1><p><a href="https://www.acwing.com/problem/content/900/">题目在这里</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p><blockquote><pre><code>                              7                              3   8                      8   1   0                          2   7   4   4                      4   5   2   6   5</code></pre></blockquote><p><strong>输入格式</strong></p><p>第一行包含整数 n，表示数字三角形的层数。</p><p>接下来 n 行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大的路径数字和。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 500,<br>−10000 ≤ 三角形中的整数 ≤ 10000</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>每个点只可能从左上方点 or 右上方点走过来，所以在这两个地方取最大值加上当前点的权值即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i; j ++ )</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j ++ )</span><br><span class="line">            f[i][j] = -INF;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j], f[i - <span class="number">1</span>][j] + a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><p><a href="https://www.acwing.com/problem/content/897/">题目在这里</a></p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</p><p><strong>输入格式</strong></p><p>第一行包含整数 N。</p><p>第二行包含 N 个整数，表示完整序列。</p><p><strong>输出格式</strong><br>输出一个整数，表示最大长度。</p><p><strong>数据范围</strong></p><p>1 ≤ N ≤ 1000<br>−109 ≤ 数列中的数 ≤ 109</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>这道题的<code>f[i]</code>表示的是前 i 个字符中的最长上升子序列<br>在遍历第 i 个字符时，二重循环 1 - (i - 1) 个字符，<code>f[i]</code>即为<code>f[i]</code>和<code>f[j] + 1</code>的最大值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>两层循环<code>O(n^2)</code>可能一不小心就爆了<br>所以进行一下 &#x3D;&#x3D;<strong>二分</strong>&#x3D;&#x3D; 优化</p><p>创建数组<code>q[i]</code>表示序列长度为 i 时的序列的最后一个数<br>对于每一个元素<code>a[i]</code>，在<code>q[n]</code>中进行二分查找，找到小于<code>a[i]</code>的最大的一个数<code>q[j]</code>，将<code>a[i]</code>接到这个子序列之后，修改<code>q[j + 1]</code>的值为<code>a[i]</code>，再更新一下长度的最大值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">max</span>(len, r + <span class="number">1</span>);</span><br><span class="line">        q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p><a href="https://www.acwing.com/problem/content/899/">题目在这里</a></p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p> 给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 N 和 M。</p><p>第二行包含一个长度为 N 的字符串，表示字符串 A。</p><p>第三行包含一个长度为 M 的字符串，表示字符串 B。</p><p>字符串均由小写字母构成。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大长度。</p><p><strong>数据范围</strong></p><p>1 ≤ N, M ≤ 1000</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">acbd</span><br><span class="line">abedc</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h2><p>这道题的<code>f[i][j]</code>表示的是在 A 中的前 i 个字符和 B 中的前 j 个字符里选，最长公共子序列的长度是多少</p><p>当不选 A 中的最后一个字符 i 时，<code>f[i][j] = f[i - 1][j]</code><br>当不选 B 中的最后一个字符 j 时，<code>f[i][j] = f[i][j - 1]</code><br>先在这两个中取最大的</p><p>如果选最后一个字符，也就是 A 和 B 的最后一个字符相等的情况下<br>选取<code>f[i][j]</code>和<code>f[i - 1][j - 1] + 1</code>中最大的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cin &gt;&gt; a + <span class="number">1</span> &gt;&gt; b + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h1><p><a href="https://www.acwing.com/problem/content/904/">题目在这里</a></p><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：</p><ul><li>删除–将字符串 A 中的某个字符删除。</li><li>插入–在字符串 A 的某个位置插入某个字符。</li><li>替换–将字符串 A 中的某个字符替换为另一个字符。</li></ul><p>现在请你求出，将 A 变为 B 至少需要进行多少次操作。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n，表示字符串 A 的长度。</p><p>第二行包含一个长度为 n 的字符串 A。</p><p>第三行包含整数 m，表示字符串 B 的长度。</p><p>第四行包含一个长度为 m 的字符串 B。</p><p>字符串中均只包含大小写字母。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最少操作次数。</p><p><strong>数据范围</strong></p><p>1 ≤ n, m ≤ 1000</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> </span><br><span class="line">AGTCTGACGC</span><br><span class="line"><span class="number">11</span> </span><br><span class="line">AGTAAGTAGGC</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h2><p>这道题的<code>f[i][j]</code>表示把 A 的前 i 个字符换成 B 的前 j 个字符需要的步骤数</p><p>首先需要初始化<code>f[0][i]</code>和<code>f[i][0]</code>都等于 i（这个应该很好理解）<br>然后，最后一步一定是插入 or 删除 or 替换<br>插入：<code>f[i - 1][j] + 1</code><br>删除：<code>f[i][j - 1] + 1</code><br>替换：要看 A 的最后一个字符和 B 的最后一个字符是否相等</p><ul><li>相等的话：<code>f[i - 1][j - 1]</code></li><li>不相等的话：<code>f[i - 1][j - 1] + 1</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a + <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; b + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i ++ ) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m ;j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论】判环问题</title>
      <link href="/posts/77f9f026.html"/>
      <url>/posts/77f9f026.html</url>
      
        <content type="html"><![CDATA[<p>（未更新完、做到相关题再更新相关部分</p><h1 id="无向图判断有无环并输出环上点"><a href="#无向图判断有无环并输出环上点" class="headerlink" title="无向图判断有无环并输出环上点"></a>无向图判断有无环并输出环上点</h1><p>例题：<a href="https://codeforces.com/contest/1873/problem/H">H. Mad City</a></p><p>利用变种拓扑排序，先把度为1的点存入队中，每次取出队头，遍历邻接点，再将该条边删除也就是将邻接点度数减一，直至队空，然后所有度数不为0的点都是在环上的点，输出即可</p><p><strong>code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line"></span><br><span class="line">    ind[x] ++, ind[y] ++ ;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function&lt;<span class="type">void</span>()&gt; topsort = [&amp;]()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (ind[i] == <span class="number">1</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- ind[v] == <span class="number">1</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">topsort</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (ind[i] &gt; <span class="number">1</span>) ans = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h1 id="有向图找最小-大环"><a href="#有向图找最小-大环" class="headerlink" title="有向图找最小&#x2F;大环"></a>有向图找最小&#x2F;大环</h1><p>利用并查集，每加一条边，判断当前这两个端点是否连通，如果不连通就更新他们的长度和父结点情况，如果这两个端点已经连通，那么加上这一条边一定能使得形成一个环，环的长度就是两个端点距离祖先结点的和再加一</p><p><strong>code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> last = fa[x];</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">        dist[x] += dist[last];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> aa = <span class="built_in">find</span>(a), bb = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aa == bb) ans = <span class="built_in">min</span>(ans, dist[a] + dist[b] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fa[a] = bb;</span><br><span class="line">        dist[a] = dist[b] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">func</span>(i, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论】有向图的强连通分量</title>
      <link href="/posts/545a0610.html"/>
      <url>/posts/545a0610.html</url>
      
        <content type="html"><![CDATA[<h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><p><strong>什么是连通分量？</strong></p><p>对于一个有向图，分量中任意两点u，v，必然可以从u走到v，且从v走到u，这样的分量叫做连通分量</p><p>如果一个连通分量加上任意一个点都不是连通分量了，就把它叫做 <strong>强连通分量</strong></p><p>强连通分量的主要作用：将任意一个有向图转化成一个有向无环图即拓扑图（通过缩点的方式），缩点就是将所有连通分量缩成一个点</p><p><strong>如何求强连通分量呢？</strong></p><p>按照DFS的顺序搜，我们可以将边分为以下四类：</p><ol><li>树枝边：<code>(x, y)</code>，x是y的父结点</li><li>前向边：<code>(x, y)</code>，x是y的祖先结点</li><li>后向边：<code>(x, y)</code>，y是x的祖先结点</li><li>横叉边：往之前搜过的其他点搜<img src="/posts/545a0610/2.png" class><strong>怎么判断一个点是否在强连通分量中？</strong></li></ol><ul><li>情况一：存在后向边指向祖先结点</li><li>情况二：先走到横叉边，横叉边再走到祖先结点</li></ul><p>（反正一定可以走到某个祖先）</p><p>基于这个想法—— <strong>&#x3D;&#x3D;Tarjan&#x3D;&#x3D;</strong> 算法求强连通分量（SCC）</p><p>先给每个结点按照 DFS 访问顺序确定一个时间戳，时间戳越小说明越先访问到</p><p><code>dfn[u]</code>：遍历到 u 的时间戳<br><code>low[u]</code>：从 u 开始走，能遍历到的最小时间戳<br><code>id[i]</code>：i 所在连通分量的编号</p><p><strong>u是其所在强连通分量的最高点 &lt;-&gt; <code>dfb[u] == low[u]</code></strong></p><h2 id="SCC板子"><a href="#SCC板子" class="headerlink" title="SCC板子"></a>SCC板子</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp; <span class="comment">// 先将dfn和low都初始化为时间戳</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u), in_stk[u] = <span class="literal">true</span>; <span class="comment">// u加入栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 取出u的所有邻点j</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[j]) <span class="comment">// 如果j还没被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]); <span class="comment">// 用low[j]更新low[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]); <span class="comment">// 如果j已入栈 则用dfn[j]更新low[u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) <span class="comment">// 如果该点是所在强连通分量的最高点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt; <span class="comment">// 强连通分量数量加一</span></span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>(); <span class="comment">// 取出栈顶元素</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            id[y] = scc_cnt; <span class="comment">// 标记每个点所在的连通分量编号</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (y != u); <span class="comment">// 直到取到此连通分量的最高点为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缩点的步骤：</strong></p><ol><li>遍历所有点 i</li><li>遍历 i 的所有邻点 j</li><li>如果 i 和 j 不在同一个连通分量中，就加一条新边 <code>id[i]-&gt;id[j]</code></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j]; <span class="comment">// 遍历i的所有邻点k</span></span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[k]; <span class="comment">// 记录ik所在连通分量编号</span></span><br><span class="line">            <span class="keyword">if</span> (a != b) dout[a] ++ ; <span class="comment">// 如果ik不在同一个连通分量 就在两个连通分量之间连一条i指向k的边</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>做完tarjon后，连通分量编号递减的顺序一定就是拓扑序</strong></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="受欢迎的牛"><a href="#受欢迎的牛" class="headerlink" title="受欢迎的牛"></a>受欢迎的牛</h2><p><a href="https://www.acwing.com/problem/content/1176/">原题链接</a></p><p>每一头牛的愿望就是变成一头最受欢迎的牛。</p><p>现在有 N 头牛，编号从 1 到 N，给你 M 对整数 (A,B)，表示牛 A 认为牛 B 受欢迎。</p><p>这种关系是具有传递性的，如果 A 认为 B 受欢迎，B 认为 C 受欢迎，那么牛 A 也认为牛 C 受欢迎。</p><p>你的任务是求出有多少头牛被除自己之外的所有牛认为是受欢迎的。</p><p><strong>输入格式</strong></p><p>第一行两个数 N,M；</p><p>接下来 M 行，每行两个数 A,B，意思是 A 认为 B 是受欢迎的（给出的信息有可能重复，即有可能出现多个 A,B）。</p><p><strong>输出格式</strong></p><p>输出被除自己之外的所有牛认为是受欢迎的牛的数量。</p><p><strong>数据范围</strong></p><p>$1≤N≤104,$<br>$1≤M≤5×104$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>样例解释</strong></p><p>只有第三头牛被除自己之外的所有牛认为是受欢迎的。</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一头牛会欢迎另一头牛，这种欢迎是有传递性的，现给出多对欢迎关系，问有几头牛是被其余所有牛欢迎的</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先对连通分量进行缩点操作</p><p>之后分析，如果有唯一一个连通分量满足出度为0，那么这个连通分量内的所有点都可以由其余任意点到达，答案就是这个连通分量内点的个数，如果这样的连通分量超过一个就不满足条件</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">10010</span>, M = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], ne[M], e[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">bool</span> in_stk[N]; <span class="comment">// 存储点是否入栈</span></span><br><span class="line"><span class="type">int</span> id[N], scc_cnt, Size[N];</span><br><span class="line"><span class="type">int</span> dout[N]; <span class="comment">// 连通分量的出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp; <span class="comment">// 先将dfn和low都初始化为时间戳</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u), in_stk[u] = <span class="literal">true</span>; <span class="comment">// u加入栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 取出u的所有邻点j</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[j]) <span class="comment">// 如果j还没被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]); <span class="comment">// 用low[j]更新low[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]); <span class="comment">// 如果j已入栈 则用dfn[j]更新low[u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) <span class="comment">// 如果该点是所在强连通分量的最高点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt; <span class="comment">// 强连通分量数量加一</span></span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>(); <span class="comment">// 取出栈顶元素</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            id[y] = scc_cnt; <span class="comment">// 标记每个点所在的连通分量编号</span></span><br><span class="line">            Size[scc_cnt] ++ ; <span class="comment">// 更新此连通分量中的点个数</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (y != u); <span class="comment">// 直到取到此连通分量的最高点为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j]; <span class="comment">// 遍历i的所有邻点k</span></span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[k]; <span class="comment">// 记录ik所在连通分量编号</span></span><br><span class="line">            <span class="keyword">if</span> (a != b) dout[a] ++ ; <span class="comment">// 如果ik不在同一个连通分量 就在两个连通分量之间连一条i指向k的边</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> zeros = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!dout[i]) <span class="comment">// 如果当前连通分量出度为0</span></span><br><span class="line">        &#123;</span><br><span class="line">            zeros ++ ; <span class="comment">// 出度为0的连通分量个数加一</span></span><br><span class="line">            sum += Size[i]; <span class="comment">// 更新出度为0的连通分量中点的个数</span></span><br><span class="line">            <span class="keyword">if</span> (zeros &gt; <span class="number">1</span>) <span class="comment">// 如果出度为0的连通分量个数超过一个 说明没有一头牛被所有牛喜欢</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="学校网络"><a href="#学校网络" class="headerlink" title="学校网络"></a>学校网络</h2><p><a href="https://www.acwing.com/problem/content/369/">原题链接</a></p><p>一些学校连接在一个计算机网络上，学校之间存在软件支援协议，每个学校都有它应支援的学校名单（学校 A 支援学校 B，并不表示学校 B 一定要支援学校 A）。</p><p>当某校获得一个新软件时，无论是直接获得还是通过网络获得，该校都应立即将这个软件通过网络传送给它应支援的学校。</p><p>因此，一个新软件若想让所有学校都能使用，只需将其提供给一些学校即可。</p><p>现在请问最少需要将一个新软件直接提供给多少个学校，才能使软件能够通过网络被传送到所有学校？</p><p>最少需要添加几条新的支援关系，使得将一个新软件提供给任何一个学校，其他所有学校就都可以通过网络获得该软件？</p><p><strong>输入格式</strong></p><p>第 1 行包含整数 N，表示学校数量。</p><p>第 2..N+1 行，每行包含一个或多个整数，第 i+1 行表示学校 i 应该支援的学校名单，每行最后都有一个 0 表示名单结束（只有一个 0 即表示该学校没有需要支援的学校）。</p><p><strong>输出格式</strong></p><p>输出两个问题的结果，每个结果占一行。</p><p><strong>数据范围</strong></p><p>$2≤N≤100$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一张图：</p><ul><li>问题一：至少从多少个点出发能够遍历完图上所有点</li><li>问题二：至少加多少条边能让图的强连通分量就是自身</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>设入度为0的连通分量个数为a，出度为0的连通分量个数为b</p><p>问题一就是问a的大小</p><p>问题二就是问ab中较大的值（需要特判一下如果只有一个强连通分量，就不需要加边，输出0即可 ）<br>举个栗子 不具体证明了：</p><img src="/posts/545a0610/1.jpeg" class><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">110</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], ne[M], e[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">bool</span> in_stk[N]; <span class="comment">// 存储点是否入栈</span></span><br><span class="line"><span class="type">int</span> id[N], scc_cnt;</span><br><span class="line"><span class="type">int</span> din[N], dout[N]; <span class="comment">// 连通分量的入度和出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp; <span class="comment">// 先将dfn和low都初始化为时间戳</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u), in_stk[u] = <span class="literal">true</span>; <span class="comment">// u加入栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 取出u的所有邻点j</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[j]) <span class="comment">// 如果j还没被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]); <span class="comment">// 用low[j]更新low[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]); <span class="comment">// 如果j已入栈 则用dfn[j]更新low[u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) <span class="comment">// 如果该点是所在强连通分量的最高点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt; <span class="comment">// 强连通分量数量加一</span></span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>(); <span class="comment">// 取出栈顶元素</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            id[y] = scc_cnt; <span class="comment">// 标记每个点所在的连通分量编号</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (y != u); <span class="comment">// 直到取到此连通分量的最高点为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 建图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; t, t) <span class="built_in">add</span>(i, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j]; <span class="comment">// 遍历i的所有邻点k</span></span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[k]; <span class="comment">// 记录ik所在连通分量编号</span></span><br><span class="line">            <span class="keyword">if</span> (a != b) <span class="comment">// 如果ik不在同一个连通分量 就在两个连通分量之间连一条i指向k的边</span></span><br><span class="line">            &#123;</span><br><span class="line">                dout[a] ++ ;</span><br><span class="line">                din[b] ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!din[i]) a ++ ; <span class="comment">// 记录入度为0的点个数</span></span><br><span class="line">        <span class="keyword">if</span> (!dout[i]) b ++ ; <span class="comment">// 记录出度为0的点个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (scc_cnt == <span class="number">1</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大半连通子图"><a href="#最大半连通子图" class="headerlink" title="最大半连通子图"></a>最大半连通子图</h2><p><a href="https://www.acwing.com/problem/content/1177/">原题链接</a></p><p>一个有向图 G&#x3D;(V,E) 称为半连通的 (Semi-Connected)，如果满足：∀u,v∈V，满足 u→v 或 v→u，即对于图中任意两点 u,v，存在一条 u 到 v 的有向路径或者从 v 到 u 的有向路径。</p><p>若 G′&#x3D;(V′,E′) 满足，E′ 是 E 中所有和 V′ 有关的边，则称 G′ 是 G 的一个导出子图。</p><p>若 G′ 是 G 的导出子图，且 G′ 半连通，则称 G′ 为 G 的半连通子图。</p><p>若 G′ 是 G 所有半连通子图中包含节点数最多的，则称 G′ 是 G 的最大半连通子图。</p><p>给定一个有向图 G，请求出 G 的最大半连通子图拥有的节点数 K，以及不同的最大半连通子图的数目 C。</p><p>由于 C 可能比较大，仅要求输出 C 对 X 的余数。</p><p><strong>输入格式</strong></p><p>第一行包含三个整数 N,M,X。N,M 分别表示图 G 的点数与边数，X 的意义如上文所述；</p><p>接下来 M 行，每行两个正整数 a,b，表示一条有向边 (a,b)。</p><p>图中的每个点将编号为 1 到 N，保证输入中同一个 (a,b) 不会出现两次。</p><p><strong>输出格式</strong></p><p>应包含两行。</p><p>第一行包含一个整数 K，第二行包含整数 C mod X。</p><p><strong>数据范围</strong></p><p>$1≤N≤105,$<br>$1≤M≤106,$<br>$1≤X≤108$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">20070603</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">6</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>找出最大的半连通子图，输出节点数和子图个数</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>最大半连通子图就是图上最长的一条链，所以按照以下思路：</p><ol><li>tarjan</li><li>缩点、建图、给边判重</li><li>按拓扑序递推</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">100010</span>, M = <span class="number">2000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, mod;</span><br><span class="line"><span class="type">int</span> h[N], hs[N], ne[M], e[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">bool</span> in_stk[N]; <span class="comment">// 存储点是否入栈</span></span><br><span class="line"><span class="type">int</span> id[N], scc_cnt, scc_size[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N]; <span class="comment">// 连通分量的入度和出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp; <span class="comment">// 先将dfn和low都初始化为时间戳</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u), in_stk[u] = <span class="literal">true</span>; <span class="comment">// u加入栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 取出u的所有邻点j</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[j]) <span class="comment">// 如果j还没被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]); <span class="comment">// 用low[j]更新low[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]); <span class="comment">// 如果j已入栈 则用dfn[j]更新low[u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) <span class="comment">// 如果该点是所在强连通分量的最高点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt; <span class="comment">// 强连通分量数量加一</span></span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>(); <span class="comment">// 取出栈顶元素</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            id[y] = scc_cnt; <span class="comment">// 标记每个点所在的连通分量编号</span></span><br><span class="line">            scc_size[scc_cnt] ++ ;</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != u); <span class="comment">// 直到取到此连通分量的最高点为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(hs, <span class="number">-1</span>, <span class="keyword">sizeof</span> hs);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(h, a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;ll&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j]; <span class="comment">// 遍历i的所有邻点k</span></span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[k]; <span class="comment">// 记录ik所在连通分量编号</span></span><br><span class="line">            ll hash = a * <span class="number">1000000ll</span> + b;</span><br><span class="line">            <span class="keyword">if</span> (a != b &amp;&amp; !S.<span class="built_in">count</span>(hash)) <span class="comment">// 如果ik不在同一个连通分量 就在两个连通分量之间连一条i指向k的边</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(hs, a, b);</span><br><span class="line">                S.<span class="built_in">insert</span>(hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = scc_cnt; i; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!f[i]) <span class="comment">// 起点</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = scc_size[i]; <span class="comment">// 更新最大半连通子图内元素个数</span></span><br><span class="line">            g[i] = <span class="number">1</span>; <span class="comment">// 更新最大半连通子图个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = hs[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j];</span><br><span class="line">            <span class="keyword">if</span> (f[k] &lt; f[i] + scc_size[k]) <span class="comment">// 有更优解</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[k] = f[i] + scc_size[k];</span><br><span class="line">                g[k] = g[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f[k] == f[i] + scc_size[k]) <span class="comment">// 有结果一样的解</span></span><br><span class="line">                g[k] = (g[k] + g[i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxf = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (f[i] &gt; maxf)</span><br><span class="line">        &#123;</span><br><span class="line">            maxf = f[i];</span><br><span class="line">            sum = g[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f[i] == maxf) sum = (sum + g[i]) % mod;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; maxf &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="银河"><a href="#银河" class="headerlink" title="银河"></a>银河</h2><p><a href="https://www.acwing.com/problem/content/370/">原题链接</a></p><p>银河中的恒星浩如烟海，但是我们只关注那些最亮的恒星。</p><p>我们用一个正整数来表示恒星的亮度，数值越大则恒星就越亮，恒星的亮度最暗是 1。</p><p>现在对于 N 颗我们关注的恒星，有 M 对亮度之间的相对关系已经判明。</p><p>你的任务就是求出这 N 颗恒星的亮度值总和至少有多大。</p><p><strong>输入格式</strong></p><p>第一行给出两个整数 N 和 M。</p><p>之后 M 行，每行三个整数 T,A,B，表示一对恒星 (A,B) 之间的亮度关系。恒星的编号从 1 开始。</p><ul><li>如果 T&#x3D;1，说明 A 和 B 亮度相等。</li><li>如果 T&#x3D;2，说明 A 的亮度小于 B 的亮度。</li><li>如果 T&#x3D;3，说明 A 的亮度不小于 B 的亮度。</li><li>如果 T&#x3D;4，说明 A 的亮度大于 B 的亮度。</li><li>如果 T&#x3D;5，说明 A 的亮度不大于 B 的亮度。</li></ul><p><strong>输出格式</strong></p><p>输出一个整数表示结果。</p><p>若无解，则输出 −1。</p><p><strong>数据范围</strong></p><p>$N≤100000,M≤100000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">1</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> </span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>求图中有无正环的问题</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>用tarjan求强连通分量</li><li>缩点、根据差分约束建图</li><li>依据拓扑序递推</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">100010</span>, M = <span class="number">600010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], hs[N], w[M], ne[M], e[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">bool</span> in_stk[N]; <span class="comment">// 存储点是否入栈</span></span><br><span class="line"><span class="type">int</span> id[N], scc_cnt, scc_size[N];</span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 连通分量的入度和出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp; <span class="comment">// 先将dfn和low都初始化为时间戳</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u), in_stk[u] = <span class="literal">true</span>; <span class="comment">// u加入栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 取出u的所有邻点j</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[j]) <span class="comment">// 如果j还没被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[j]); <span class="comment">// 用low[j]更新low[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]); <span class="comment">// 如果j已入栈 则用dfn[j]更新low[u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) <span class="comment">// 如果该点是所在强连通分量的最高点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++ scc_cnt; <span class="comment">// 强连通分量数量加一</span></span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>(); <span class="comment">// 取出栈顶元素</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            id[y] = scc_cnt; <span class="comment">// 标记每个点所在的连通分量编号</span></span><br><span class="line">            scc_size[scc_cnt] ++ ;</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != u); <span class="comment">// 直到取到此连通分量的最高点为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(hs, <span class="number">-1</span>, <span class="keyword">sizeof</span> hs);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">add</span>(h, <span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t, a, b;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="built_in">add</span>(h, b, a, <span class="number">0</span>), <span class="built_in">add</span>(h, a, b, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) <span class="built_in">add</span>(h, a, b, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">3</span>) <span class="built_in">add</span>(h, b, a, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">4</span>) <span class="built_in">add</span>(h, b, a, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(h, a, b, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = e[j]; <span class="comment">// 遍历i的所有邻点k</span></span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[k]; <span class="comment">// 记录ik所在连通分量编号</span></span><br><span class="line">            <span class="keyword">if</span> (a == b) <span class="comment">// ik在同一个强连通分量</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (w[j] &gt; <span class="number">0</span>) <span class="comment">// ik间有权值为正的路径</span></span><br><span class="line">                &#123;</span><br><span class="line">                    success = <span class="literal">false</span>; <span class="comment">// 无解</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">add</span>(hs, a, b, w[j]);<span class="comment">// 如果ik不在同一个连通分量 就在两个连通分量之间连一条i指向k的边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!success) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 有解则求最长路</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = scc_cnt; i; i -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = hs[i]; ~j; j = ne[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k = e[j];</span><br><span class="line">                dist[k] = <span class="built_in">max</span>(dist[k], dist[i] + w[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i ++ ) res += (ll)dist[i] * scc_size[i];</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 连通分量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论】SPFA求负环</title>
      <link href="/posts/33ca34cf.html"/>
      <url>/posts/33ca34cf.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>负环</strong>：环上权值之和是负数</p><p>求负环的常用方法 <strong>基于SPFA</strong></p><ol><li>统计每个点入队次数，如果某个点入队n次，则说明存在负环（完全等价于Bellman-Ford算法）</li><li>统计当前每个点的最短路中所包含的边数，如果某点的最短路包含的边数大于等于n，则说明存在负环</li></ol><p>玄学结论：当所有点的入队次数超过2n时，就认为图中有很大肯存在负环</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="虫洞"><a href="#虫洞" class="headerlink" title="虫洞"></a>虫洞</h2><p><a href="https://www.acwing.com/problem/content/906/">原题链接</a></p><p>农夫约翰在巡视他的众多农场时，发现了很多令人惊叹的虫洞。</p><p>虫洞非常奇特，它可以看作是一条 单向 路径，通过它可以使你回到过去的某个时刻（相对于你进入虫洞之前）。</p><p>农夫约翰的每个农场中包含 N 片田地，M 条路径（双向）以及 W 个虫洞。</p><p>现在农夫约翰希望能够从农场中的某片田地出发，经过一些路径和虫洞回到过去，并在他的出发时刻之前赶到他的出发地。</p><p>他希望能够看到出发之前的自己。</p><p>请你判断一下约翰能否做到这一点。</p><p>下面我们将给你提供约翰拥有的农场数量 F，以及每个农场的完整信息。</p><p>已知走过任何一条路径所花费的时间都不超过 10000 秒，任何虫洞将他带回的时间都不会超过 10000 秒。</p><p><strong>输入格式</strong></p><p>第一行包含整数 F，表示约翰共有 F 个农场。</p><p>对于每个农场，第一行包含三个整数 N,M,W。</p><p>接下来 M 行，每行包含三个整数 S,E,T，表示田地 S 和 E 之间存在一条路径，经过这条路径所花的时间为 T。</p><p>再接下来 W 行，每行包含三个整数 S,E,T，表示存在一条从田地 S 走到田地 E 的虫洞，走过这条虫洞，可以回到 T 秒之前。</p><p><strong>输出格式</strong></p><p>输出共 F行，每行输出一个结果。</p><p>如果约翰能够在出发时刻之前回到出发地，则输出 YES，否则输出 NO。</p><p><strong>数据范围</strong></p><p>$1≤F≤5$<br>$1≤N≤500,$<br>$1≤M≤2500,$<br>$1≤W≤200,$<br>$1≤T≤10000,$<br>$1≤S,E≤N$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>负环板题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>跑一遍spfa</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">5210</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m1, m2;</span><br><span class="line"><span class="type">int</span> h[N], ne[M], e[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 更新次数一旦超过n就说明有负环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m1; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m2; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(a, b, -c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="观光奶牛"><a href="#观光奶牛" class="headerlink" title="观光奶牛"></a>观光奶牛</h2><p><a href="https://www.acwing.com/problem/content/363/">原题链接</a></p><p>给定一张 L 个点、P 条边的有向图，每个点都有一个权值 f[i]，每条边都有一个权值 t[i]。</p><p>求图中的一个环，使“环上各点的权值之和”除以“环上各边的权值之和”最大。</p><p>输出这个最大值。</p><p>注意：数据保证至少存在一个环。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 L 和 P。</p><p>接下来 L 行每行一个整数，表示 f[i]。</p><p>再接下来 P 行，每行三个整数 a，b，t[i]，表示点 a 和 b 之间存在一条边，边的权值为 t[i]。</p><p><strong>输出格式</strong></p><p>输出一个数表示结果，保留两位小数。</p><p><strong>数据范围</strong></p><p>$2≤L≤1000,$<br>$2≤P≤5000,$<br>$1≤f[i],t[i]≤1000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6.00</span></span><br></pre></td></tr></table></figure><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出点权和边权，求一个环使得点权之和除以边权之和最大</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>求比值最大的问题 -&gt; <strong>&#x3D;&#x3D;01分数规划&#x3D;&#x3D;</strong> -&gt; <strong>二分</strong></p><p>首先确定边界值，答案一定在<code>[0, 1000)</code> 之间</p><p>每次取中点mid，如果图中存在一个环使得比值大于mid，则答案在mid和r之间，反之亦然</p><p>现在问题变成了如何判断是否存在一个比值大于mid的环？</p><p>判断：$\frac{\sum f_i}{\sum t_i}&gt;Mid$<br>化简：$\sum f_i-Mid*\sum t_i&gt;0$</p><p>在环上的点权我们可以任意加到边权上，对环不会有影响，假设我们将所有点权加到出边上，化简：$\sum (f_i-Mid*t_i)&gt;0$</p><p>现在将边权全看成$f_i-Mid*t_i$</p><p>问题转换成了：图中是否存在一个正环</p><p>求最长路即可</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> wf[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], wt[M], idx;</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, wt[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 所有点存进队列</span></span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &lt; dist[t] + wf[t] - mid * wt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + wf[t] - mid * wt[i]; <span class="comment">// 更新最长距离</span></span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 更新次数超过n就说明有正环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; wf[i]; <span class="comment">// 记录点权</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-4</span>) <span class="comment">// 误差</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单词环"><a href="#单词环" class="headerlink" title="单词环"></a>单词环</h2><p><a href="https://www.acwing.com/problem/content/1167/">原题链接</a></p><p>我们有 n 个字符串，每个字符串都是由 a∼z 的小写英文字母组成的。</p><p>如果字符串 A 的结尾两个字符刚好与字符串 B 的开头两个字符相匹配，那么我们称 A 与 B 能够相连（注意：A 能与 B 相连不代表 B 能与 A 相连）。</p><p>我们希望从给定的字符串中找出一些，使得它们首尾相连形成一个环串（一个串首尾相连也算），我们想要使这个环串的平均长度最大。</p><p>如下例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ababc</span><br><span class="line">bckjaca</span><br><span class="line">caahoynaab</span><br></pre></td></tr></table></figure><p>第一个串能与第二个串相连，第二个串能与第三个串相连，第三个串能与第一个串相连，我们按照此顺序相连，便形成了一个环串，长度为 5+7+10&#x3D;22（重复部分算两次），总共使用了 3 个串，所以平均长度是 223≈7.33。</p><p><strong>输入格式</strong></p><p>本题有多组数据。</p><p>每组数据的第一行，一个整数 n，表示字符串数量；</p><p>接下来 n 行，每行一个长度小于等于 1000 的字符串。</p><p>读入以 n&#x3D;0 结束。</p><p><strong>输出格式</strong></p><p>若不存在环串，输出”No solution”，否则输出最长的环串的平均长度。</p><p>只要答案与标准答案的差不超过 0.01，就视为答案正确。</p><p><strong>数据范围</strong></p><p>$1≤n≤105$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">intercommunicational</span><br><span class="line">alkylbenzenesulfonate</span><br><span class="line">tetraiodophenolphthalein</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">21.66</span></span><br></pre></td></tr></table></figure><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>n个字符串，如果a的末尾两个字符和b的开头相同则能相连，求能构成的环的平均长度最大值</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>把每个字符串的首位两个字母看做一个点，比如说样例可以这样建图：</p><img src="/posts/33ca34cf/1.png" class><p>答案就变成了求$\frac{\sum w_i}{\sum 1}$的最大值</p><p>答案在<code>(0, 1000)</code>之内，二分做，类似观光奶牛</p><p>最终判断式为：$\sum w_i - Mid*\sum 1&gt;0$</p><p>判断有没有解直接把 <code>Mid = 0</code> 代入即可，因为如果等于0都不能满足的话大于0就更不会满足了</p><p>于是成功TLE，用一下玄学优化</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">700</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">676</span>; i ++ ) <span class="comment">// 所有点存入队列</span></span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &lt; dist[t] + w[i] - mid)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i] - mid;</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (++ count &gt; <span class="number">10000</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 次数过多直接返回（玄学可能失败</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= N) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这个是保证一定正确的</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1010</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">if</span> (len &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 用类似于26进制的方法存储</span></span><br><span class="line">                <span class="type">int</span> left = (str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> right = (str[len - <span class="number">2</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[len - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="built_in">add</span>(left, right, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(<span class="number">0</span>)) <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>); <span class="comment">// 判断是否有解</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">while</span> (r - l &gt; <span class="number">1e-4</span>) <span class="comment">// 误差</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> SPFA </tag>
            
            <tag> 负环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论】最小生成树</title>
      <link href="/posts/a428212b.html"/>
      <url>/posts/a428212b.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><h3 id="步骤与基本思路"><a href="#步骤与基本思路" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>（1）初始化所有点，每个点单独在一个点集。把所有边按权重排序</p><p>（2）按边权重从小到大遍历每一条边，如果这条边的两个顶点不在同一个点集，就将它们加到同一点集，也就是选中这条边，以此类推</p><p>（3）如果最后加入同一个点集的点个数小于n个说明这个图不是连通图，无法生成最小生成树</p><h3 id="Kruskal板子"><a href="#Kruskal板子" class="headerlink" title="Kruskal板子"></a>Kruskal板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 判断x属于哪一个点集</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m); <span class="comment">// 所有边按权重排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i; <span class="comment">// 所有点单独占一个点集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="comment">// 从小到大遍历每条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b) <span class="comment">// 判断ab在不在同一个点集</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b; <span class="comment">// 合并到同一点集</span></span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF; <span class="comment">// 不是连通图</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><h3 id="步骤与基本思路-1"><a href="#步骤与基本思路-1" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>（1）初始化距离数组dist[N]，将其所有值赋为0x3f</p><p>（2）从第一个点开始循环n次（因为最小生成树有n个点），每次循环中遍历所有点，选择还没有加入最小生成树且与生成树集合距离最短的点加入生成树，然后更新所有点到生成树集合的距离</p><p>（3）如果不是第一个点且距离生成树集合为无穷大时，说明不能形成最小生成树</p><h3 id="Prim板子"><a href="#Prim板子" class="headerlink" title="Prim板子"></a>Prim板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> <span class="comment">// 返回最小生成树的权重和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) <span class="comment">// 找到距离生成树集合距离最短的点</span></span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF; <span class="comment">// 距离最短的点距离时INF</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]); <span class="comment">// 更新所有点到生成树集合的距离</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>求最小生成树的基本算法有两个：</p><ul><li>Prim 时间复杂度O(n^2^)</li><li>Kruskal 时间复杂度O(mlogn) <strong>一般都用这个</strong></li></ul><p>上两个算法的证明思路：</p><p>假设不选当前边，最终得到了一棵树，然后将这条边加上，必然会出现一个环，在环上一定可以找到一条长度不小于当前边的边，那么用当前边替换，结果一定不会变差</p><p>同时还需要掌握：</p><ul><li>任意一棵最小生成树一定 <strong>&#x3D;&#x3D;可以&#x3D;&#x3D;</strong> 包含无向图中权值最小的边</li><li>给定一张无向图<code>G = (V, E)</code>，<code>n = |V|</code>，<code>m = |E|</code>，从 E 中选出 <code>k &lt; n - 1</code> 条边构成 G 的一个生成森林，若再从剩余的 <code>m -  k</code> 条边中选 <code>n - 1 - k</code> 条边添加到生成森林中，使其成为 G 的生成树，并且选出的边的权值之和最小，则该生成树一定 <strong>&#x3D;&#x3D;可以&#x3D;&#x3D;</strong> 包含 <code>m - k</code> 条边中连接生成森林的两个不连通节点的权值最小的边</li></ul><p>（证明思路还是同上）</p><h2 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h2><p>定义：给定一个带权图，把图的所有生成树权值从大到小排序，第二小的称为次小生成树</p><p>严格的次小生成树权值和不能等于最小生成树</p><p>求法：</p><p>方法一：先求最小生成树，再枚举删去最小生成树中的边求解<br><strong>只能求出非严格最小生成树</strong><br>时间复杂度：O(mlogn + mn)</p><p>方法二：先求最小生成树，然后依次枚举非树边，将该边加入树中，同时从形成的环的其余边中去掉最大边，使得最终图依然是一棵树，一定可以求出次小生成树<br>时间复杂度：O(m + n^2^ + mlogn)</p><h1 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h1><h2 id="最短网络"><a href="#最短网络" class="headerlink" title="最短网络"></a>最短网络</h2><p><a href="https://www.acwing.com/problem/content/1142/">原题链接</a></p><p>农夫约翰被选为他们镇的镇长！</p><p>他其中一个竞选承诺就是在镇上建立起互联网，并连接到所有的农场。</p><p>约翰已经给他的农场安排了一条高速的网络线路，他想把这条线路共享给其他农场。</p><p>约翰的农场的编号是1，其他农场的编号是 2∼n。</p><p>为了使花费最少，他希望用于连接所有的农场的光纤总长度尽可能短。</p><p>你将得到一份各农场之间连接距离的列表，你必须找出能连接所有农场并使所用光纤最短的方案。</p><p><strong>输入格式</strong></p><p>第一行包含一个整数 n，表示农场个数。</p><p>接下来 n 行，每行包含 n 个整数，输入一个对角线上全是0的对称矩阵。<br>其中第 x+1 行 y 列的整数表示连接农场 x 和农场 y 所需要的光纤长度。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示所需的最小光纤长度。</p><p><strong>数据范围</strong></p><p>$3≤n≤100$<br>每两个农场间的距离均是非负整数且不超过100000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span>  <span class="number">4</span>  <span class="number">9</span>  <span class="number">21</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0</span>  <span class="number">8</span>  <span class="number">17</span></span><br><span class="line"><span class="number">9</span>  <span class="number">8</span>  <span class="number">0</span>  <span class="number">16</span></span><br><span class="line"><span class="number">21</span> <span class="number">17</span> <span class="number">16</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>最小生成树裸题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>跑一遍prim</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N][N]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// dist[i]表示i点距离当前连通块最短的一条边的长度</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 需要加入n个点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) t = j; <span class="comment">// 找到距离当前连通块最短的一条边</span></span><br><span class="line">        </span><br><span class="line">        res += dist[t]; <span class="comment">// 把最短的边连接的点加到连通块中</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], w[t][j]); <span class="comment">// 更新dist</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">prim</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p><a href="https://www.acwing.com/problem/content/1143/">原题链接</a></p><p>某个局域网内有 n 台计算机和 k 条 双向 网线，计算机的编号是 1∼n。由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。</p><p>注意：<br>对于某一个连接，虽然它是双向的，但我们不将其当做回路。本题中所描述的回路至少要包含两条不同的连接。<br>两台计算机之间最多只会存在一条连接。<br>不存在一条连接，它所连接的两端是同一台计算机。<br>因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用 <code>f(i,j)</code> 表示 <code>i</code>,<code>j</code> 之间连接的畅通程度，<code>f(i,j)</code> 值越小表示 <code>i</code>,<code>j</code> 之间连接越通畅。</p><p>现在我们需要解决回路问题，我们将除去一些连线，使得网络中没有回路且不影响连通性（即如果之前某两个点是连通的，去完之后也必须是连通的），并且被除去网线的 <code>Σf(i,j)</code> 最大，请求出这个最大值。</p><p><strong>输入格式</strong></p><p>第一行两个正整数 n,k。</p><p>接下来的 k 行每行三个正整数 i,j,m 表示 i,j 两台计算机之间有网线联通，通畅程度为 m。</p><p><strong>输出格式</strong></p><p>一个正整数，表示被除去网线的 Σf(i,j) 的最大值。</p><p><strong>数据范围</strong></p><p>$1≤n≤100$<br>$0≤k≤200$<br>$1≤f(i,j)≤1000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p><code>f[i][j]</code>表示ij间网络通畅度，越大流畅度越差，现在给出一张图，删掉任意条边使得原来连通的点对还连通，问删去后的图的最小权重</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>题意可转换成寻找一个“森林”的“最小生成森林”，跑一遍Kruskal即可</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        e[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b), w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span> (a != b) p[a] = b;</span><br><span class="line">        <span class="keyword">else</span> res += w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="繁忙的都市"><a href="#繁忙的都市" class="headerlink" title="繁忙的都市"></a>繁忙的都市</h2><p><a href="https://www.acwing.com/problem/content/1144/">原题链接</a></p><p>城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。</p><p>城市C的道路是这样分布的：</p><p>城市中有 n 个交叉路口，编号是 1∼n，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。</p><p>这些道路是 双向 的，且把所有的交叉路口直接或间接的连接起来了。</p><p>每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。</p><p>但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：</p><p>1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。</p><p>2．在满足要求1的情况下，改造的道路尽量少。</p><p>3．在满足要求1、2的情况下，改造的那些道路中分值最大值尽量小。</p><p>作为市规划局的你，应当作出最佳的决策，选择哪些道路应当被修建。</p><p><strong>输入格式</strong></p><p>第一行有两个整数 n,m 表示城市有 n 个交叉路口，m 条道路。</p><p>接下来 m 行是对每条道路的描述，每行包含三个整数u,v,c 表示交叉路口 u 和 v 之间有道路相连，分值为 c。</p><p><strong>输出格式</strong></p><p>两个整数 s,max，表示你选出了几条道路，分值最大的那条道路的分值是多少。</p><p><strong>数据范围</strong></p><p>$1≤n≤300,$<br>$1≤m≤8000,$<br>$1≤c≤10000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出一张图，问最小生成树的最大边</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>跑一遍Kruskal即可</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        e[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b), w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; n - <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接格点"><a href="#连接格点" class="headerlink" title="连接格点"></a>连接格点</h2><p><a href="https://www.acwing.com/problem/content/1146/">原题链接</a></p><p>有一个 m 行 n 列的点阵，相邻两点可以相连。</p><p>一条纵向的连线花费一个单位，一条横向的连线花费两个单位。</p><p>某些点之间已经有连线了，试问至少还需要花费多少个单位才能使所有的点全部连通。</p><p><strong>输入格式</strong></p><p>第一行输入两个正整数 m 和 n。</p><p>以下若干行每行四个正整数 x1,y1,x2,y2，表示第 x1 行第 y1 列的点和第 x2 行第 y2 列的点已经有连线。</p><p>输入保证|x1−x2|+|y1−y2|&#x3D;1。</p><p><strong>输出格式</strong></p><p>输出使得连通所有点还需要的最小花费。</p><p><strong>数据范围</strong></p><p>$1≤m,n≤1000$<br>$0≤已经存在的连线数≤10000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个点阵，相邻两点可连接，竖着连权重1，横着连权重二，已经连了一些边，求最小生成树</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>首先还是将已经连的边存进去，然后由于竖着的比横着的权重小，我们先将竖着的边存进去再存横着的边（避免对边的集合进行排序），之后跑一遍kruskal即可</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N, K = <span class="number">2</span> * N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> ids[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;e[K];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_edges</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dw[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; z &lt; <span class="number">2</span>; z ++ ) <span class="comment">// 先竖再横 确保边权有序 使无需对边排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u ++ )</span><br><span class="line">                    <span class="keyword">if</span> (u % <span class="number">2</span> == z)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> x = i + dx[u], y = j + dy[u], w = dw[u];</span><br><span class="line">                        <span class="keyword">if</span> (x &amp;&amp; x &lt;= n &amp;&amp; y &amp;&amp; y &lt;= m) <span class="comment">// 确定位置合法</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="type">int</span> a = ids[i][j], b = ids[x][y];</span><br><span class="line">                            <span class="keyword">if</span> (a &lt; b) e[k ++ ] = &#123;a, b, w&#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, t = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++, t ++ )</span><br><span class="line">            ids[i][j] = t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x1, x2, y1, y2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = ids[x1][y1], b = ids[x2][y2];</span><br><span class="line">        p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_edges</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跑一遍Kruskal</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b), w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓展应用"><a href="#拓展应用" class="headerlink" title="拓展应用"></a>拓展应用</h1><h2 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h2><p><a href="https://www.acwing.com/problem/content/1148/">原题链接</a></p><p>发展采矿业当然首先得有矿井，小 FF 花了上次探险获得的千分之一的财富请人在岛上挖了 n 口矿井，但他似乎忘记了考虑矿井供电问题。</p><p>为了保证电力的供应，小 FF 想到了两种办法：</p><p>在矿井 i 上建立一个发电站，费用为 vi（发电站的输出功率可以供给任意多个矿井）。将这口矿井 i 与另外的已经有电力供应的矿井 j 之间建立电网，费用为 pi,j。</p><p>小 FF 希望你帮他想出一个保证所有矿井电力供应的最小花费方案。</p><p><strong>输入格式</strong></p><p>第一行包含一个整数 n，表示矿井总数。</p><p>接下来 n 行，每行一个整数，第 i 个数 vi 表示在第 i 口矿井上建立发电站的费用。</p><p>接下来为一个 n×n 的矩阵 P，其中 pi,j 表示在第 i 口矿井和第 j 口矿井之间建立电网的费用。</p><p>数据保证 <code>p[i,j]=p[j,i]</code>，且 <code>p[i,i]=0</code>。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示让所有矿井获得充足电能的最小花费。</p><p><strong>数据范围</strong></p><p>$1≤n≤300,$<br>$0≤vi,pi,j≤105$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>多个矿井需要通电，可以在矿井处建发电站也可以将该矿井和其他有点的地方连起来，这两个操作都需要一定花费，求最少花费</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p><strong>&#x3D;&#x3D;虚拟源点&#x3D;&#x3D;</strong></p><p>建立虚拟源点，在某点建立发电站转化成在该点和虚拟源点之间连边，边的权值是在该点建立发电站的花费，求最小生成树跑一遍Prim即可</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) t = j;</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], w[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 连接虚拟源点和各个点</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w[<span class="number">0</span>][i];</span><br><span class="line">        w[i][<span class="number">0</span>] = w[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">prim</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="北极通讯网络"><a href="#北极通讯网络" class="headerlink" title="北极通讯网络"></a>北极通讯网络</h2><p><a href="https://www.acwing.com/problem/content/1147/">原题链接</a></p><p>北极的某区域共有 n 座村庄，每座村庄的坐标用一对整数 (x,y) 表示。</p><p>为了加强联系，决定在村庄之间建立通讯网络，使每两座村庄之间都可以直接或间接通讯。</p><p>通讯工具可以是无线电收发机，也可以是卫星设备。</p><p>无线电收发机有多种不同型号，不同型号的无线电收发机有一个不同的参数 d，两座村庄之间的距离如果不超过 d，就可以用该型号的无线电收发机直接通讯，d 值越大的型号价格越贵。现在要先选择某一种型号的无线电收发机，然后统一给所有村庄配备，数量不限，但型号都是 相同的。</p><p>配备卫星设备的两座村庄无论相距多远都可以直接通讯，但卫星设备是 有限的，只能给一部分村庄配备。</p><p>现在有 k 台卫星设备，请你编一个程序，计算出应该如何分配这 k 台卫星设备，才能使所配备的无线电收发机的 d 值最小。</p><p>例如，对于下面三座村庄：</p><img src="/posts/a428212b/7.png" class><p>其中，<code>|AB|=10,|BC|=20,|AC|=105√≈22.36</code>。</p><p>如果没有任何卫星设备或只有 1 台卫星设备 (k&#x3D;0 或 k&#x3D;1)，则满足条件的最小的 d&#x3D;20，因为 A 和 B，B 和 C 可以用无线电直接通讯；而 A 和 C 可以用 B 中转实现间接通讯 (即消息从 A 传到 B，再从 B 传到 C)；</p><p>如果有 2 台卫星设备 (k&#x3D;2)，则可以把这两台设备分别分配给 B 和 C ，这样最小的 d 可取10，因为 A 和 B 之间可以用无线电直接通讯；B 和 C 之间可以用卫星直接通讯；A 和 C<br> 可以用 B 中转实现间接通讯。</p><p>如果有 3 台卫星设备，则 A,B,C 两两之间都可以直接用卫星通讯，最小的 d 可取 0。</p><p><strong>输入格式</strong></p><p>第一行为由空格隔开的两个整数 n,k;</p><p>接下来 n 行，每行两个整数，第 i 行的 xi,yi 表示第 i 座村庄的坐标 (xi,yi)。</p><p><strong>输出格式</strong></p><p>一个实数，表示最小的 d 值，结果保留 2 位小数。</p><p><strong>数据范围</strong></p><p>$1≤n≤500,$<br>$0≤x,y≤104,$<br>$0≤k≤100$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">0</span></span><br><span class="line"><span class="number">30</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10.00</span></span><br></pre></td></tr></table></figure><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>有无线电和卫星设备两种方式，无线电的参数d表示在d之内的都可以直接传输，卫星设备不管离多远都可以传输，现有k个卫星设备，求问最小的d</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>Kruskal的基本思路是，假设已经遍历完前i条边，那么就已经求出了连接前i条边的连通块个数，本题给出k个卫星设备，意思就是我们需要求出一个d，使得距离比d小的两个点之间都靠无线电传输（这些靠无线电传输的构成了多个连通块），在所有连通块之间建立卫星设备，卫星设备的个数是k</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = N * N / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">double</span> w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line">PII q[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_dist</span><span class="params">(PII a, PII b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx = a.first - b.first;</span><br><span class="line">    <span class="type">int</span> dy = a.second - b.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i].first &gt;&gt; q[i].second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line">            e[m ++ ] = &#123;i, j, <span class="built_in">get_dist</span>(q[i], q[j])&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = n;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == k) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">        <span class="type">double</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            cnt -- ;</span><br><span class="line">            res = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="走廊泼水节"><a href="#走廊泼水节" class="headerlink" title="走廊泼水节"></a>走廊泼水节</h2><p><a href="https://www.acwing.com/problem/content/348/">原题链接</a></p><p>给定一棵 N 个节点的树，要求增加若干条边，把这棵树扩充为完全图，并满足图的唯一最小生成树仍然是这棵树。</p><p>求增加的边的权值总和最小是多少。</p><p>注意： 树中的所有边权均为整数，且新加的所有边权也必须为整数。</p><p><strong>输入格式</strong></p><p>第一行包含整数 t，表示共有 t 组测试数据。</p><p>对于每组测试数据，第一行包含整数 N。</p><p>接下来 N−1 行，每行三个整数 X,Y,Z，表示 X 节点与 Y 节点之间存在一条边，长度为 Z。</p><p><strong>输出格式</strong></p><p>每组数据输出一个整数，表示权值总和最小值。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><p>$1≤N≤6000$<br>$1≤Z≤100$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>将一棵树扩展为一个完全图，要求图的最小生成树还是原来的那棵树，求添加的边权总和最小是多少</p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p><strong>&#x3D;&#x3D;扩展应用&#x3D;&#x3D;</strong></p><p>将图中每个点看做一个连通块</p><p>每两个连通块之间构成完全图就是连接两个连通块的所有点对，也就是<code>(sized[a] * sized[b] - 1)</code></p><p>因为我们要让起初的树是完全图的最小生成树，我们将边权从小到大排序，每次选择当前边所连接的两个连通块，加上的新边必须要大于当前边权（才能使其为最小生成树），也就是新加的边权是<code>w + 1</code></p><p>记得维护<code>size</code>和<code>p</code></p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 并查集</span></span><br><span class="line"><span class="type">int</span> sized[N]; <span class="comment">// 只有根结点的数据正确 表示这个连通块的结点个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            e[i] = &#123;a, b, c&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(e, e + n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i, sized[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b), w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span> (a != b)</span><br><span class="line">            &#123;</span><br><span class="line">                res += (sized[a] * sized[b] - <span class="number">1</span>) * (w + <span class="number">1</span>);</span><br><span class="line">                sized[b] += sized[a];</span><br><span class="line">                p[a] = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="秘密的牛奶运输"><a href="#秘密的牛奶运输" class="headerlink" title="秘密的牛奶运输"></a>秘密的牛奶运输</h2><p><a href="https://www.acwing.com/problem/content/1150/">原题链接</a></p><p>农夫约翰要把他的牛奶运输到各个销售点。</p><p>运输过程中，可以先把牛奶运输到一些销售点，再由这些销售点分别运输到其他销售点。</p><p>运输的总距离越小，运输的成本也就越低。</p><p>低成本的运输是农夫约翰所希望的。</p><p>不过，他并不想让他的竞争对手知道他具体的运输方案，所以他希望采用费用第二小的运输方案而不是最小的。</p><p>现在请你帮忙找到该运输方案。</p><p>注意：</p><p>如果两个方案至少有一条边不同，则我们认为是不同方案；<br>费用第二小的方案在数值上一定要严格大于费用最小的方案；<br>答案保证一定有解；</p><p><strong>输入格式</strong></p><p>第一行是两个整数 N,M，表示销售点数和交通线路数；</p><p>接下来 M 行每行 3 个整数 x,y,z，表示销售点 x 和销售点 y 之间存在线路，长度为 z。</p><p><strong>输出格式</strong></p><p>输出费用第二小的运输方案的运输总距离。</p><p><strong>数据范围</strong></p><p>$1≤N≤500,$<br>$1≤M≤104,$<br>$1≤z≤109,$<br>数据中可能包含重边。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">100</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">200</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">250</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">450</span></span><br></pre></td></tr></table></figure><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p>次小生成树板题</p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p><strong>&#x3D;&#x3D;次小生成树&#x3D;&#x3D;</strong></p><p>使用方法二，具体步骤：</p><ol><li>求最小生成树，统计每条边是树边还是非树边，同时建立最小生成树</li><li>预处理任意两点间边权最大值<code>dist1[a][b]</code>和次大值<code>dist2[a][b]</code></li><li>依次枚举所有非树边，求<code>min(sum + w - dist[a][b])</code>，满足<code>w &gt; dist1[a][b]</code>或<code>w &gt; dist2[a][b]</code>（这样才能保证求出的是严格次小生成树）</li></ol><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> f; <span class="comment">// 记录该边是否为树边</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> dist1[N][N], dist2[N][N];</span><br><span class="line"><span class="type">int</span> h[N], e[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], w[N * <span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// u当前结点 fa父结点 maxd1 maxd2 d1:和u形成的路径上的最大边 d2:和u形成的路径上的次大边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> maxd1, <span class="type">int</span> maxd2, <span class="type">int</span> d1[], <span class="type">int</span> d2[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d1[u] = maxd1, d2[u] = maxd2; <span class="comment">// 记录最大边次大边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != fa) <span class="comment">// 不是连到父结点的边再继续</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 更新当前最大边和次大边</span></span><br><span class="line">            <span class="type">int</span> td1 = maxd1, td2 = maxd2;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; td1) td2 = td1, td1 = w[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w[i] &lt; td1 &amp;&amp; w[i] &gt; td2) td2 = w[i];</span><br><span class="line">            <span class="built_in">dfs</span>(j, u, td1, td2, d1, d2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        edge[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(edge, edge + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先跑一遍最小生成树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">            sum += w;</span><br><span class="line">            <span class="built_in">add</span>(a, b, w), <span class="built_in">add</span>(b, a, w);</span><br><span class="line">            edge[i].f = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理两点之间路径上的最大边和次大边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">dfs</span>(i, <span class="number">-1</span>, <span class="number">-1e9</span>, <span class="number">-1e9</span>, dist1[i], dist2[i]);</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!edge[i].f) <span class="comment">// 非树边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            ll t;</span><br><span class="line">            <span class="keyword">if</span> (w &gt; dist1[a][b]) t = sum + w - dist1[a][b]; <span class="comment">// 大于当前最大边直接替换最大边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w &gt; dist2[a][b]) t = sum + w - dist2[a][b]; <span class="comment">// 不大于最大边但大于次大边替换次大边</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论】Floyd</title>
      <link href="/posts/15c63d49.html"/>
      <url>/posts/15c63d49.html</url>
      
        <content type="html"><![CDATA[<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="牛的旅行"><a href="#牛的旅行" class="headerlink" title="牛的旅行"></a>牛的旅行</h2><p><a href="https://www.acwing.com/problem/content/1127/">原题链接</a></p><p>农民John的农场里有很多牧区，有的路径连接一些特定的牧区。</p><p>一片所有连通的牧区称为一个牧场。</p><p>但是就目前而言，你能看到至少有两个牧区不连通。</p><p>现在，John想在农场里添加一条路径（注意，恰好一条）。</p><p>一个牧场的直径就是牧场中最远的两个牧区的距离（本题中所提到的所有距离指的都是最短的距离）。</p><p>考虑如下的两个牧场，每一个牧区都有自己的坐标：</p><img src="/posts/15c63d49/2.png" class><p>图 1 是有 5 个牧区的牧场，牧区用“*”表示，路径用直线表示。</p><p>图 1 所示的牧场的直径大约是 12.07106, 最远的两个牧区是 A 和 E，它们之间的最短路径是 A-B-E。</p><p>图 2 是另一个牧场。</p><p>这两个牧场都在John的农场上。</p><p>John将会在两个牧场中各选一个牧区，然后用一条路径连起来，使得连通后这个新的更大的牧场有最小的直径。</p><p>注意，如果两条路径中途相交，我们不认为它们是连通的。</p><p>只有两条路径在同一个牧区相交，我们才认为它们是连通的。</p><p>现在请你编程找出一条连接两个不同牧场的路径，使得连上这条路径后，所有牧场（生成的新牧场和原有牧场）中直径最大的牧场的直径尽可能小。</p><p>输出这个直径最小可能值。</p><p><strong>输入格式</strong></p><p>第 1 行：一个整数 N, 表示牧区数；</p><p>第 2 到 N+1 行：每行两个整数 X,Y， 表示 N 个牧区的坐标。每个牧区的坐标都是不一样的。</p><p>第 N+2 行到第 2*N+1 行：每行包括 N 个数字 ( 0或1 ) 表示一个对称邻接矩阵。</p><p>例如，题目描述中的两个牧场的矩阵描述如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  A B C D E F G H </span><br><span class="line">A 0 1 0 0 0 0 0 0 </span><br><span class="line">B 1 0 1 1 1 0 0 0 </span><br><span class="line">C 0 1 0 0 1 0 0 0 </span><br><span class="line">D 0 1 0 0 1 0 0 0 </span><br><span class="line">E 0 1 1 1 0 0 0 0 </span><br><span class="line">F 0 0 0 0 0 0 1 0 </span><br><span class="line">G 0 0 0 0 0 1 0 1 </span><br><span class="line">H 0 0 0 0 0 0 1 0</span><br></pre></td></tr></table></figure><p>输入数据中至少包括两个不连通的牧区。</p><p><strong>输出格式</strong></p><p>只有一行，包括一个实数，表示所求答案。</p><p>数字保留六位小数。</p><p><strong>数据范围</strong></p><p>$1≤N≤150,$<br>$0≤X,Y≤105$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span></span><br><span class="line"><span class="number">15</span> <span class="number">10</span></span><br><span class="line"><span class="number">20</span> <span class="number">10</span></span><br><span class="line"><span class="number">15</span> <span class="number">15</span></span><br><span class="line"><span class="number">20</span> <span class="number">15</span></span><br><span class="line"><span class="number">30</span> <span class="number">15</span></span><br><span class="line"><span class="number">25</span> <span class="number">10</span></span><br><span class="line"><span class="number">30</span> <span class="number">10</span></span><br><span class="line"><span class="number">01000000</span></span><br><span class="line"><span class="number">10111000</span></span><br><span class="line"><span class="number">01001000</span></span><br><span class="line"><span class="number">01001000</span></span><br><span class="line"><span class="number">01110000</span></span><br><span class="line"><span class="number">00000010</span></span><br><span class="line"><span class="number">00000101</span></span><br><span class="line"><span class="number">00000010</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">22.071068</span></span><br></pre></td></tr></table></figure><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一张图，连通的部分算作一个区域，每个区域的直径为区域中相隔最远的两个点的距离，问在不同区域中添加一条边，得到的最小直径是多少</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先建图，然后跑一遍floyd算出和每一个点相隔最远的点的距离</p><p>得到的最新直径一定大于等于原来的最大直径，因此可以先求出原来的最大直径<code>maxd[i]</code></p><p>加上一条边<code>[i, j]</code>得到的新直径是<code>maxd[i] + maxd[j] + dist[i][j]</code></p><p>二者取最大值即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; PDD;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">155</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> INF = <span class="number">1e20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> d[N][N];</span><br><span class="line"><span class="type">double</span> maxd[N];</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line">PDD q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_dist</span><span class="params">(PDD a, PDD b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx = a.first - b.first;</span><br><span class="line">    <span class="type">double</span> dy = a.second - b.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i].first &gt;&gt; q[i].second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span>) d[i][j] = <span class="built_in">get_dist</span>(q[i], q[j]); <span class="comment">// ij之间有边</span></span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF; <span class="comment">// ij之间无边</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// floyd更新最短路</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> r1 = <span class="number">0</span>; <span class="comment">// 两个牧场中最长的直径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (d[i][j] &lt; INF / <span class="number">2</span>) <span class="comment">// 说明ij之间有边</span></span><br><span class="line">                maxd[i] = <span class="built_in">max</span>(maxd[i], d[i][j]); <span class="comment">// 更新与i最远的点距离</span></span><br><span class="line">        r1 = <span class="built_in">max</span>(r1, maxd[i]); <span class="comment">// 更新直径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> r2 = INF; <span class="comment">// 加边之后的最长值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (d[i][j] &gt; INF / <span class="number">2</span>) <span class="comment">// 说明ij之间无边 可以加边</span></span><br><span class="line">                r2 = <span class="built_in">min</span>(r2, maxd[i] + maxd[j] + <span class="built_in">get_dist</span>(q[i], q[j]));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, <span class="built_in">max</span>(r1, r2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><a href="https://www.acwing.com/problem/content/345/">原题链接</a></p><p>给定 n 个变量和 m 个不等式。其中 n 小于等于 26，变量分别用前 n 的大写英文字母表示。</p><p>不等式之间具有传递性，即若 A&gt;B 且 B&gt;C，则 A&gt;C。</p><p>请从前往后遍历每对关系，每次遍历时判断：</p><p>如果能够确定全部关系且无矛盾，则结束循环，输出确定的次序；<br>如果发生矛盾，则结束循环，输出有矛盾；<br>如果循环结束时没有发生上述两种情况，则输出无定解。</p><p><strong>输入格式</strong></p><p>输入包含多组测试数据。</p><p>每组测试数据，第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含一个不等式，不等式全部为小于关系。</p><p>当输入一行 0 0 时，表示输入终止。</p><p><strong>输出格式</strong></p><p>每组数据输出一个占一行的结果。</p><p>结果可能为下列三种之一：</p><ul><li>如果可以确定两两之间的关系，则输出 <code>Sorted sequence determined after t relations: yyy...y.</code>,其中<code>t</code>指迭代次数，<code>yyy...y</code>是指升序排列的所有变量。</li><li>如果有矛盾，则输出： <code>Inconsistency found after t relations.</code>，其中<code>t</code>指迭代次数。</li><li>如果没有矛盾，且不能确定两两之间的关系，则输出 <code>Sorted sequence cannot be determined.</code>。</li></ul><p><strong>数据范围</strong></p><p>$2≤n≤26，变量只可能为大写字母 A∼Z。$</p><p><strong>输入样例1</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line">A&lt;B</span><br><span class="line">A&lt;C</span><br><span class="line">B&lt;C</span><br><span class="line">C&lt;D</span><br><span class="line">B&lt;D</span><br><span class="line">A&lt;B</span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line">A&lt;B</span><br><span class="line">B&lt;A</span><br><span class="line"><span class="number">26</span> <span class="number">1</span></span><br><span class="line">A&lt;Z</span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例1</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sorted sequence determined after <span class="number">4</span> relations: ABCD.</span><br><span class="line">Inconsistency found after <span class="number">2</span> relations.</span><br><span class="line">Sorted sequence cannot be determined.</span><br></pre></td></tr></table></figure><p><strong>输入样例2</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">6</span></span><br><span class="line">A&lt;F</span><br><span class="line">B&lt;D</span><br><span class="line">C&lt;E</span><br><span class="line">F&lt;D</span><br><span class="line">D&lt;E</span><br><span class="line">E&lt;F</span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例2</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Inconsistency found after <span class="number">6</span> relations.</span><br></pre></td></tr></table></figure><p><strong>输入样例3</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line">A&lt;B</span><br><span class="line">B&lt;C</span><br><span class="line">C&lt;D</span><br><span class="line">D&lt;E</span><br><span class="line">E&lt;A</span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例3</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sorted sequence determined after <span class="number">4</span> relations: ABCDE.</span><br></pre></td></tr></table></figure><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>从前到后遍历给出的关系，如果能确定所有关系就直接输出当前次数和关系，如果前后矛盾则输出矛盾，如果得不到最终关系就输出得不到最终关系</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><strong>&#x3D;&#x3D;传递闭包&#x3D;&#x3D;</strong></p><p>已知<code>a&gt;b</code> <code>b&gt;c</code> 一定可以推出 <code>a&gt;c</code>，根据这个性质，我们可以在得到每个新的判断时进行传递，看看是否不满足原先已知的结论，如果不满足就会出现<code>i</code>和<code>i</code>的关系确定的结果</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> g[N][N], d[N][N]; <span class="comment">// 表示两个字母之间关系（前一个字母小于后一个字母）是否确定</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                d[i][j] |= d[i][k] &amp;&amp; d[k][j]; <span class="comment">// 如果有i-&gt;k k-&gt;j的边 那就加上i-&gt;j的边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (d[i][i]) <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 出现矛盾返回2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!d[i][j] &amp;&amp; !d[j][i])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 遍历所有数对 没确定返回0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 确定就返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get_min</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (!st[j] &amp;&amp; d[j][i]) <span class="comment">// 如果有没出现过的j比i还小的话说明i不是最小值</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="comment">// 否则i就是当前没出现过的数中的最小值</span></span><br><span class="line">            &#123;</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="type">int</span> type = <span class="number">0</span>, t; <span class="comment">// type表示目前关系未确定/确定/矛盾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> str[<span class="number">5</span>];</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="type">int</span> a = str[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>, b = str[<span class="number">2</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!type)</span><br><span class="line">            &#123;</span><br><span class="line">                g[a][b] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">floyd</span>();</span><br><span class="line">                type = <span class="built_in">check</span>();</span><br><span class="line">                <span class="keyword">if</span> (type) t = i; <span class="comment">// t记录经过几次才确定所有关系</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!type) <span class="built_in">puts</span>(<span class="string">&quot;Sorted sequence cannot be determined.&quot;</span>); <span class="comment">// 关系不确定</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;Inconsistency found after &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; relations.\n&quot;</span>; <span class="comment">// 矛盾</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 确定</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Sorted sequence determined after &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; relations: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; <span class="built_in">get_min</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="观光之旅"><a href="#观光之旅" class="headerlink" title="观光之旅"></a>观光之旅</h2><p><a href="https://www.acwing.com/problem/content/346/">原题链接</a></p><p>给定一张无向图，求图中一个至少包含 3 个点的环，环上的节点不重复，并且环上的边的长度之和最小。</p><p>该问题称为无向图的最小环问题。</p><p>你需要输出最小环的方案，若最小环不唯一，输出任意一个均可。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 N 和 M，表示无向图有 N 个点，M 条边。</p><p>接下来 M 行，每行包含三个整数 u，v，l，表示点 u 和点 v 之间有一条边，边长为 l。</p><p><strong>输出格式</strong></p><p>输出占一行，包含最小环的所有节点（按顺序输出），如果不存在则输出 No solution.。</p><p><strong>数据范围</strong></p><p>$1≤N≤100,$<br>$1≤M≤10000,$<br>$1≤l&lt;500$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">300</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">16</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">100</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">15</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>无向图的最小环裸题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>假设环的形式是这样的：（ij均小于k）</p><img src="/posts/15c63d49/1.png" class><p>那么环的长度就是<code>d[i][j] + g[j][k] + g[k][i]</code>（d代表ij在图上的最短距离，g表示两点之间有边的话 边的长度)</p><p>用<code>pos[i][j] = k</code>记录<code>i</code>和<code>j</code>的最短路由k的状态转移，k是路径中编号最大的点</p><p>在floyd中循环每个k，如果<code>d[i][j] + g[j][k] + g[k][i]</code>比当前的最小环长度更小就更新一下</p><p>使用类似中序遍历的算法求出环中的字母</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> d[N][N], g[N][N];</span><br><span class="line"><span class="type">int</span> pos[N][N];</span><br><span class="line"><span class="type">int</span> path[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_path</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos[i][j] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似于中序遍历</span></span><br><span class="line">    <span class="type">int</span> k = pos[i][j];</span><br><span class="line">    <span class="built_in">get_path</span>(i, k);</span><br><span class="line">    path[cnt ++ ] = k;</span><br><span class="line">    <span class="built_in">get_path</span>(k, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) g[i][i] = <span class="number">0</span>; <span class="comment">// 避免统计自环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = INF;</span><br><span class="line">    <span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; k; j ++ )</span><br><span class="line">                <span class="keyword">if</span> ((ll)d[i][j] + g[j][k] + g[k][i] &lt; res) <span class="comment">// 一旦发现比原来的最短路还要短的路径就更新</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res = d[i][j] + g[j][k] + g[k][i]; <span class="comment">// 最短路长度</span></span><br><span class="line">                    <span class="comment">// 更新最短路中的点</span></span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                    path[cnt ++ ] = k;</span><br><span class="line">                    path[cnt ++ ] = i;</span><br><span class="line">                    <span class="built_in">get_path</span>(i, j);</span><br><span class="line">                    path[cnt ++ ] = j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新两点之间的距离 在更新完最小环之后更新所以不会对最小环有影响</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &gt; d[i][k] + d[k][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">                    pos[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == INF) <span class="built_in">puts</span>(<span class="string">&quot;No solution.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ ) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> Floyd </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论】单源最短路</title>
      <link href="/posts/24fd3c3d.html"/>
      <url>/posts/24fd3c3d.html</url>
      
        <content type="html"><![CDATA[<h1 id="单源最短路的建图方式"><a href="#单源最短路的建图方式" class="headerlink" title="单源最短路的建图方式"></a>单源最短路的建图方式</h1><p>最短路问题可以分为以下两类：</p><ul><li>边权非负——朴素Dijkstra、堆优化Dijkstra</li><li>有负权边——Bellman-Ford、SPFA</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="热浪"><a href="#热浪" class="headerlink" title="热浪"></a>热浪</h3><p><a href="https://www.acwing.com/problem/content/1131/">原题链接</a>   </p><p>德克萨斯纯朴的民众们这个夏天正在遭受巨大的热浪！！！</p><p>他们的德克萨斯长角牛吃起来不错，可是它们并不是很擅长生产富含奶油的乳制品。</p><p>农夫John此时身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。</p><p>John已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。</p><p>这些路线包括起始点和终点一共有 T 个城镇，为了方便标号为 1 到 T。</p><p>除了起点和终点外的每个城镇都由 双向道路 连向至少两个其它的城镇。</p><p>每条道路有一个通过费用（包括油费，过路费等等）。</p><p>给定一个地图，包含 C 条直接连接 2 个城镇的道路。</p><p>每条道路由道路的起点 Rs，终点 Re 和花费 Ci 组成。</p><p>求从起始的城镇 Ts 到终点的城镇 Te 最小的总费用。</p><p><strong>输入格式</strong></p><p>第一行: 4 个由空格隔开的整数: T,C,Ts,Te;</p><p>第 2 到第 C+1 行: 第 i+1 行描述第 i 条道路，包含 3 个由空格隔开的整数: Rs,Re,Ci。</p><p><strong>输出格式</strong></p><p>一个单独的整数表示从 Ts 到 Te 的最小总费用。</p><p>数据保证至少存在一条道路。</p><p><strong>数据范围</strong></p><p>$1≤T≤2500$,<br>$1≤C≤6200$,<br>$1≤Ts,Te,Rs,Re≤T$,<br>$1≤Ci≤1000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">11</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">7</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">6</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p><del>板题</del></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>写了个SPFA和堆优化的Dijkstra，详见代码</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2510</span>, M = <span class="number">6200</span> * <span class="number">2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], q[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span> <span class="comment">// SPFA算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(S);</span><br><span class="line">    st[S] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> <span class="comment">// 堆优化Dijkstra</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, S&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> distance = t.first, ver = t.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo 下面的选一个就可以 //</span></span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dist[T] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信使"><a href="#信使" class="headerlink" title="信使"></a>信使</h3><p><a href="https://www.acwing.com/problem/content/1130/">原题链接</a></p><p>战争时期，前线有 n 个哨所，每个哨所可能会与其他若干个哨所之间有通信联系。</p><p>信使负责在哨所之间传递信息，当然，这是要花费一定时间的（以天为单位）。</p><p>指挥部设在第一个哨所。</p><p>当指挥部下达一个命令后，指挥部就派出若干个信使向与指挥部相连的哨所送信。</p><p>当一个哨所接到信后，这个哨所内的信使们也以同样的方式向其他哨所送信。信在一个哨所内停留的时间可以忽略不计。</p><p>直至所有 n 个哨所全部接到命令后，送信才算成功。</p><p>因为准备充足，每个哨所内都安排了足够的信使（如果一个哨所与其他 k 个哨所有通信联系的话，这个哨所内至少会配备 k 个信使）。</p><p>现在总指挥请你编一个程序，计算出完成整个送信过程最短需要多少时间。</p><p><strong>输入格式</strong></p><p>第 1 行有两个整数 n 和 m，中间用 1 个空格隔开，分别表示有 n 个哨所和 m 条通信线路。</p><p>第 2 至 m+1 行：每行三个整数 i、j、k，中间用 1 个空格隔开，表示第 i 个和第 j 个哨所之间存在 双向 通信线路，且这条线路要花费 k 天。</p><p><strong>输出格式</strong></p><p>一个整数，表示完成整个送信过程的最短时间。</p><p>如果不是所有的哨所都能收到信，就输出-1。</p><p><strong>数据范围</strong></p><p>$1≤n≤100,$<br>$1≤m≤200,$<br>$1≤k≤1000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>建图，指挥部在1</p><p>每个点可以给相邻点送信，求所有点都收到信的最短时间</p><p>如果有收不到信的，输出-1</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>对于每个点来说：接收到信的时间等于他到指挥部的最短距离</p><p>因此可以分别求每个点的最短路径，求所有最短路径的最大值</p><p>如果有最短路径是正无穷，说明不能传过去，输出-1</p><p>下方代码使用Floyd算法</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) d[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        d[a][b] = d[b][a] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxx = *<span class="built_in">max_element</span>(d[<span class="number">1</span>] + <span class="number">1</span>, d[<span class="number">1</span>] + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (maxx == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="香甜的黄油"><a href="#香甜的黄油" class="headerlink" title="香甜的黄油"></a>香甜的黄油</h3><p><a href="https://www.acwing.com/problem/content/1129/">原题链接</a></p><p>农夫John发现了做出全威斯康辛州最甜的黄油的方法：糖。</p><p>把糖放在一片牧场上，他知道 N 只奶牛会过来舔它，这样就能做出能卖好价钱的超甜黄油。</p><p>当然，他将付出额外的费用在奶牛上。</p><p>农夫John很狡猾，就像以前的巴甫洛夫，他知道他可以训练这些奶牛，让它们在听到铃声时去一个特定的牧场。</p><p>他打算将糖放在那里然后下午发出铃声，以至他可以在晚上挤奶。</p><p>农夫John知道每只奶牛都在各自喜欢的牧场（一个牧场不一定只有一头牛）。</p><p>给出各头牛在的牧场和牧场间的路线，找出使所有牛到达的路程和最短的牧场（他将把糖放在那）。</p><p>数据保证至少存在一个牧场和所有牛所在的牧场连通。</p><p><strong>输入格式</strong></p><p>第一行: 三个数：奶牛数 N，牧场数 P，牧场间道路数 C。</p><p>第二行到第 N+1 行: 1 到 N 头奶牛所在的牧场号。</p><p>第 N+2 行到第 N+C+1 行：每行有三个数：相连的牧场A、B，两牧场间距 D，当然，连接是双向的。</p><p><strong>输出格式</strong></p><p>共一行，输出奶牛必须行走的最小的距离和。</p><p><strong>数据范围</strong></p><p>$1≤N≤500,$<br>$2≤P≤800,$<br>$1≤C≤1450,$<br>$1≤D≤255$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>若干头牛分别在不同牧场，找到一个牧场使所有牛到该牧场的总距离之和最小</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>求以每个点为起点，其余点到该点的最短路之和</p><p>输出最小值</p><p>以下代码为堆优化Dijkstra</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">810</span>, M = <span class="number">3000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, p;</span><br><span class="line"><span class="type">int</span> id[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, start&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> distance = t.first, ver = t.second;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历奶牛不是遍历牧场</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = id[i];</span><br><span class="line">        <span class="keyword">if</span> (dist[j] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        res += dist[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; id[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存图</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取所有res中的最小值</span></span><br><span class="line">    <span class="type">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; i ++ ) res = <span class="built_in">min</span>(res, <span class="built_in">dijkstra</span>(i));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小花费"><a href="#最小花费" class="headerlink" title="最小花费"></a>最小花费</h3><p><a href="https://www.acwing.com/problem/content/1128/">原题链接</a></p><p>在 n 个人中，某些人的银行账号之间可以互相转账。</p><p>这些人之间转账的手续费各不相同。</p><p>给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 A 最少需要多少钱使得转账后 B 收到 100 元。</p><p><strong>输入格式</strong></p><p>第一行输入两个正整数 n,m，分别表示总人数和可以互相转账的人的对数。</p><p>以下 m 行每行输入三个正整数 x,y,z，表示标号为 x 的人和标号为 y 的人之间互相转账需要扣除 z% 的手续费 ( z&lt;100 )。</p><p>最后一行输入两个正整数 A,B。</p><p>数据保证 A 与 B 之间可以直接或间接地转账。</p><p><strong>输出格式</strong></p><p>输出 A 使得 B 到账 100 元最少需要的总费用。</p><p>精确到小数点后 8 位。</p><p><strong>数据范围</strong></p><p>$1≤n≤2000,$<br>$m≤105$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">103.07153164</span></span><br></pre></td></tr></table></figure><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>n个人互相转账，给出每两个人转账的手续费，询问A最少发出去多少钱使得B可以收到100</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>将每个人看做点，权重是能传过去的百分比（比如说手续费3%，这条边的权重就是0.97），问题就变成了<br>$100&#x3D;d(A)<em>w_1</em>w_2<em>…</em>w_n$<br>想让 $d(A)$ 最小，就要让 $w_i$ 最大<br>所以就是求最短路算法（但是是让权重之积最大）</p><p>下方代码为朴素版Dijkstra</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">double</span> g[N][N];</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &lt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">max</span>(dist[j], dist[t] * g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="type">double</span> z = (<span class="number">100.0</span> - c) / <span class="number">100</span>;</span><br><span class="line">        g[a][b] = g[b][a] = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; S &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; <span class="number">100</span> / dist[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最优乘车"><a href="#最优乘车" class="headerlink" title="最优乘车"></a>最优乘车</h3><p><a href="https://www.acwing.com/problem/content/922/">原题链接</a></p><p>H 城是一个旅游胜地，每年都有成千上万的人前来观光。</p><p>为方便游客，巴士公司在各个旅游景点及宾馆，饭店等地都设置了巴士站并开通了一些单程巴士线路。</p><p>每条单程巴士线路从某个巴士站出发，依次途经若干个巴士站，最终到达终点巴士站。</p><p>一名旅客最近到 H 城旅游，他很想去 S 公园游玩，但如果从他所在的饭店没有一路巴士可以直接到达 S 公园，则他可能要先乘某一路巴士坐几站，再下来换乘同一站台的另一路巴士，这样换乘几次后到达 S 公园。</p><p>现在用整数 1,2,…N 给 H 城的所有的巴士站编号，约定这名旅客所在饭店的巴士站编号为 1，S 公园巴士站的编号为 N。</p><p>写一个程序，帮助这名旅客寻找一个最优乘车方案，使他在从饭店乘车到 S 公园的过程中换乘的次数最少。</p><p><strong>输入格式</strong></p><p>第一行有两个数字 M 和 N，表示开通了 M 条单程巴士线路，总共有 N 个车站。</p><p>从第二行到第 M+1 行依次给出了第 1 条到第 M 条巴士线路的信息，其中第 i+1 行给出的是第 i 条巴士线路的信息，从左至右按运行顺序依次给出了该线路上的所有站号，相邻两个站号之间用一个空格隔开。</p><p><strong>输出格式</strong></p><p>共一行，如果无法乘巴士从饭店到达 S 公园，则输出 NO，否则输出最少换乘次数，换乘次数为 0 表示不需换车即可到达。</p><p><strong>数据范围</strong></p><p>$1≤M≤100,$<br>$2≤N≤500$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给出多条公交车线路，求从起点到终点最少的换乘次数是多少</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>这题的难度在建图上，如果有一条线路是 1-&gt;3-&gt;5-&gt;7，从1开始坐，不管做到3还是5还是7，都不需要换乘，因此可以将1向后面的所有点都连一条边</p><p>建完图直接BFS即可</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">bool</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> stop[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[t][i] &amp;&amp; dist[i] &gt; dist[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, line);</span><br><span class="line">        <span class="function">stringstream <span class="title">ssin</span><span class="params">(line)</span></span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, p;</span><br><span class="line">        <span class="keyword">while</span> (ssin &gt;&gt; p) stop[cnt ++ ] = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; cnt; k ++ )</span><br><span class="line">                g[stop[j]][stop[k]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">max</span>(dist[n] - <span class="number">1</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="昂贵的聘礼"><a href="#昂贵的聘礼" class="headerlink" title="昂贵的聘礼"></a>昂贵的聘礼</h3><p><a href="https://www.acwing.com/problem/content/905/">原题链接</a></p><p>年轻的探险家来到了一个印第安部落里。</p><p>在那里他和酋长的女儿相爱了，于是便向酋长去求亲。</p><p>酋长要他用 10000 个金币作为聘礼才答应把女儿嫁给他。</p><p>探险家拿不出这么多金币，便请求酋长降低要求。</p><p>酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要 8000 金币。如果你能够弄来他的水晶球，那么只要 5000 金币就行了。”</p><p>探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。</p><p>探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。</p><p>不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。</p><p>探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。</p><p>另外他要告诉你的是，在这个部落里，等级观念十分森严。</p><p>地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。</p><p>他是一个外来人，所以可以不受这些限制。</p><p>但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。</p><p>因此你需要在考虑所有的情况以后给他提供一个最好的方案。</p><p>为了方便起见，我们把所有的物品从 1 开始进行编号，酋长的允诺也看作一个物品，并且编号总是 1。</p><p>每个物品都有对应的价格 P，主人的地位等级 L，以及一系列的替代品 Ti 和该替代品所对应的”优惠” Vi。</p><p>如果两人地位等级差距超过了 M，就不能”间接交易”。</p><p>你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p><p><strong>输入格式</strong></p><p>输入第一行是两个整数 M，N，依次表示地位等级差距限制和物品的总数。</p><p>接下来按照编号从小到大依次给出了 N 个物品的描述。</p><p>每个物品的描述开头是三个非负整数 P、L、X，依次表示该物品的价格、主人的地位等级和替代品总数。</p><p>接下来 X 行每行包括两个整数 T 和 V，分别表示替代品的编号和”优惠价格”。</p><p><strong>输出格式</strong></p><p>输出最少需要的金币数。</p><p><strong>数据范围</strong></p><p>$1≤N≤100,$<br>$1≤P≤10000,$<br>$1≤L,M≤N,$<br>$0≤X&lt;N$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">10000</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">8000</span></span><br><span class="line"><span class="number">3</span> <span class="number">5000</span></span><br><span class="line"><span class="number">1000</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">200</span></span><br><span class="line"><span class="number">3000</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">200</span></span><br><span class="line"><span class="number">50</span> <span class="number">2</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5250</span></span><br></pre></td></tr></table></figure><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>有个人想娶酋长的女儿，酋长需要指定数量金钱的聘礼，或者拿一样东西和少一点的金钱替代，这样东西的所有者需要指定的金钱换这样东西，或者拿另一样东西和少一点的金钱代替，以此类推…同时，所有者阶级超过指定数字的不能间接交易，现在给出所有东西的价值、替代方式和所有者阶级，求这个人最少用多少钱能娶到酋长的女儿</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>题目很难读懂，读懂后发现难点还是在建图上，我们把每样物品看作一个点，根据样例可以建出以下图：</p><img src="/posts/24fd3c3d/1.png" class><p>此时设置一个<strong>虚拟源点</strong>，所有情况都从虚拟源点开始，得到以下图：</p><img src="/posts/24fd3c3d/2.png" class><p>从虚拟源点开始求到点1的最短路即可</p><p>那么阶级问题怎么考虑呢？</p><p>注意到阶级最高只有100，如果阶级限制是1的话，最多也只有100种划分情况，所以直接枚举所有的阶级划分就可以了</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N][N], level[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> down, <span class="type">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) <span class="comment">// 更新所有在阶级区间范围内且与t有邻边的点</span></span><br><span class="line">            <span class="keyword">if</span> (w[t][j] != <span class="number">0x3f3f3f3f</span> &amp;&amp; level[j] &gt;= down &amp;&amp; level[j] &lt;= up)</span><br><span class="line">                dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + w[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存图</span></span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) w[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> price, cnt;</span><br><span class="line">        cin &gt;&gt; price &gt;&gt; level[i] &gt;&gt; cnt;</span><br><span class="line">        w[<span class="number">0</span>][i] = <span class="built_in">min</span>(price, w[<span class="number">0</span>][i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cnt -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> id, cost;</span><br><span class="line">            cin &gt;&gt; id &gt;&gt; cost;</span><br><span class="line">            w[id][i] = <span class="built_in">min</span>(w[id][i], cost);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = level[<span class="number">1</span>] - m; i &lt;= level[<span class="number">1</span>]; i ++ )</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">dijkstra</span>(i, i + m));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单源最短路的综合应用"><a href="#单源最短路的综合应用" class="headerlink" title="单源最短路的综合应用"></a>单源最短路的综合应用</h1><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="新年好"><a href="#新年好" class="headerlink" title="新年好"></a>新年好</h3><p><a href="https://www.acwing.com/problem/content/1137/">原题链接</a></p><p>重庆城里有 n 个车站，m 条 双向 公路连接其中的某些车站。</p><p>每两个车站最多用一条公路连接，从任何一个车站出发都可以经过一条或者多条公路到达其他车站，但不同的路径需要花费的时间可能不同。</p><p>在一条路径上花费的时间等于路径上所有公路需要的时间之和。</p><p>佳佳的家在车站 1，他有五个亲戚，分别住在车站 a,b,c,d,e。</p><p>过年了，他需要从自己的家出发，拜访每个亲戚（顺序任意），给他们送去节日的祝福。</p><p>怎样走，才需要最少的时间？</p><p><strong>输入格式</strong></p><p>第一行：包含两个整数 n,m，分别表示车站数目和公路数目。</p><p>第二行：包含五个整数 a,b,c,d,e，分别表示五个亲戚所在车站编号。</p><p>以下 m 行，每行三个整数 x,y,t，表示公路连接的两个车站编号和时间。</p><p><strong>输出格式</strong></p><p>输出仅一行，包含一个整数 T，表示最少的总时间。</p><p><strong>数据范围</strong></p><p>$1≤n≤50000,$<br>$1≤m≤105,$<br>$1&lt;a,b,c,d,e≤n,$<br>$1≤x,y≤n,$<br>$1≤t≤100$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure><h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><p>找到一条至少经过指定五个点的最短路径</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>我们只关心必须要经过的五个点，其他点有没有经过不重要</p><p>先用Dijkstra算出每两个点之间的最短距离，然后枚举五个点的所有情况取最小值即可</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[<span class="number">6</span>][N];</span><br><span class="line"><span class="type">int</span> source[<span class="number">6</span>];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> dist[])</span> <span class="comment">// 堆优化Dijkstra</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, N * <span class="number">4</span>); <span class="comment">// 因为dist大小不固定所以不能用sizeof</span></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, start&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> start, <span class="type">int</span> distance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; <span class="number">5</span>) <span class="keyword">return</span> distance;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> next = source[i];</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(u + <span class="number">1</span>, i, distance + dist[start][next]));</span><br><span class="line">            st[i] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    source[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++ ) cin &gt;&gt; source[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>; i ++ ) <span class="built_in">dijkstra</span>(source[i], dist[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通信线路"><a href="#通信线路" class="headerlink" title="通信线路"></a>通信线路</h3><p><a href="https://www.acwing.com/problem/content/342/">原题链接</a></p><p>在郊区有 N 座通信基站，P 条 双向 电缆，第 i 条电缆连接基站 Ai 和 Bi。</p><p>特别地，1 号基站是通信公司的总站，N 号基站位于一座农场中。</p><p>现在，农场主希望对通信线路进行升级，其中升级第 i 条电缆需要花费 Li。</p><p>电话公司正在举行优惠活动。</p><p>农产主可以指定一条从 1 号基站到 N 号基站的路径，并指定路径上不超过 K 条电缆，由电话公司免费提供升级服务。</p><p>农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。</p><p>求至少用多少钱可以完成升级。</p><p><strong>输入格式</strong></p><p>第 1 行：三个整数 N，P，K。</p><p>第 2..P+1 行：第 i+1 行包含三个整数 Ai,Bi,Li。</p><p><strong>输出格式</strong></p><p>包含一个整数表示最少花费。</p><p>若 1 号基站与 N 号基站之间不存在路径，则输出 −1。</p><p><strong>数据范围</strong></p><p>$0≤K&lt;N≤1000,$<br>$1≤P≤10000,$<br>$1≤Li≤1000000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h4><p>任选一条从 1 到 N 的路径，公司可以免费升级k条路线，只需要支付除了这k条路线之外的最大值，求这个值的最小值</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>一条路线的权重可以直接理解成第k+1长的边权，如果边数小于等于k，则该路线的权重是0</p><p>于是想到 **&#x3D;&#x3D;二分&#x3D;&#x3D;**（使用二分的条件是所求的答案是某个分界点，分界点的一边满足性质，另一边不满足性质）</p><p>对于我们所求的答案x，性质为从1到N的路线上大于x的边数小于等于k，大于x的情况满足性质，小于x的情况不满足性质</p><p>如何来判断呢？</p><p>将大于x的边权设为1，其余设为0，那么大于x的边数就等于路径长度</p><p>于是问题就转化成了边权为0&#x2F;1的最短路问题 -&gt; <strong>&#x3D;&#x3D;双端队列&#x3D;&#x3D;</strong></p><p>（细节问题：注意二分边界是0到1e6+1，因为如果定为1e6的话，无解和解为1e6的情况都会返回1e6）</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[t]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i], x = w[i] &gt; bound;</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + x)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + x;</span><br><span class="line">                <span class="keyword">if</span> (!x) q.<span class="built_in">push_front</span>(j);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[n] &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">1e6</span> + <span class="number">1</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="道路与航线"><a href="#道路与航线" class="headerlink" title="道路与航线"></a>道路与航线</h3><p><a href="https://www.acwing.com/problem/content/344/">原题链接</a></p><p>农夫约翰正在一个新的销售区域对他的牛奶销售方案进行调查。</p><p>他想把牛奶送到 T 个城镇，编号为 1∼T。</p><p>这些城镇之间通过 R 条道路 (编号为 1 到 R) 和 P 条航线 (编号为 1 到 P) 连接。</p><p>每条道路 i 或者航线 i 连接城镇 Ai 到 Bi，花费为 Ci。</p><p>对于道路，$0≤C_i≤10000$；然而航线的花费很神奇，花费 $C_i$ 可能是负数$(−10,000≤C_i≤10000)$。</p><p>道路是双向的，可以从 $A_i$ 到 $B_i$，也可以从 $B_i$ 到 $A_i$，花费都是 $C_i$。</p><p>然而航线与之不同，只可以从 $A_i$ 到 $B_i$。</p><p>事实上，由于最近恐怖主义太嚣张，为了社会和谐，出台了一些政策：保证如果有一条航线可以从 $A_i$ 到 $B_i$，那么保证不可能通过一些道路和航线从 $B_i$ 回到 $A_i$。</p><p>由于约翰的奶牛世界公认十分给力，他需要运送奶牛到每一个城镇。</p><p>他想找到从发送中心城镇 S 把奶牛送到每个城镇的最便宜的方案。</p><p><strong>输入格式</strong></p><p>第一行包含四个整数 T,R,P,S。</p><p>接下来 R 行，每行包含三个整数（表示一个道路）Ai,Bi,Ci。</p><p>接下来 P 行，每行包含三个整数（表示一条航线）Ai,Bi,Ci。</p><p><strong>输出格式</strong></p><p>第 1..T 行：第 i 行输出从 S 到达城镇 i 的最小花费，如果不存在，则输出 NO PATH。</p><p><strong>数据范围</strong></p><p>$1≤T≤25000,$<br>$1≤R,P≤50000,$<br>$1≤Ai,Bi,S≤T$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">-100</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">-100</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">-10</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NO PATH</span><br><span class="line">NO PATH</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">-95</span></span><br><span class="line"><span class="number">-100</span></span><br></pre></td></tr></table></figure><h4 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h4><p>图中有两种路线：</p><ul><li>道路：无向边，边权为正</li><li>航线：有向边，边权可正可负</li></ul><p>问把牛奶送到每个点的最短路径</p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>首先看到边权有负会想到spfa，但是这个做法会被卡</p><p>由题意可知，如果 a 到 b 有航线，那 b 就不可能到 a ，说明 a b 间也不存在道路</p><p>根据这个特点可以用 <strong>&#x3D;&#x3D;DFS&#x3D;&#x3D;</strong> 把整张图分成几个块，两个不同的块之间只有航线相连，每个块均连通（因此每个块中都不存在航线，因为航线连接的两个点是单向的），因为每个块中只有道路也就是只有正向边，所以每个块内可以用 <strong>&#x3D;&#x3D;Dijkstra&#x3D;&#x3D;</strong> ，块与块之间是有向边，所以可以用 <strong>&#x3D;&#x3D;拓扑序列&#x3D;&#x3D;</strong> 做</p><p>具体步骤：</p><ol><li>先输入所有双向道路，然后DFS出所有连通块，记录两个数组：<ul><li><code>id[]</code>存储每个点属于哪个连通块</li><li><code>vector&lt;int&gt; block[]</code>存储每个连通块有哪些点</li></ul></li><li>输入所有航线，统计出每个连通块入度</li><li>按照拓扑序列依次出了每个连通块，先将所有入度为0的连通块编号加入队列中</li><li>每次从队头取出一个连通块的编号bid</li><li>将该block[bid]中的所有点加入堆中，然后对堆中所有点做Dijkstra</li><li>每次取出堆中距离最小的点ver</li><li>遍历ver的所有邻点j，如果id[j]&#x3D;&#x3D;id[ver]，如果j能被更新，就将j插入堆中，如果不相等，就说明该边是航线，则将id[j]这个连通块的入度减1，如果入度减为0，就将其插入拓扑序列的队列中</li></ol><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25010</span>, M = <span class="number">150010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, mr, mp, S;</span><br><span class="line"><span class="type">int</span> id[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], din[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; block[N];</span><br><span class="line"><span class="type">int</span> bcnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> bid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[u] = bid, block[bid].<span class="built_in">push_back</span>(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!id[j]) <span class="built_in">dfs</span>(j, bid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> bid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : block[bid]) heap.<span class="built_in">push</span>(&#123;dist[u], u&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (id[ver] != id[j] &amp;&amp; -- din[id[j]] == <span class="number">0</span>) q.<span class="built_in">push</span>(id[j]);</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (id[j] == id[ver]) heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bcnt; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!din[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">dijkstra</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mr &gt;&gt; mp &gt;&gt; S;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mr -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!id[i])</span><br><span class="line">        &#123;</span><br><span class="line">            bcnt ++ ;</span><br><span class="line">            <span class="built_in">dfs</span>(i, bcnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mp -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        din[id[b]] ++ ;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (dist[i] &gt; INF / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;NO PATH&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; dist[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最优贸易"><a href="#最优贸易" class="headerlink" title="最优贸易"></a>最优贸易</h3><p><a href="https://www.acwing.com/problem/content/343/">原题链接</a></p><p>C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。</p><p>任意两个城市之间最多只有一条道路直接相连。</p><p>这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。</p><p>C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。</p><p>但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。</p><p>商人阿龙来到 C 国旅游。</p><p>当他得知“同一种商品在不同城市的价格可能会不同”这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚一点旅费。</p><p>设 C 国 n 个城市的标号从 1∼n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。</p><p>在旅游的过程中，任何城市可以被重复经过多次，但不要求经过所有 n 个城市。</p><p>阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。</p><p>因为阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。</p><p>现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。</p><p>请你告诉阿龙，他最多能赚取多少旅费。</p><p>注意：本题数据有加强。</p><p><strong>输入格式</strong></p><p>第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。</p><p>第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。</p><p>接下来 m 行，每行有 3 个正整数，x，y，z，每两个整数之间用一个空格隔开。</p><p>如果 z&#x3D;1，表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z&#x3D;2，表示这条道路为城市 x 和城市 y 之间的双向道路。</p><p><strong>输出格式</strong></p><p>一个整数，表示答案。</p><p><strong>数据范围</strong></p><p>$1≤n≤100000,$<br>$1≤m≤500000,$<br>$1≤各城市水晶球价格≤100$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h4><p>有n个城市，每个城市水晶球的价值不一样，两个城市之间的道路可能是有向边可能是无向边，一个人要从1到n，在一个城市买水晶球另一个城市卖出，每个点可以经过多次且不一定要经过所有点，问最多赚多少</p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p><strong>&#x3D;&#x3D;dp&#x3D;&#x3D;</strong></p><p>由题目可知，会在1-n的一条路径上先买入水晶球再卖出水晶球</p><p>我们设一个点x为分界点，在x前面（包括x）买入水晶球，在x后面（包括x）卖出水晶球，现在问题就转换成了在x前用最低的价格买入，在x后用最高的价格卖出</p><p>用 <strong>&#x3D;&#x3D;spfa&#x3D;&#x3D;</strong> 算出所有点前面的最低价格和后面的最高价格，然后依次遍历每一个点为分界点，用该点后面的最高价格减去前面的最低价格，输出这个值的最大值即可</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">2000010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> hs[N], ht[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dmin[N], dmax[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> dist[], <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dmin);</span><br><span class="line">        dist[<span class="number">1</span>] = w[<span class="number">1</span>];</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">-0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dmax);</span><br><span class="line">        dist[n] = w[n];</span><br><span class="line">        q.<span class="built_in">push</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> ((type == <span class="number">0</span> &amp;&amp; dist[j] &gt; <span class="built_in">min</span>(dist[t], w[j])) || (type == <span class="number">1</span> &amp;&amp; dist[j] &lt; <span class="built_in">max</span>(dist[t], w[j])))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == <span class="number">0</span>) dist[j] = <span class="built_in">min</span>(dist[t], w[j]);</span><br><span class="line">                <span class="keyword">else</span> dist[j] = <span class="built_in">max</span>(dist[t], w[j]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(hs, <span class="number">-1</span>, <span class="keyword">sizeof</span> hs);</span><br><span class="line">    <span class="built_in">memset</span>(ht, <span class="number">-1</span>, <span class="keyword">sizeof</span> ht);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(hs, a, b), <span class="built_in">add</span>(ht, b, a);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">2</span>) <span class="built_in">add</span>(hs, b, a), <span class="built_in">add</span>(ht, a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spfa</span>(hs, dmin, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">spfa</span>(ht, dmax, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, dmax[i] - dmin[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单源最短路的扩展应用"><a href="#单源最短路的扩展应用" class="headerlink" title="单源最短路的扩展应用"></a>单源最短路的扩展应用</h1><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><h3 id="选择最佳线路"><a href="#选择最佳线路" class="headerlink" title="选择最佳线路"></a>选择最佳线路</h3><p><a href="https://www.acwing.com/problem/content/1139/">原题链接</a></p><p>有一天，琪琪想乘坐公交车去拜访她的一位朋友。</p><p>由于琪琪非常容易晕车，所以她想尽快到达朋友家。</p><p>现在给定你一张城市交通路线图，上面包含城市的公交站台以及公交线路的具体分布。</p><p>已知城市中共包含 n 个车站（编号1~n）以及 m 条公交线路。</p><p>每条公交线路都是 单向的，从一个车站出发直接到达另一个车站，两个车站之间可能存在多条公交线路。</p><p>琪琪的朋友住在 s 号车站附近。</p><p>琪琪可以在任何车站选择换乘其它公共汽车。</p><p>请找出琪琪到达她的朋友家（附近的公交车站）需要花费的最少时间。</p><p><strong>输入格式</strong></p><p>输入包含多组测试数据。</p><p>每组测试数据第一行包含三个整数 n,m,s，分别表示车站数量，公交线路数量以及朋友家附近车站的编号。</p><p>接下来 m 行，每行包含三个整数 p,q,t，表示存在一条线路从车站 p 到达车站 q，用时为 t。</p><p>接下来一行，包含一个整数 w，表示琪琪家附近共有 w 个车站，她可以在这 w 个车站中选择一个车站作为始发站。</p><p>再一行，包含 w 个整数，表示琪琪家附近的 w 个车站的编号。</p><p><strong>输出格式</strong></p><p>每个测试数据输出一个整数作为结果，表示所需花费的最少时间。</p><p>如果无法达到朋友家的车站，则输出 -1。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><p>$n≤1000,m≤20000,$<br>$1≤s≤n,$<br>$0&lt;w&lt;n,$<br>$0&lt;t≤1000$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">8</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h3><p>给出一张图，琪琪可以从指定多个点的任意一个点出发，到达指定的一个点，问最短路</p><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p><strong>&#x3D;&#x3D;多个起点-&gt;虚拟源点&#x3D;&#x3D;</strong></p><p>起初将所有起点入队即可</p><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> scnt; <span class="comment">// 琪琪家旁边车站的个数</span></span><br><span class="line">    cin &gt;&gt; scnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (scnt -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u;</span><br><span class="line">        cin &gt;&gt; u;</span><br><span class="line">        dist[u] = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(u); <span class="comment">// 先将所有真实起点都入队</span></span><br><span class="line">        st[u] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;T) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">spfa</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist[T] == INF) dist[T] = <span class="number">-1</span>;</span><br><span class="line">        cout &lt;&lt; dist[T] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拯救大兵瑞恩"><a href="#拯救大兵瑞恩" class="headerlink" title="拯救大兵瑞恩"></a>拯救大兵瑞恩</h3><p><a href="https://www.acwing.com/problem/content/1133/">原题链接</a></p><p>1944 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。</p><p>瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。</p><p>迷宫的外形是一个长方形，其南北方向被划分为 N 行，东西方向被划分为 M 列， 于是整个迷宫被划分为 N×M 个单元。</p><p>每一个单元的位置可用一个有序数对 (单元的行号, 单元的列号) 来表示。</p><p>南北或东西方向相邻的 2 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。</p><p>注意： 门可以从两个方向穿过，即可以看成一条无向边。</p><p>迷宫中有一些单元存放着钥匙，同一个单元可能存放 多把钥匙，并且所有的门被分成 P 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。</p><p>大兵瑞恩被关押在迷宫的东南角，即 (N,M) 单元里，并已经昏迷。</p><p>迷宫只有一个入口，在西北角。</p><p>也就是说，麦克可以直接进入 (1,1) 单元。</p><p>另外，麦克从一个单元移动到另一个相邻单元的时间为 1，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。</p><p>试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。</p><p><strong>输入格式</strong></p><p>第一行有三个整数,分别表示 N,M,P 的值。</p><p>第二行是一个整数 k，表示迷宫中门和墙的总数。</p><p>接下来 k 行，每行包含五个整数，$X_{i1},Y_{i1},X_{i2},Y_{i2},G_{i}$：当 $G_i≥1$ 时，表示 $(X-{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一扇第 $G_i$ 类的门，当 $G_i&#x3D;0$ 时，表示 $(X_{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一面不可逾越的墙。</p><p>接下来一行，包含一个整数 S，表示迷宫中存放的钥匙的总数。</p><p>接下来 $S$ 行，每行包含三个整数 $X_{i1},Y_{i1},Q_i$，表示 $(X_{i1},Y_{i1}) $单元里存在一个能开启第 $Q_i$ 类门的钥匙。</p><p><strong>输出格式</strong></p><p>输出麦克营救到大兵瑞恩的最短时间。</p><p>如果问题无解，则输出 -1。</p><p><strong>数据范围</strong></p><p>$|Xi1−Xi2|+|Yi1−Yi2|&#x3D;1,$<br>$0≤Gi≤P,$<br>$1≤Qi≤P,$<br>$1≤N,M,P≤10,$<br>$1≤k≤150$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><h3 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h3><p>给出迷宫，其中有不能穿过的墙， 能穿过的路和需要钥匙才能穿过的门，有一些格子上有钥匙，每移动一格消耗时间1，求从左上到右下的最短路</p><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>把迷宫的每一格看做一个点，每两个点之间能走就说明有边，先建图</p><p>用二进制的01表示当前身上有没有每一把钥匙的状态</p><p><code>dist[i][j]</code>表示在第i个点，身上钥匙的状态是j时的最短路</p><p>然后跑一遍 <strong>&#x3D;&#x3D;双端队列BFS&#x3D;&#x3D;</strong></p><p>如果该点有钥匙，就捡起来，更新dist的状态，新状态加入队头</p><p>然后看这个点的所有邻边：</p><ul><li>有门没钥匙</li><li>没有门，可更新的话新状态加入队尾</li></ul><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11</span>, M = <span class="number">360</span>, P = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k, p;</span><br><span class="line"><span class="type">int</span> h[N * N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> g[N][N], key[N * N];</span><br><span class="line"><span class="type">int</span> dist[N * N][P]; <span class="comment">// dist[i][j]表示在i位置有j钥匙的最短路距离</span></span><br><span class="line"><span class="type">bool</span> st[N * N][P];</span><br><span class="line"></span><br><span class="line">set&lt;PII&gt; edges;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = i + dx[u], y = j + dy[u];</span><br><span class="line">                <span class="keyword">if</span> (!x || x &gt; n || !y || y &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> a = g[i][j], b = g[x][y];</span><br><span class="line">                <span class="keyword">if</span> (!edges.<span class="built_in">count</span>(&#123;a, b&#125;)) <span class="built_in">add</span>(a, b, <span class="number">0</span>); <span class="comment">// 之前没处理过就在这两点之间加边</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    deque&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[t.first][t.second]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.first == n * m) <span class="keyword">return</span> dist[t.first][t.second];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key[t.first]) <span class="comment">// 该点有钥匙</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> state = t.second | key[t.first]; <span class="comment">// 状态加上该钥匙</span></span><br><span class="line">            <span class="keyword">if</span> (dist[t.first][state] &gt; dist[t.first][t.second]) <span class="comment">// 可以更新</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[t.first][state] = dist[t.first][t.second];</span><br><span class="line">                q.<span class="built_in">push_front</span>(&#123;t.first, state&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t.first]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (w[i] &amp;&amp; !(t.second &gt;&gt; w[i] - <span class="number">1</span> &amp; <span class="number">1</span>)) <span class="keyword">continue</span>; <span class="comment">// 有门没钥匙</span></span><br><span class="line">            <span class="keyword">if</span> (dist[j][t.second] &gt; dist[t.first][t.second] + <span class="number">1</span>) <span class="comment">// 没有阻碍的路</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j][t.second] = dist[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push_back</span>(&#123;j, t.second&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, t = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            g[i][j] = t ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (k -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, x2, y1, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="type">int</span> a = g[x1][y1], b = g[x2][y2];</span><br><span class="line"></span><br><span class="line">        edges.<span class="built_in">insert</span>(&#123;a, b&#125;), edges.<span class="built_in">insert</span>(&#123;b, a&#125;); <span class="comment">// 记录哪些边加过了</span></span><br><span class="line">        <span class="keyword">if</span> (c) <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c); <span class="comment">// 有钥匙就在这两点之间连边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (s -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        key[g[x][y]] |= <span class="number">1</span> &lt;&lt; c - <span class="number">1</span>; <span class="comment">// 钥匙加到该点上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短路计数"><a href="#最短路计数" class="headerlink" title="最短路计数"></a>最短路计数</h3><p><a href="https://www.acwing.com/problem/content/1136/">原题链接</a></p><p>给出一个 N 个顶点 M 条边的无向无权图，顶点编号为 1 到 N。</p><p>问从顶点 1 开始，到其他每个点的最短路有几条。</p><p><strong>输入格式</strong></p><p>第一行包含 2 个正整数 N,M，为图的顶点数与边数。</p><p>接下来 M 行，每行两个正整数 x,y，表示有一条顶点 x 连向顶点 y 的边，请注意可能有自环与重边。</p><p><strong>输出格式</strong></p><p>输出 N 行，每行一个非负整数，第 i 行输出从顶点 1 到顶点 i 有多少条不同的最短路，由于答案有可能会很大，你只需要输出对 100003 取模后的结果即可。</p><p>如果无法到达顶点 i 则输出 0。</p><p><strong>数据范围</strong></p><p>$1≤N≤105,$<br>$1≤M≤2×105$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="题意-12"><a href="#题意-12" class="headerlink" title="题意"></a>题意</h4><p>给出一张图，问从1到每个点的最短路条数</p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>这题求最短路的数量而不是最短路</p><p>bfs和Dijkstra每个点都只入一次队，出队时即为最短路，但spfa不能保证出队时是最短路，本题选用bfs &#x2F; Dijkstra</p><p>当新的点最短路可以更新到比当前值小，那么最短路的数量就是新的点的源点的最短路数量</p><p>当新的点最短路可以更新到和当前值一样，那最短路的数量就加上新的点的源点的最短路数量</p><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">400010</span>, mod = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                cnt[j] = cnt[t];</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dist[j] == dist[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[j] = (cnt[j] + cnt[t]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cout &lt;&lt; cnt[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观光"><a href="#观光" class="headerlink" title="观光"></a>观光</h3><p><a href="https://www.acwing.com/problem/content/385/">原题链接</a></p><p>“您的个人假期”旅行社组织了一次比荷卢经济联盟的巴士之旅。</p><p>比荷卢经济联盟有很多公交线路。</p><p>每天公共汽车都会从一座城市开往另一座城市。</p><p>沿途汽车可能会在一些城市（零或更多）停靠。</p><p>旅行社计划旅途从 S 城市出发，到 F 城市结束。</p><p>由于不同旅客的景点偏好不同，所以为了迎合更多旅客，旅行社将为客户提供多种不同线路。</p><p>游客可以选择的行进路线有所限制，要么满足所选路线总路程为 S 到 F 的最小路程，要么满足所选路线总路程仅比最小路程多一个单位长度。</p><img src="/posts/24fd3c3d/3.png" class><p>如上图所示，如果 S&#x3D;1，F&#x3D;5，则这里有两条最短路线 1→2→5,1→3→5，长度为 6；有一条比最短路程多一个单位长度的路线 1→3→4→5，长度为 7。</p><p>现在给定比荷卢经济联盟的公交路线图以及两个城市 S 和 F，请你求出旅行社最多可以为旅客提供多少种不同的满足限制条件的线路。</p><p><strong>输入格式</strong></p><p>第一行包含整数 T，表示共有 T 组测试数据。</p><p>每组数据第一行包含两个整数 N 和 M，分别表示总城市数量和道路数量。</p><p>接下来 M 行，每行包含三个整数 A,B,L，表示有一条线路从城市 A 通往城市 B，长度为 L。</p><p>需注意，线路是 单向的，存在从 A 到 B 的线路不代表一定存在从 B 到 A 的线路，另外从城市 A 到城市 B 可能存在多个不同的线路。</p><p>接下来一行，包含两个整数 S 和 F，数据保证 S 和 F 不同，并且 S、F 之间至少存在一条线路。</p><p><strong>输出格式</strong></p><p>每组数据输出一个结果，每个结果占一行。</p><p>数据保证结果不超过 109。</p><p><strong>数据范围</strong></p><p>$2≤N≤1000,$<br>$1≤M≤10000,$<br>$1≤L≤1000，$<br>$1≤A,B,S,F≤N$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">7</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="题意-13"><a href="#题意-13" class="headerlink" title="题意"></a>题意</h4><p>给出一张图，求给定两个点之间的最短路和次短路条数之和（次短路需要比最短路长度严格多1，不满足该条件就没有次短路）</p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>用堆优化Dijkstra求出最短路次短路数量（同时记录具体值）</p><p>详细看下方代码注释</p><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id, type, dist; <span class="comment">// 第id个点，最or次短路，具体值</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Ver &amp;W) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dist &gt; W.dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N][<span class="number">2</span>], cnt[N][<span class="number">2</span>]; <span class="comment">// dist表示最/次短路值 cnt表示最/次短路条数</span></span><br><span class="line"><span class="type">bool</span> st[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line"></span><br><span class="line">    dist[S][<span class="number">0</span>] = <span class="number">0</span>, cnt[S][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    priority_queue&lt;Ver, vector&lt;Ver&gt;, greater&lt;Ver&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;S, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.id, type = t.type, distance = t.dist, count = cnt[ver][type];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver][type]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver][type] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j][<span class="number">0</span>] &gt; distance + w[i]) <span class="comment">// 可以更新最短路</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j][<span class="number">1</span>] = dist[j][<span class="number">0</span>], cnt[j][<span class="number">1</span>] = cnt[j][<span class="number">0</span>]; <span class="comment">// 更新次短路</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, dist[j][<span class="number">1</span>]&#125;);</span><br><span class="line">                dist[j][<span class="number">0</span>] = distance + w[i], cnt[j][<span class="number">0</span>] = count; <span class="comment">// 更新最短路</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;j, <span class="number">0</span>, dist[j][<span class="number">0</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dist[j][<span class="number">0</span>] == distance + w[i]) cnt[j][<span class="number">0</span>] += count; <span class="comment">// 更新最短路条数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dist[j][<span class="number">1</span>] &gt; distance + w[i]) <span class="comment">// 可以更新次短路</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j][<span class="number">1</span>] = distance + w[i], cnt[j][<span class="number">1</span>] = count; <span class="comment">// 更新次短路</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, dist[j][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dist[j][<span class="number">1</span>] == distance + w[i]) cnt[j][<span class="number">1</span>] += count; <span class="comment">// 更新次短路条数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = cnt[T][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (dist[T][<span class="number">0</span>] + <span class="number">1</span> == dist[T][<span class="number">1</span>]) res += cnt[T][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cases;</span><br><span class="line">    cin &gt;&gt; cases;</span><br><span class="line">    <span class="keyword">while</span> (cases -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; S &gt;&gt; T;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论】二分图</title>
      <link href="/posts/7d098920.html"/>
      <url>/posts/7d098920.html</url>
      
        <content type="html"><![CDATA[<p>二分图，即可以将图中的所有顶点分层两个点集，每个点集内部没有边</p><p><strong>判定图为二分图的充要条件：有向连通图不含奇数环</strong></p><h2 id="1、染色法"><a href="#1、染色法" class="headerlink" title="1、染色法"></a>1、染色法</h2><p>可以解决二分图判断的问题</p><h3 id="步骤与基本思路"><a href="#步骤与基本思路" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>遍历图中每一个点，若该点未被染色，则遍历该点所相邻的点，相邻的点中未被染色的进行染色操作，已被染色的判断颜色是否合法，合法继续遍历，不合法退出</p><h3 id="染色法板子"><a href="#染色法板子" class="headerlink" title="染色法板子"></a>染色法板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!color[i]) <span class="comment">// 未被染色则开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c; <span class="comment">// 对该点进行染色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j]) <span class="comment">// 未被染色的点进行染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已染色的点判断是否合法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="2、匈牙利算法"><a href="#2、匈牙利算法" class="headerlink" title="2、匈牙利算法"></a>2、匈牙利算法</h2><p>可以解决最大匹配数的问题，也就是二分图的两个点集可以连多少条一一对应的边</p><h3 id="步骤与基本思路-1"><a href="#步骤与基本思路-1" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>（1）遍历第一个点集的所有点，每个点遍历之前要记得把第二个点集的状态清空</p><p>（2）依次遍历这些点相邻的点，若该点未被遍历过，则判断该点是否满足未与前面的点匹配过或前面与它匹配的点有其他的匹配方案，若满足任意条件则让现在的两点匹配，不满足则说明当前第一个点集的这个点没有匹配对象</p><h3 id="匈牙利算法板子"><a href="#匈牙利算法板子" class="headerlink" title="匈牙利算法板子"></a>匈牙利算法板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st); <span class="comment">// 清空第二个点集的状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="comment">// 若该点未被遍历过</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 该点是否满足 未被匹配过 or 匹配的第一个点集的点有其他成功匹配方案</span></span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x; <span class="comment">// 匹配现在的这两点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论】最短路算法</title>
      <link href="/posts/6874ac4d.html"/>
      <url>/posts/6874ac4d.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、Dijkstra算法"><a href="#1、Dijkstra算法" class="headerlink" title="1、Dijkstra算法"></a>1、Dijkstra算法</h2><p>不能处理边权为负的情况，<strong>复杂度O(nlogn)</strong></p><h3 id="步骤与基本思路"><a href="#步骤与基本思路" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>（1）初始化距离数组dist[N]，将其所有值赋为0x3f，并将起点1的dist初始化为0，存入优先队列heap中</p><p>（2）从所有<strong>未被遍历</strong>的点中找到与起点1的<strong>距离dist[i]最小</strong>的点，并将该点标记为已遍历</p><p>（3）利用刚刚遍历的这个点 i <strong>更新</strong>所有 i 的出边所连的点与起点1的距离，更新后存入heap中</p><p>（4）重复操作（2）（3）直至heap空</p><h3 id="Dijkstra板子"><a href="#Dijkstra板子" class="headerlink" title="Dijkstra板子"></a>Dijkstra板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> <span class="comment">// 返回起点到终点的距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// first为dist second为具体的点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>(); <span class="comment">// 即取出与起始距离最短点</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> distance = t.first, ver = t.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有与ver相邻的点 更新他们的dist</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 说明起点到不了终点</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="2、Bellman-Ford算法"><a href="#2、Bellman-Ford算法" class="headerlink" title="2、Bellman-Ford算法"></a>2、Bellman-Ford算法</h2><p>可以解决<strong>对边数有要求</strong>的最短路问题，<strong>复杂度O(n^2)</strong></p><h3 id="步骤与基本思路-1"><a href="#步骤与基本思路-1" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>（1）初始化距离数组dist[N]，将其所有值赋为0x3f，并将起点1的dist初始化为0</p><p>（2）遍历 k 次，第 i 次表示这一轮的最短路最多经过 i 条边：每轮先复制上一轮的dist（防止本轮前面的dist更新对后面的更新有影响），然后遍历所有边，更新dist为最小值</p><h3 id="Bellman-Ford板子"><a href="#Bellman-Ford板子" class="headerlink" title="Bellman-Ford板子"></a>Bellman-Ford板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(last, dist, <span class="keyword">sizeof</span> dist); <span class="comment">// 将本轮还没有更新的dist值赋给last</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], last[e.a] + e.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="3、SPFA算法"><a href="#3、SPFA算法" class="headerlink" title="3、SPFA算法"></a>3、SPFA算法</h2><p>可以解决有负权边的情况，还可以判断负环，<strong>复杂度O(n^2)</strong></p><h3 id="步骤与基本思路-2"><a href="#步骤与基本思路-2" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>（1）初始化距离数组dist[N]，将其所有值赋为0x3f，并将起点1的dist初始化为0</p><p>（2）建立队列q，将起点1存入队列中。同时建立st数组记录哪些点入队</p><p>（3）每轮取出队头，遍历与队头相连的所有点，更新这些点的dist，并将不在队中的点入队</p><p>（4）重复（3），直到队空</p><h3 id="SPFA板子"><a href="#SPFA板子" class="headerlink" title="SPFA板子"></a>SPFA板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span> <span class="comment">// 返回起点到终点的最短距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 记录队中现在有哪些点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>(); <span class="comment">// 取出队头</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>; <span class="comment">// 取出的点不在队中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j]) <span class="comment">// 更新的点不在队中就入队</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="4、Floyd算法"><a href="#4、Floyd算法" class="headerlink" title="4、Floyd算法"></a>4、Floyd算法</h2><p>数据范围小时用该方法合适，可以处理负权边，<strong>时间复杂度O(n^3)</strong></p><h3 id="步骤与基本思路-3"><a href="#步骤与基本思路-3" class="headerlink" title="步骤与基本思路"></a>步骤与基本思路</h3><p>设置 k 为中转站，每轮更新 i -&gt; j 距离为 i -&gt; j 和 i -&gt; k k -&gt; j 的最小值</p><h3 id="Floyd板子"><a href="#Floyd板子" class="headerlink" title="Floyd板子"></a>Floyd板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ ) <span class="comment">// k为中转站</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论】最近公共祖先LCA</title>
      <link href="/posts/b33f183d.html"/>
      <url>/posts/b33f183d.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>什么是最近公共祖先？</p><p>在一棵树中（也就是有向无环图中），从根结点遍历到每个结点，路径上所经过的所有结点都叫做该结点的祖先结点</p><p>两个结点的祖先结点中重复的部分叫做公共祖先</p><p>公共祖先中层数最大的一个点叫做<strong>最近公共祖先（LCA）</strong></p><h1 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h1><h2 id="向上标记法"><a href="#向上标记法" class="headerlink" title="向上标记法"></a>向上标记法</h2><p>要求的两个结点依次向上遍历，找到的第一个公共祖先就是最近公共祖先</p><p>但是这个做法比较暴力，时间复杂度<strong>O(n)</strong></p><h2 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h2><p>首先需要预处理<code>f[i][j]</code>：从结点 i 向上走 2^j^ 步走到的结点，j 的范围是<code>0 &lt;= j &lt;= logn</code><br>比如说，当 j &#x3D; 0 时，<code>f[i][j]</code>表示的就是 i 向上走一步到达的结点，其实也就是 i 的父结点</p><p>（如果从 i 开始跳 2^j^ 跳出了根结点，那么规定<code>f[i][j] = 0</code>且<code>dist[0] = 0</code>）</p><p>怎么实现这个算法呢？</p><p>我们发现，从结点 i 向上走 2^j^ 步，相当于结点 i 先向上走 2 ^j-1^ 步，再向上走 2 ^j-1^ 步<br>据此，我们可以利用<strong>递归</strong>来解决这个问题</p><p>用式子可以表示为：<code>f[i][j] = f[f[i][j - 1]][j - 1]</code></p><p>然后，我们需要预处理另一个数组<code>depth[i]</code>：表示 i 结点的深度</p><p>上面的两个数组都可以利用 DFS &#x2F; BFS 求出</p><p>当我们知道了<code>f[i][j]</code> 和<code>depth[i]</code>，应该怎么求LCA呢？</p><p><strong>步骤：</strong></p><ul><li>&#x3D;&#x3D;<strong>先将两个结点跳到同一层</strong>&#x3D;&#x3D;<br>具体怎么做呢？<br>首先我们需要了解<strong>二进制拼凑</strong>：所有整数都可以由2的整次幂的和来表示（因为所有数都可以表示为二进制）<br>当我们需要拼出一个 n ，从大到小开始枚举，当找到第一个数 k 满足<code>2^k &lt;= n</code>时，表示我们需要选择 2 ^k^，之后用 n - 2 ^k^ 再根据一样的步骤求出下一个满足条件的 k，以此类推<br>了解了这个知识之后，回到<strong>怎么将两个不同深度的结点跳到同一层</strong>这个问题<br>我们已经知道了<code>depth[i]</code>和<code>depth[j]</code>（假设要求的两个结点是 i 和 j，i 的深度比 j 大）<br>当<code>depth[f[i][k]] &gt;= depth[j]</code>时，说明结点 i 向上跳了 2 ^k^ 步后的祖先结点还是比结点 j 深度大，那就说明可以跳，根据这个方法，我们可以将深度较大的结点跳到和深度较小的结点的同一层</li><li>&#x3D;&#x3D;<strong>让两个结点同时往上跳，直到跳到最近公共祖先的下一层</strong>&#x3D;&#x3D;<br>为什么要让这两个结点跳到LCA的下一层而不是直接跳到LCA呢？<br>因为如果这两个结点跳到的祖先是同一个结点，我们只能说这个相同的结点是公共祖先祖先，而无法保证是最近公共祖先。当我们跳到LCA的下一层，只要他们的父结点是同一个结点，那这个结点就一定是它们的最近公共祖先了<br>那该怎么实现这一步呢？<br>还是从大到小枚举 k，当<code>f[i][k] != f[j][k]</code>时，说明 i 和 j 还没有跳到公共祖先，当<code>f[i][k] == f[j][k]</code>时，跳到了公共祖先，此时 k - 1 就是不能跳到公共祖先的最大的 k，于是我们将 i 和 j 同时往上跳 2 ^k-1^步，以此类推</li></ul><p>预处理的时间复杂度是<strong>O(nlogn)</strong><br>查询的时间复杂度是<strong>O(logn)</strong></p><h3 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h3><p><strong>题目 <a href="https://www.acwing.com/problem/content/1174/">祖孙询问</a></strong></p><p>给定一棵包含 n 个节点的有根无向树，节点编号互不相同，但不一定是 1∼n。</p><p>有 m 个询问，每个询问给出了一对节点的编号 x 和 y，询问 x 与 y 的祖孙关系。</p><p><strong>输入格式</strong></p><p>输入第一行包括一个整数 表示节点个数；</p><p>接下来 n 行每行一对整数 a 和 b，表示 a 和 b 之间有一条无向边。如果 b 是 −1，那么 a 就是树的根；</p><p>第 n+2 行是一个整数 m 表示询问个数；</p><p>接下来 m 行，每行两个不同的正整数 x 和 y，表示一个询问。</p><p><strong>输出格式</strong></p><p>对于每一个询问，若 x 是 y 的祖先则输出 1，若 y 是 x 的祖先则输出 2，否则输出 0。</p><p><strong>数据范围</strong></p><p><code>1 ≤ n, m ≤ 4 × 10^4</code>,<br><code>1 ≤ 每个节点的编号 ≤ 4 × 10^4</code></p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">234</span> <span class="number">-1</span></span><br><span class="line"><span class="number">12</span> <span class="number">234</span></span><br><span class="line"><span class="number">13</span> <span class="number">234</span></span><br><span class="line"><span class="number">14</span> <span class="number">234</span></span><br><span class="line"><span class="number">15</span> <span class="number">234</span></span><br><span class="line"><span class="number">16</span> <span class="number">234</span></span><br><span class="line"><span class="number">17</span> <span class="number">234</span></span><br><span class="line"><span class="number">18</span> <span class="number">234</span></span><br><span class="line"><span class="number">19</span> <span class="number">234</span></span><br><span class="line"><span class="number">233</span> <span class="number">19</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">234</span> <span class="number">233</span></span><br><span class="line"><span class="number">233</span> <span class="number">12</span></span><br><span class="line"><span class="number">233</span> <span class="number">13</span></span><br><span class="line"><span class="number">233</span> <span class="number">15</span></span><br><span class="line"><span class="number">233</span> <span class="number">19</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong>（加了注释^^）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">16</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span> <span class="comment">// 预处理depth和fa</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f3f3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[root] = <span class="number">1</span>; <span class="comment">// 设置哨兵</span></span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>; <span class="comment">// 更新depth</span></span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">                fa[j][<span class="number">0</span>] = t; <span class="comment">// 记录父结点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>]; <span class="comment">// 更新fa</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// 返回最近公共祖先</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b); <span class="comment">// 把深度大的调到a</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- ) <span class="comment">// 把两个结点调到同一层</span></span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- ) <span class="comment">// 两个点同时往上跳</span></span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 构图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">-1</span>) root = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>(root); <span class="comment">// 预处理</span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span> (p == a) cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == b) cout &lt;&lt; <span class="string">&quot;2\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tarjan法"><a href="#Tarjan法" class="headerlink" title="Tarjan法"></a>Tarjan法</h2><p>本质是对向上标记法的优化，这是一种离线做法（意思是读入所有询问后统一计算统一输出），时间复杂度<strong>O(n + m)</strong></p><p>在DFS中，把所有的点分成三大类：<strong>已经遍历过且回溯过的点</strong>（意思是它的所有子树都被遍历了，换句话说就是经过了该点两次）、<strong>正在遍历的分支</strong>（遍历过一次还没有回溯的点，换句话说就是经过了该点一次）、<strong>还没搜索到的点</strong>（经过了该点0次）</p><p>以下面这张图为例，设红色的路线使我们正在遍历的点，红色左边的所有点都是已经遍历完的，右边的所有点都是还没有被遍历的<br>可以发现，黄色区域内的所有点与 j 的最近公共祖先就是黄色区域的父结点，蓝色区域和绿色区域也一样，因此我们可以通过并查集的方式求得两个结点的lca</p><img src="/posts/b33f183d/1.png" class><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><strong>题目 <a href="https://www.acwing.com/problem/content/1173/">距离</a></strong></p><p>给出 n 个点的一棵树，多次询问两点之间的最短距离。</p><p>注意：</p><ul><li>边是无向的。</li><li>所有节点的编号是 1,2,…,n。</li></ul><p><strong>输入格式</strong></p><p>第一行为两个整数 n 和 m。n 表示点数，m 表示询问次数；</p><p>下来 n−1 行，每行三个整数 x,y,k，表示点 x 和点 y 之间存在一条边长度为 k；</p><p>再接下来 m 行，每行两个整数 x,y，表示询问点 x 到点 y 的最短距离。</p><p>树中结点编号从 1 到 n。</p><p><strong>输出格式</strong><br>共 m 行，对于每次询问，输出一行询问结果。</p><p><strong>数据范围</strong><br>2 ≤ n ≤ 10^4^, 1 ≤ m ≤ 2 × 10^4^, 0 &lt; k ≤ 100, 1 ≤ x, y ≤ n</p><p><strong>输入样例1：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">100</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出样例1：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p><strong>输入样例2：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">10</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出样例2：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>只需要知道，求两个点的路径长度，就是用<strong>第一个点到根结点的距离</strong>加上<strong>第二个点到根结点的距离</strong>减去<strong>两倍的最近公共祖先到根节点的距离</strong>，所以问题还是转化成求lca的问题</p><img src="/posts/b33f183d/2.png" class><p><strong>代码</strong>（加了注释）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20010</span>, M = <span class="number">2</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;  </span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储每个点到根结点的距离</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 每个点的祖宗结点</span></span><br><span class="line"><span class="type">int</span> res[N]; <span class="comment">// 存储输出结果</span></span><br><span class="line"><span class="type">int</span> st[N]; <span class="comment">// 表示每个点的遍历状态 1:正在搜索 2:已经搜完 0:还没搜</span></span><br><span class="line">vector&lt;PII&gt; query[N]; <span class="comment">// 存储查询的点，first存另一个点，second存查询编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>; <span class="comment">// 需要记录父结点防止遍历到上面去（因为这是一个图我们把它看成树而已）</span></span><br><span class="line">        dist[j] = dist[u] + w[i]; <span class="comment">// dist[j]是点 w[i]是边 更新距离dist</span></span><br><span class="line">        <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="number">1</span>; <span class="comment">// 修改当前点状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="comment">// 如果当前点未被遍历过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            p[j] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query[u]) <span class="comment">// 处理和当前点相关的所有询问</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = item.first, id = item.second; <span class="comment">// y是另一个点 id是询问编号</span></span><br><span class="line">        <span class="keyword">if</span> (st[y] == <span class="number">2</span>) <span class="comment">// 另一个点已经搜完才处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> anc = <span class="built_in">find</span>(y); <span class="comment">// anc为最近公共祖先</span></span><br><span class="line">            res[id] = dist[u] + dist[y] - <span class="number">2</span> * dist[anc];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st[u] = <span class="number">2</span>; <span class="comment">// 修改当前点状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) <span class="comment">// 构图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        query[a].<span class="built_in">push_back</span>(&#123;b, i&#125;);</span><br><span class="line">        query[b].<span class="built_in">push_back</span>(&#123;a, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i; <span class="comment">// 并查集初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>); <span class="comment">// -1表示1是根结点</span></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) cout &lt;&lt; res[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h1><h2 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a><a href="https://www.acwing.com/problem/content/description/358/">次小生成树</a></h2><p>给定一张 N 个点 M 条边的无向图，求无向图的严格次小生成树。</p><p>设最小生成树的边权之和为 sum，严格次小生成树就是指边权之和大于 sum 的生成树中最小的一个。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 N 和 M。</p><p>接下来 M 行，每行包含三个整数 x，y，z，表示点 x 和点 y 之前存在一条边，边的权值为 z。</p><p><strong>输出格式</strong></p><p>包含一行，仅一个数，表示严格次小生成树的边权和。(数据保证必定存在严格次小生成树)</p><p><strong>数据范围</strong></p><p>N ≤ 10^5^, M ≤ 3 × 10^5^,<br>1 ≤ x, y ≤ N,<br>0 ≤ z ≤ 106</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>总体思路是：先利用Kruskal算法求出最小生成树，然后看其余不在最小生成树中的每条边能不能替换最小生成树中的一条边使得其变成次小生成树<br>不在最小生成树的边加到最小生成树里，（比如说加了a-b这条边），那ab在最小生成树中的路径一定会和加的这条边构成环（这点很重要，理解了就很清楚），那我们就需要在这个环里去掉一条边让a-b这条边来代替它，设新加的边权重w，去掉的边权重wi，最小生成树边权和sum，那么新生成的树边权和<code>sum - wi + w</code>，要让新生成的树权重尽可能小，我们就要让减掉的边权重尽可能大，因此减掉的边只可能是最小生成树中的最大边或者次大边（因为要求生成严格的次小生成树，那么次小生成树的边权和就不能和最小生成树一样大，如果新加入的边和最小生成树中的最大边权重一样，就不能用这条边替换最大边（否则最终权重还是一样），就应该用这条边替换次大边）</p><p>代码中的 lca 函数利用最近公共祖先求出环中除了新加的边之外的最大边和次大边，bfs 函数更新 d1 和 d2 的值<br>具体看代码注释（ 受不了了好难qaq</p><p><strong>代码</strong>（写了注释）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">// 存边信息</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> used;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 并查集</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N]; <span class="comment">// 每个点的层数</span></span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">17</span>]; <span class="comment">// 每个点向上走2^j到达的点</span></span><br><span class="line"><span class="type">int</span> d1[N][<span class="number">17</span>]; <span class="comment">// d1[i][j] 表示从i点向上走2^j步这段路径中最大边</span></span><br><span class="line"><span class="type">int</span> d2[N][<span class="number">17</span>]; <span class="comment">// d2[i][j] 表示从i点向上走2^j步这段路径中（严格）次大边</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">kruskal</span><span class="params">()</span> <span class="comment">// 构建最小生成树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(edge, edge + m); <span class="comment">// 按边权从小到大排序</span></span><br><span class="line">    i64 res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(edge[i].a), b = <span class="built_in">find</span>(edge[i].b), w = edge[i].w;</span><br><span class="line">        <span class="keyword">if</span> (a != b) <span class="comment">// ab不属于同一集合</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b; <span class="comment">// 将a加到b所在集合</span></span><br><span class="line">            res += w; <span class="comment">// 更新最小生成树边权</span></span><br><span class="line">            edge[i].used = <span class="literal">true</span>; <span class="comment">// 标记i这条边已被使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> <span class="comment">// 构图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (edge[i].used) <span class="comment">// 这条边在最小生成树里才加到图里</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            <span class="built_in">add</span>(a, b, w), <span class="built_in">add</span>(b, a, w);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="comment">// 更新depth和fa和d1和d2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f3f3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 设置哨兵和初始化</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>) <span class="comment">// 说明j没被遍历过，更新j相关信息</span></span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">                fa[j][<span class="number">0</span>] = t; <span class="comment">// 更新j父结点</span></span><br><span class="line">                d1[j][<span class="number">0</span>] = w[i], d2[j][<span class="number">0</span>] = -inf; <span class="comment">// 初始化</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; <span class="number">16</span>; k ++ )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> anc = fa[j][k - <span class="number">1</span>]; <span class="comment">// j向上走2^(k-1)所到达点</span></span><br><span class="line">                    fa[j][k] = fa[anc][k - <span class="number">1</span>]; <span class="comment">// 递归思想</span></span><br><span class="line">                    <span class="comment">// 最大边和次大边一定是下方四个值中的一个</span></span><br><span class="line">                    <span class="type">int</span> distance[<span class="number">4</span>] = &#123;d1[j][k - <span class="number">1</span>], d2[j][k - <span class="number">1</span>], d1[anc][k - <span class="number">1</span>], d2[anc][k - <span class="number">1</span>]&#125;;</span><br><span class="line">                    d1[j][k] = d2[j][k] = -inf; <span class="comment">// 初始化最大边和次大边的值</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u ++ ) <span class="comment">// 更新最大边和次大边</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> d = distance[u];</span><br><span class="line">                        <span class="keyword">if</span> (d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (d != d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> distance[N * <span class="number">2</span>]; <span class="comment">// 存储所有跳的路径中的最大边和次大边</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// distance大小</span></span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b); <span class="comment">// 把深度大的调给a</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b]) <span class="comment">// 把ab调到同一层，a往上跳2^k还是比b深度大，说明可以跳</span></span><br><span class="line">        &#123;</span><br><span class="line">            distance[cnt ++ ] = d1[a][k];</span><br><span class="line">            distance[cnt ++ ] = d2[a][k];</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != b) <span class="comment">// 把ab同时跳到最近公共祖先的下一层</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">            <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">            &#123;</span><br><span class="line">                distance[cnt ++ ] = d1[a][k];</span><br><span class="line">                distance[cnt ++ ] = d2[a][k];</span><br><span class="line">                distance[cnt ++ ] = d1[b][k];</span><br><span class="line">                distance[cnt ++ ] = d2[b][k];</span><br><span class="line">                a = fa[a][k], b = fa[b][k];</span><br><span class="line">            &#125;</span><br><span class="line">        distance[cnt ++ ] = d1[a][<span class="number">0</span>];</span><br><span class="line">        distance[cnt ++ ] = d1[b][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在distance中找到最大边和次大边赋给dist1 dist2</span></span><br><span class="line">    <span class="type">int</span> dist1 = -inf, dist2 = -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = distance[i];</span><br><span class="line">        <span class="keyword">if</span> (d &gt; dist1) dist2 = dist1, dist1 = d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d != dist1 &amp;&amp; d &gt; dist2) dist2 = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w &gt; dist1) <span class="keyword">return</span> w - dist1; <span class="comment">// w替换最大边</span></span><br><span class="line">    <span class="keyword">if</span> (w &gt; dist2) <span class="keyword">return</span> w - dist2; <span class="comment">// w替换次大边</span></span><br><span class="line">    <span class="keyword">return</span> inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        edge[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i64 sum = <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    i64 res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!edge[i].used) <span class="comment">// 在没选的所有边中找到要替换的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">            res = <span class="built_in">min</span>(res, sum + <span class="built_in">lca</span>(a, b, w));</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闇の連鎖"><a href="#闇の連鎖" class="headerlink" title="闇の連鎖"></a><a href="https://www.acwing.com/problem/content/description/354/">闇の連鎖</a></h2><p>传说中的暗之连锁被人们称为 Dark。</p><p>Dark 是人类内心的黑暗的产物，古今中外的勇者们都试图打倒它。</p><p>经过研究，你发现 Dark 呈现无向图的结构，图中有 N 个节点和两类边，一类边被称为主要边，而另一类被称为附加边。</p><p>Dark 有 N–1 条主要边，并且 Dark 的任意两个节点之间都存在一条只由主要边构成的路径。</p><p>另外，Dark 还有 M 条附加边。</p><p>你的任务是把 Dark 斩为不连通的两部分。</p><p>一开始 Dark 的附加边都处于无敌状态，你只能选择一条主要边切断。</p><p>一旦你切断了一条主要边，Dark 就会进入防御模式，主要边会变为无敌的而附加边可以被切断。</p><p>但是你的能力只能再切断 Dark 的一条附加边。</p><p>现在你想要知道，一共有多少种方案可以击败 Dark。</p><p>注意，就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 N 和 M。</p><p>之后 N–1 行，每行包括两个整数 A 和 B，表示 A 和 B 之间有一条主要边。</p><p>之后 M 行以同样的格式给出附加边。</p><p><strong>输出格式</strong></p><p>输出一个整数表示答案。</p><p><strong>数据范围</strong></p><p>N ≤ 100000, M ≤ 200000，数据保证答案不超过 2^31^−1</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>这一题转换一下语言，意思就是有一棵树上还有一些边，属于树的边叫做树边，另外的边叫做非树边，现在要求切断一条树边一条非树边，把这个图分成两个部分</p><p>首先明确一点，每个非树边连接的两个点都可由唯一的一条由树边组成的路径连接，这条路径和该非树边组成一个环</p><p>我们想要断开这个环，把这个环分成两部分，首先需要切断那一条非树边，然后需要切断任意一条环上的树边，所以我们遍历每一条非树边，然后把这个环上的所有树边标记一次</p><ul><li>对于没有被标记过的树边，说明只要切断这条树边就可以将图分成两部分，此时再任意切一条非树边就可以了，答案加上非树边的条数</li><li>对于只标记过一次的树边，说明需要切断这条树边和另一条对应的非树边，答案加上1</li><li>对于标记过两次及以上的树边，此时切断这条树边，会导致原来的两个环合并成一个环，但此时只能再切一条边了，不可能断开形成的新环，所以答案不变</li></ul><p>于是这一题的问题就转换成了在每一条树边上标记的问题</p><p>怎样快速的对图中的边进行标记呢？</p><p>这里我们利用<strong>树上差分</strong> 的思路</p><p>我们学习过一维数组的差分，将<code>[l, r]</code>上的每个元素都加上相同的元素 c，可以直接将差分数组的 l 加上 c，r + 1 项减去 c</p><p>那么在树中，我们要将路径<code>(a, b)</code>上的每条边都加上 c，需要将差分数组的 a，b 项分别加 c，将 ab 的 lca 项减去 2c （差分数组的每一项表示该项编号对应的点与父结点连接的边）</p><p><strong>代码</strong>（加了注释）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">2</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N]; <span class="comment">// 存每个结点深度</span></span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">17</span>]; <span class="comment">// f[i][j]：i往上走2^j步所到达的结点</span></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 差分数组</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> <span class="comment">// 定义depth和fa</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f3f3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 哨兵和初始化</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">16</span>; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b); <span class="comment">// 先调顺序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k -- ) <span class="comment">// 再调同一层</span></span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b]) a = fa[a][k];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k -- ) <span class="comment">// 再同时往上跳</span></span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span> <span class="comment">// 返回以u为根的子树的d之和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = d[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j, u);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">0</span>) ans += m;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">1</span>) ans ++ ;</span><br><span class="line">            res += s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">        d[a] ++, d[b] ++, d[p] -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最近公共祖先 </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论】图的存储与搜索</title>
      <link href="/posts/3f91b69e.html"/>
      <url>/posts/3f91b69e.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、图的存储方式"><a href="#一、图的存储方式" class="headerlink" title="一、图的存储方式"></a>一、图的存储方式</h1><p>首先，树是一种特殊的图，因此树的存储类似，这里只记录图的存储。</p><p>其次，无向图又是一种特殊的有向图。</p><p>无向图中的 a—b 相当于有向图中的 a-&gt;b b-&gt;a，因此这里只记录有向图的存储。</p><h2 id="1、邻接矩阵"><a href="#1、邻接矩阵" class="headerlink" title="1、邻接矩阵"></a>1、邻接矩阵</h2><p>简单来说就是开个二维数组g[N][N]。</p><ul><li>无权图中，g就是个bool值，ab之间有边，则g[a][b] &#x3D; true， 否则为false。</li><li>有权图中，g为两条边之间的权重。</li></ul><p>出现重边时，邻接矩阵只保留一条边（一般是保留最短的那条）。</p><p>空间复杂度O(n^2)，经验来看1e5会爆，只适合存储稠密图，稀疏图用邻接表。</p><h2 id="2、邻接表"><a href="#2、邻接表" class="headerlink" title="2、邻接表"></a>2、邻接表</h2><h3 id="（1）链式前向星"><a href="#（1）链式前向星" class="headerlink" title="（1）链式前向星"></a>（1）链式前向星</h3><ul><li>h[N]：头结点</li><li>e[N]：头结点可以到达哪些点</li><li>ne[N]：起到指针的作用 表示e[i]的下一个结点是什么位置</li><li>idx：当前存储到了什么位置</li></ul><h3 id="链式前向星板子"><a href="#链式前向星板子" class="headerlink" title="链式前向星板子"></a><strong>链式前向星板子</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], w[N], idx;</span><br><span class="line"><span class="comment">// 首先一定要初始化h</span></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 加入 a -&gt; b 这条边，权重是w</span></span><br><span class="line">    e[idx] = b, w[idx] = w, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="（2）vector存二维数组"><a href="#（2）vector存二维数组" class="headerlink" title="（2）vector存二维数组"></a>（2）vector存二维数组</h3><p>vector<int> g[N] 的方式来存储。</int></p><h3 id="vector存二维数组板子"><a href="#vector存二维数组板子" class="headerlink" title="vector存二维数组板子"></a><strong>vector存二维数组板子</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 加入 a -&gt; b 这条边</span></span><br><span class="line">    g[a].<span class="built_in">pushforward</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 如果需要增加权重，可以考虑把vector<int>换成vector&lt;pair&lt;int, int&gt;&gt;</int></p><hr><h1 id="二、图的搜索与遍历"><a href="#二、图的搜索与遍历" class="headerlink" title="二、图的搜索与遍历"></a>二、图的搜索与遍历</h1><h2 id="1、深度优先搜索（DFS）"><a href="#1、深度优先搜索（DFS）" class="headerlink" title="1、深度优先搜索（DFS）"></a>1、深度优先搜索（DFS）</h2><p>尽可能往深搜，直到前面没有能继续搜索的点了才会回溯，回溯时也是一边回溯一边看目前回溯到的点有没有能接着往深搜的，直到遍历完整个图。</p><p>空间复杂度O(n)，相较于BFS有绝对优势。</p><h3 id="深度优先搜索BFS板子"><a href="#深度优先搜索BFS板子" class="headerlink" title="深度优先搜索BFS板子"></a><strong>深度优先搜索BFS板子</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ( 遍历完毕 )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; 打印所需结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( 遍历整个图 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) <span class="comment">// 当前结点未被遍历过</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i); <span class="comment">// 遍历下一层</span></span><br><span class="line">            <span class="comment">// 是否恢复现场依情况而定 如果遍历整个图就不需要恢复现场</span></span><br><span class="line">            st[i] = <span class="literal">false</span>; <span class="comment">// 恢复当前结点的遍历情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="2、宽度优先搜索（BFS）"><a href="#2、宽度优先搜索（BFS）" class="headerlink" title="2、宽度优先搜索（BFS）"></a>2、宽度优先搜索（BFS）</h2><p>按层搜索，每一轮搜索到的点和起始点的距离都是一样的。（比如说第一次搜索到的点距离起始点的长度都是1，第二次搜索到的点距离起始点的长度都是2，以此类推）</p><p>正是因为这个特性，BFS可以解决一部分权重为1的最短路问题。</p><p>空间复杂度O(2^n)。</p><h3 id="宽度优先搜索BFS板子"><a href="#宽度优先搜索BFS板子" class="headerlink" title="宽度优先搜索BFS板子"></a><strong>宽度优先搜索BFS板子</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>( 第一个数 );</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) <span class="comment">// q不空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取出队头并删去</span></span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> ( 遍历与t相邻的点 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[i])</span><br><span class="line">            &#123;</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(i); <span class="comment">// 该点没遍历过就把它加到队列中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="BFS应用实例-—-拓补序列"><a href="#BFS应用实例-—-拓补序列" class="headerlink" title="BFS应用实例 — 拓补序列"></a>BFS应用实例 — 拓补序列</h3><p>拓补序列：对于所有有向边 x-&gt;y，序列中总存在x在y前面，该序列为拓补序列</p><p>换句话说序列中所有边都是从前指向后。</p><p>如果一个图存在环，就一定不存在拓补序列。</p><p><strong>一个有向无环图一定存在拓补序列，有向无换图又被称作拓补图。</strong></p><p>任何一个入度为0的点都可以作为拓补序列的起点</p><p>任何一个出度为0的点都可以作为拓补序列的终点</p><h3 id="拓补序列板子"><a href="#拓补序列板子" class="headerlink" title="拓补序列板子"></a>拓补序列板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> ( 找到所有入度为<span class="number">0</span>的点i ) q.<span class="built_in">push</span>(i); <span class="comment">// 把入度为0的点存进q</span></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>(); <span class="comment">// 指向队头</span></span><br><span class="line">        <span class="keyword">for</span> ( 枚举t的所有出边 t-&gt;j )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 删掉t-&gt;j这条边 也就是让j的入度-1</span></span><br><span class="line">            d[j] -- ;</span><br><span class="line">            <span class="keyword">if</span> (d[j] == <span class="number">0</span>) q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】双向DFS</title>
      <link href="/posts/c90ca664.html"/>
      <url>/posts/c90ca664.html</url>
      
        <content type="html"><![CDATA[<p>双向BFS和前面的双向DFS思路基本一样，都是为了从两端搜索从而避免搜索中间一大块复杂的情况</p><h1 id="送礼物"><a href="#送礼物" class="headerlink" title="送礼物"></a>送礼物</h1><p><a href="https://www.acwing.com/problem/content/173/">原题链接</a></p><p>达达帮翰翰给女生送礼物，翰翰一共准备了 $N$ 个礼物，其中第 i 个礼物的重量是 $G[i]$。</p><p>达达的力气很大，他一次可以搬动重量之和不超过 $W$ 的任意多个物品。</p><p>达达希望一次搬掉尽量重的一些物品，请你告诉达达在他的力气范围内一次性能搬动的最大重量是多少。</p><p><strong>输入格式</strong></p><p>第一行两个整数，分别代表 $W$ 和 $N$。</p><p>以后 $N$ 行，每行一个正整数表示 $G[i]$。</p><p><strong>输出格式</strong></p><p>仅一个整数，表示达达在他的力气范围内一次性能搬动的最大重量。</p><p><strong>数据范围</strong></p><p>$1 ≤ N ≤ 46,$<br>$1 ≤ W , G[i] ≤ 2^{31}−1$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出背包体积和每个物品体积，问一次最多装多少物品</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看数据范围判断背包问题一定会TLE，但N范围比较小，因此使用爆搜，把所有可能方案枚举一遍，取一个最大值<br>但是直接爆搜，时间复杂度 2^46^，也是会超时的</p><p><strong>优化——双向DFS</strong> 用空间换时间<br>先枚举前一半数能凑出来的集合，再枚举后一半数，然后在两个集合中分别找 $a、b$，看能不能找到使$a+b&lt;&#x3D;w$（$w$是要求的最大总重量）<br>爆搜b，二分查找a，借此优化时间复杂度</p><p>本题思路总结如下：</p><ol><li>将所有物品重量从大到小排序</li><li>先将前k件物品能凑出的所有重量打表，然后排序判重</li><li>搜索剩下的n-k件物品的选择方式，然后在表中二分出不超过w的最大值</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">46</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="type">int</span> w[N]; <span class="comment">// 每个物品重量</span></span><br><span class="line"><span class="type">int</span> weights[<span class="number">1</span> &lt;&lt; <span class="number">25</span>], cnt; <span class="comment">// 能凑出来的重量</span></span><br><span class="line"><span class="type">int</span> ans; <span class="comment">// 全局最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s)</span> <span class="comment">// u:枚举到哪个数 s:当前的和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == k)</span><br><span class="line">    &#123;</span><br><span class="line">        weights[cnt ++ ] = s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(u + <span class="number">1</span>, s); <span class="comment">// 不选第u个</span></span><br><span class="line">    <span class="keyword">if</span> ((i64)s + w[u] &lt;= m) <span class="built_in">dfs1</span>(u + <span class="number">1</span>, s + w[u]); <span class="comment">// 选第u个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 二分查找前一部分</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (weights[mid] &lt;= m - s)  l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, weights[l] + s); <span class="comment">// 更新答案</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs2</span>(u + <span class="number">1</span>, s); <span class="comment">// 不选第u个</span></span><br><span class="line">    <span class="keyword">if</span> ((i64)s + w[u] &lt;= m) <span class="built_in">dfs2</span>(u + <span class="number">1</span>, s + w[u]); <span class="comment">// 选第u个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(w, w + n);</span><br><span class="line">    <span class="built_in">reverse</span>(w, w + n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对前k个数打表预处理</span></span><br><span class="line">    k = n / <span class="number">2</span>; <span class="comment">// 防止n==1死循环</span></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序去重</span></span><br><span class="line">    <span class="built_in">sort</span>(weights, weights + cnt);</span><br><span class="line">    cnt = <span class="built_in">unique</span>(weights, weights + cnt) - weights; <span class="comment">// 返回当前数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs2</span>(k, <span class="number">0</span>); <span class="comment">// 爆搜后一部分</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】DFS迭代加深与IDA*</title>
      <link href="/posts/78aeb4cc.html"/>
      <url>/posts/78aeb4cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h1><p>搜索时可能会遇到这样一种情况：</p><img src="/posts/78aeb4cc/1.png" class><p>明明答案就在第一层！但是因为DFS的缘故浪费很多时间<br>迭代加深就是用来解决这个问题的算法</p><p>定义一个 max_depth ，每次搜索时，超过这一层就全部剪掉、<br>（相当于我们划定一个区域，在这个区域内找解，如果找不到，再扩大区域）</p><p>？迭代加深和BFS有什么区别呢<br>BFS用队列存储，浪费空间，迭代加深本质是还是DFS，只存储本条路径，还是O(n)的算法</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="加成序列"><a href="#加成序列" class="headerlink" title="加成序列"></a>加成序列</h3><p><a href="https://www.acwing.com/problem/content/172/">原题链接</a></p><p>满足如下条件的序列 X（序列中元素被标号为 1、2、3…m）被称为“加成序列”：</p><ol><li>$X[1]&#x3D;1$</li><li>$X[m]&#x3D;n$</li><li>$X[1]&lt;X[2]&lt;…&lt;X[m−1]&lt;X[m]$</li><li>对于每个 k（2 ≤ k ≤ m）都存在两个整数 i 和 j （1 ≤ i , j ≤ k − 1，i 和 j 可相等），使得 $X[k]&#x3D;X[i]+X[j]$。</li></ol><p>你的任务是：给定一个整数 n，找出符合上述条件的长度 m 最小的“加成序列”。</p><p>如果有多个满足要求的答案，只需要找出任意一个可行解。</p><p><strong>输入格式</strong></p><p>输入包含多组测试用例。</p><p>每组测试用例占据一行，包含一个整数 n。</p><p>当输入为单行的 0 时，表示输入结束。</p><p><strong>输出格式</strong></p><p>对于每个测试用例，输出一个满足需求的整数序列，数字之间用空格隔开。</p><p>每个输出占一行。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 100</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">77</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">12</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">10</span> <span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">17</span> <span class="number">34</span> <span class="number">68</span> <span class="number">77</span></span><br></pre></td></tr></table></figure><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给出 n 构造一个序列，要求第一个数是1，最后一个数是n，严格递增，且后面的数一定要是前面两个数之和（两个数可以是同一个数），输出一个长度最小的序列</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>序列的最小规模：1 2 4 8 16 32 64 128 此时就已经超过100了，说明正确答案的深度不会很深，适合用迭代加深来做<br>层数从1开始，依次考虑每一位选什么数字</p><p><strong>优化：</strong></p><ol><li>优化搜索顺序：优先枚举较大的数，层数较少，更快的找到 n</li><li>排除等效冗余：举个栗子：1 2 3 4 现在枚举下一个数，不管选择1+4还是2+3结果都是5，就可以不用计算两次了（方法是开一个bool数组存储每个数是否被用过）</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 标记某数是否被用过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span> <span class="comment">// 分别是当前层数和最大层数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; depth) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当前层数&gt;最大层数</span></span><br><span class="line">    <span class="keyword">if</span> (path[u - <span class="number">1</span>] == n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 最后一个数为n满足条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = u - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = path[i] + path[j];</span><br><span class="line">            <span class="keyword">if</span> (s &gt; n || s &lt;= path[u - <span class="number">1</span>] || st[s]) <span class="keyword">continue</span>; <span class="comment">// 大于最大值or小于前一个值or已被用过 都不满足条件</span></span><br><span class="line"></span><br><span class="line">            st[s] = <span class="literal">true</span>; <span class="comment">// 标记s已被用过</span></span><br><span class="line">            path[u] = s; <span class="comment">// 记录s</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(u + <span class="number">1</span>, depth)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 下一位</span></span><br><span class="line">            st[s] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">1</span>, depth)) depth ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i ++ ) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA*"></a>IDA*</h1><p>IDA*是什么意思？</p><p>IDA*就是特殊的剪枝，一般情况下和<strong>迭代加深</strong>结合起来使用，需要定义一个max_depth，我们搜索到一个结点的时候就开始预估这个结点和正确答案的步数，如果说在这个步数内无论如何都找不到正确答案，那就不继续往下搜了提前退出</p><p>要求：估价函数&lt;&#x3D;真实值</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="排书"><a href="#排书" class="headerlink" title="排书"></a>排书</h3><p><a href="https://www.acwing.com/problem/content/182/">原题链接</a></p><p>给定 $n$ 本书，编号为 $1∼n$。</p><p>在初始状态下，书是任意排列的。</p><p>在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。</p><p>我们的目标状态是把书按照 $1∼n$ 的顺序依次排列。</p><p>求最少需要多少次操作。</p><p><strong>输入格式</strong></p><p>第一行包含整数 $T$，表示共有 T 组测试数据。</p><p>每组数据包含两行，第一行为整数 $n$，表示书的数量。</p><p>第二行为 $n$ 个整数，表示 $1∼n$ 的一种任意排列。</p><p>同行数之间用空格隔开。</p><p><strong>输出格式</strong></p><p>每组数据输出一个最少操作次数。</p><p>如果最少操作次数大于或等于 5 次，则输出 <code>5 or more</code>。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><p>$1 ≤ n ≤ 15$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">6</span> <span class="number">8</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">7</span> <span class="number">2</span> <span class="number">9</span> <span class="number">1</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">or</span> more</span><br></pre></td></tr></table></figure><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>一列数，每次可以取出其中一个子串插到其他地方，问至少多少次能让数列递增</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>采用迭代加深框架，每次估计当前序列最少要进行多少次操作才能把它变成排好序的序列</p><p>怎么确定估价函数呢？</p><p>我们观察每一位数的后继（也就是后面那个数），如果序列排好序，那么每个元素的后继都应该比元素本身大1<br>每操作一次会修改三个元素的后继，如下图所示：</p><img src="/posts/78aeb4cc/2.png" class><p>因此我们先统计出有 tot 个元素的后继不正确，因为每次操作可以修改三个后继，我们假设三个后继都变成正确的了，所以最少进行的操作步数就是$\lceil\frac{tot}{3}\rceil$，也就是$\lfloor\frac{tot+2}{3}\rfloor$，用它作为估价函数可以保证一定满足条件</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> w[<span class="number">5</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> <span class="comment">// 估价函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>; <span class="comment">// 错误的后继数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (q[i + <span class="number">1</span>] != q[i] + <span class="number">1</span>) tot ++ ;</span><br><span class="line">    <span class="keyword">return</span> (tot + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> max_depth)</span> <span class="comment">// 分别表示当前层数和最大层数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth + <span class="built_in">f</span>() &gt; max_depth) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当前深度大于最大深度</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 估价函数=0说明当前就是正确答案</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len ++ ) <span class="comment">// 枚举长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l + len - <span class="number">1</span> &lt; n; l ++ ) <span class="comment">// 枚举从哪开始截</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = r + <span class="number">1</span>; k &lt; n; k ++ ) <span class="comment">// 枚举挪到哪个位置（k是结尾位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(w[depth], q, <span class="keyword">sizeof</span> q); <span class="comment">// 把原数组存到w里</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 挪位</span></span><br><span class="line">                <span class="type">int</span> y = l;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = r + <span class="number">1</span>; x &lt;= k; x ++, y ++ ) q[y] = w[depth][x];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = l; x &lt;= r; x ++, y ++ ) q[y] = w[depth][x];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth + <span class="number">1</span>, max_depth)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(q, w[depth], <span class="keyword">sizeof</span> q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代加深</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>; <span class="comment">// 最大层数</span></span><br><span class="line">        <span class="keyword">while</span> (depth &lt; <span class="number">5</span> &amp;&amp; !<span class="built_in">dfs</span>(<span class="number">0</span>, depth)) depth ++ ; <span class="comment">// 这里注意循环判断条件一定要把depth&lt;5放前面！否则TLE</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= <span class="number">5</span>) cout &lt;&lt; <span class="string">&quot;5 or more\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; depth &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挪位理解不了就画图</p><img src="/posts/78aeb4cc/3.png" class><h3 id="回转游戏"><a href="#回转游戏" class="headerlink" title="回转游戏"></a>回转游戏</h3><p><a href="https://www.acwing.com/problem/content/183/">原题链接</a></p><p>如下图所示，有一个 # 形的棋盘，上面有 1,2,3 三种数字各 8 个。</p><p>给定 8 种操作，分别为图中的 $A∼H$。</p><p>这些操作会按照图中字母和箭头所指明的方向，把一条长为 7 的序列循环移动 1 个单位。</p><p>例如下图最左边的 # 形棋盘执行操作 $A$ 后，会变为下图中间的 # 形棋盘，再执行操作 $C$ 后会变成下图最右边的 # 形棋盘。</p><p>给定一个初始状态，请使用最少的操作次数，使 # 形棋盘最中间的 8 个格子里的数字相同。</p><img src="/posts/78aeb4cc/4.png" class><p><strong>输入格式</strong></p><p>输入包含多组测试用例。</p><p>每个测试用例占一行，包含 24 个数字，表示将初始棋盘中的每一个位置的数字，按整体从上到下，同行从左到右的顺序依次列出。</p><p>输入样例中的第一个测试用例，对应上图最左边棋盘的初始状态。</p><p>当输入只包含一个 0 的行时，表示输入终止。</p><p><strong>输出格式</strong></p><p>每个测试用例输出占两行。</p><p>第一行包含所有移动步骤，每步移动用大写字母 $A∼H$ 中的一个表示，字母之间没有空格，如果不需要移动则输出 <code>No moves needed</code>。</p><p>第二行包含一个整数，表示移动完成后，中间 8 个格子里的数字。</p><p>如果有多种方案，则输出字典序最小的解决方案。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AC</span><br><span class="line"><span class="number">2</span></span><br><span class="line">DDHH</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>井字格，每次可以拉动任意一条边，要求用最小的操作次数使中间的八个格子数字一样</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>要求字典序最小，因此按照字典序搜索即可</p><p>每次往下搜所层数都很深，但是根据 <del>搜索问题的玄学性，</del> 直觉来看正确答案的层数不会很深，所以选择迭代加深的算法来做<br>迭代加深搜索的过程中我们加入估价函数，让迭代加深升级为IDA*</p><p>每拉动一次，中间的八个格子只有一个格子的数字会改变，所以先统计八个格子里出现次数最多的数字出现了多少次（记作 $cnt$），那最好的情况就是每操作一次，都使得一个不是最多数的数字变成最多数，因此可以将估价函数设置为 $f()&#x3D;8-cnt$，就可以保证这个数字一定小于等于正确答案</p><p>本题还有一个难点就是怎么表示出这几个操作，我们可以先打表，给格子编号，然后预先处理出几个操作的具体步骤<br>{asset_image 5.png}</p><p><strong>优化：</strong> 本次枚举的操作一定不能是上一次的逆操作</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储每个操作移动的位置</span></span><br><span class="line"><span class="type">int</span> op[<span class="number">8</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">22</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>&#125;,</span><br><span class="line">    &#123;<span class="number">23</span>, <span class="number">21</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">22</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储每个操作对应的逆操作</span></span><br><span class="line"><span class="type">int</span> opposite[<span class="number">8</span>] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储中间的八个数</span></span><br><span class="line"><span class="type">int</span> center[<span class="number">8</span>] = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> path[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> <span class="comment">// 估价函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ ) sum[q[center[i]]] ++ ; <span class="comment">// 找到每个数出现几次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i ++ ) s = <span class="built_in">max</span>(s, sum[i]); <span class="comment">// 找到出现最多的次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> - s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operate</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = q[op[x][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i ++ ) q[op[x][i]] = q[op[x][i + <span class="number">1</span>]];</span><br><span class="line">    q[op[x][<span class="number">6</span>]] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> max_depth, <span class="type">int</span> last)</span> <span class="comment">// depth:当前层数 max_depth:最大层数 last:上一步</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth + <span class="built_in">f</span>() &gt; max_depth) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 范围内找不到解</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到正确答案</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (opposite[i] != last) <span class="comment">// 只要不是逆操作就往下搜</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">operate</span>(i);</span><br><span class="line">            path[depth] = i; <span class="comment">// 记录操作</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth + <span class="number">1</span>, max_depth, i)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 递归操作</span></span><br><span class="line">            <span class="built_in">operate</span>(opposite[i]); <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; q[<span class="number">0</span>], q[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代加深</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">0</span>, depth, <span class="number">-1</span>)) depth ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!depth) cout &lt;&lt; <span class="string">&quot;No moves needed&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i ++ ) cout &lt;&lt; (<span class="type">char</span>)(path[i] + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; q[<span class="number">6</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 迭代加深 </tag>
            
            <tag> IDA* </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】DFS剪枝与优化</title>
      <link href="/posts/2e580918.html"/>
      <url>/posts/2e580918.html</url>
      
        <content type="html"><![CDATA[<p><strong>剪枝</strong>是什么意思呢？</p><p>我们知道，不管是内部搜索还是外部搜索，都可以形成一棵搜索树，如果将搜索树全部遍历一遍，效率会很低，但如果我们能在搜索的过程中，提前预知，判断某一些不可能是正确答案的情况，就可以不用遍历其下的子树，从而提高我们的算法效率</p><p>我们可以从以下几个角度考虑剪枝：</p><ol><li>优化搜索顺序<br>优先选择分支较少的结点</li><li>排除等效冗余<br>尽量保证不搜索重复的状态（就是在不考虑顺序时，采用组合的方式搜索）</li><li>可行性剪枝<br>不合法提前退出</li><li>最优性剪枝<br>如果当前答案无论如何都比目前的最优解要差，那就可以不要往下搜了</li><li>记忆化搜索（DP）</li></ol><p>接下来将通过例题来讲解</p><h1 id="小猫爬山"><a href="#小猫爬山" class="headerlink" title="小猫爬山"></a>小猫爬山</h1><p><a href="https://www.acwing.com/problem/content/167/">原题链接</a></p><p>翰翰和达达饲养了 N 只小猫，这天，小猫们要去爬山。</p><p>经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕&gt;_&lt;）。</p><p>翰翰和达达只好花钱让它们坐索道下山。</p><p>索道上的缆车最大承重量为 W，而 N 只小猫的重量分别是 C1、C2……CN。</p><p>当然，每辆缆车上的小猫的重量之和不能超过 W。</p><p>每租用一辆缆车，翰翰和达达就要付 1 美元，所以他们想知道，最少需要付多少美元才能把这 N 只小猫都运送下山？</p><p><strong>输入格式</strong></p><p>第 1 行：包含两个用空格隔开的整数，N 和 W。</p><p>第 2..N+1 行：每行一个整数，其中第 i+1 行的整数表示第 i 只小猫的重量 Ci。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。</p><p><strong>数据范围</strong></p><p>1 ≤ N ≤ 18,<br>1 ≤ C<del>i</del> ≤ W ≤ 108</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">1996</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1994</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出小猫重量、缆车承重，问最少要多少缆车能把所有小猫运走</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>枚举每只小猫，有两种状态：</p><ul><li>放到当前这辆车上</li><li>新开一辆车</li></ul><p><strong>优化：</strong> </p><ol><li>优化搜索顺序：比较一只比较轻的猫和另一只比较重的猫，显然是比较重的猫带来的分支数量较少，因为如果猫非常重可以直接把车占满，但是猫很轻的话我们就要考虑还要加什么别的猫，因此：将所有猫按从大到小排序，优先放重猫</li><li>可行性剪枝：当发现目前小猫的重量已经超过缆车承重，就不要再往下搜了</li><li>最优性剪枝：当发现目前缆车数量已经大于等于当前计算出的缆车最少数量，就不要再搜索了</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> ans = N; <span class="comment">// 最坏的情况:每只小猫占一辆车</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span> <span class="comment">// u:当前在搜第几只猫 k:当前在搜第几辆车</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 最优性剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ ) <span class="comment">// 遍历每一辆车</span></span><br><span class="line">        <span class="comment">// 可行性剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (sum[i] + w[u] &lt;= m) <span class="comment">// 称重符合条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum[i] += w[u];</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, k);</span><br><span class="line">            sum[i] -= w[u]; <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新开一辆车</span></span><br><span class="line">    sum[k] = w[u];</span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">    sum[k] = <span class="number">0</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化搜索顺序</span></span><br><span class="line">    <span class="built_in">sort</span>(w, w + n);</span><br><span class="line">    <span class="built_in">reverse</span>(w, w + n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数独"><a href="#数独" class="headerlink" title="数独"></a>数独</h1><p><a href="https://www.acwing.com/problem/content/168/">原题链接</a></p><p>数独是一种传统益智游戏，你需要把一个 9×9 的数独补充完整，使得数独中每行、每列、每个 3×3 的九宫格内数字 1∼9 均恰好出现一次。</p><p>请编写一个程序填写数独。</p><p><strong>输入格式</strong></p><p>输入包含多组测试用例。</p><p>每个测试用例占一行，包含 81 个字符，代表数独的 81 个格内数据（顺序总体由上到下，同行由左到右）。</p><p>每个字符都是一个数字（1−9）或一个 .（表示尚未填充）。</p><p>您可以假设输入中的每个谜题都只有一个解决方案。</p><p>文件结尾处为包含单词 end 的单行，表示输入结束。</p><p><strong>输出格式</strong></p><p>每个测试用例，输出一行数据，代表填充完全后的数独。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4.</span>...<span class="number">.8</span><span class="number">.5</span><span class="number">.3</span>.........<span class="number">.7</span>.....<span class="number">.2</span>....<span class="number">.6</span>....<span class="number">.8</span><span class="number">.4</span>.....<span class="number">.1</span>......<span class="number">.6</span><span class="number">.3</span><span class="number">.7</span><span class="number">.5</span>.<span class="number">.2</span>....<span class="number">.1</span><span class="number">.4</span>......</span><br><span class="line">.....<span class="number">.52</span>.<span class="number">.8</span><span class="number">.4</span>.....<span class="number">.3</span>..<span class="number">.9</span>..<span class="number">.5</span><span class="number">.1</span>..<span class="number">.6</span>.<span class="number">.2</span>.<span class="number">.7</span>.......<span class="number">.3</span>....<span class="number">.6</span>..<span class="number">.1</span>.........<span class="number">.7</span><span class="number">.4</span>......<span class="number">.3</span>.</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">417369825632158947958724316825437169791586432346912758289643571573291684164875293</span></span><br><span class="line"><span class="number">416837529982465371735129468571298643293746185864351297647913852359682714128574936</span></span><br></pre></td></tr></table></figure><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>填好数独，保证每行每列、每个3x3方块都包含1-9</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>先做一个小优化，看比如说一个3x3小方格中有哪些数字没被用过，随意选择一个格子，然后对这些数字依次枚举搜索即可</p><p><strong>优化：</strong></p><ol><li>优化搜索顺序：选择格子时，尽量选择分支数量较少的格子，比如说一个格子有2种填法，另一个格子有5种，那肯定优先选择2种的</li><li>可行性剪枝：一旦与行列九宫格重复时就不要继续搜了</li><li>&#x3D;&#x3D;<strong>位运算优化：</strong>&#x3D;&#x3D; 特殊优化，可以用一个九位的二进制数表示每一行数使用的状态<br>比如：0 1 0 0 1 1 1 0 0 可以用来表示2 5 6 7还没用其他数字用过了<br>我们考虑这一位上能不能填这个数时，应该考虑二进制数的交集，即在行、列、九宫格的二进制数列上，这个数字都为1，表示在行、列、九宫格内这个数字都没有被使用，我们才能用这个数（直接按位与&amp;）<br>这里有个比循环九次更好的办法——<strong>lowbit</strong><br>lowbit运算可以帮助我们在O(1)的时间复杂度内，返回当前数里的最后一个1，因此用lowbit循环就可以抠出来所有的1</li></ol><p>好难啊好难啊qaq看代码注释吧还是</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">9</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ones[M]; <span class="comment">// 每个二进制数里1的个数</span></span><br><span class="line"><span class="type">int</span> mapp[M]; <span class="comment">// 把二进制数换成第几位是1</span></span><br><span class="line"><span class="type">int</span> row[N], col[N], cell[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 初始化，将所有位置都标记成没用过(也就是标记成1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ ) row[i] = col[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            cell[i][j] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> t, <span class="type">bool</span> is_set)</span> <span class="comment">// 在(x,y)这个位置填上/删去t 填上的话is_set为true 删去为false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_set) str[x * N + y] = <span class="string">&#x27;1&#x27;</span> + t; <span class="comment">// t属于0-8 要把它换算成1-9</span></span><br><span class="line">    <span class="keyword">else</span> str[x * N + y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span> &lt;&lt; t; <span class="comment">// t换算到在每一行的位置</span></span><br><span class="line">    <span class="keyword">if</span> (!is_set) v = -v; <span class="comment">// 若为清空操作则取反</span></span><br><span class="line"></span><br><span class="line">    row[x] -= v;</span><br><span class="line">    col[y] -= v;</span><br><span class="line">    cell[x / <span class="number">3</span>][y / <span class="number">3</span>] -= v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 返回二进制数的最后一个1以及这个1之后的所有0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">// 返回(x,y)能填的数字(二进制序列)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x / <span class="number">3</span>][y / <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cnt) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 全部填完</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> minv = <span class="number">10</span>; <span class="comment">// 首先找分支数最少的空格，将最少的分支数赋给maxx</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (str[i * N + j] == <span class="string">&#x27;.&#x27;</span>) <span class="comment">// 格子为空可以填数字</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> state = <span class="built_in">get</span>(i, j); <span class="comment">// 该格子能填的数字的交集</span></span><br><span class="line">                <span class="keyword">if</span> (ones[state] &lt; minv)</span><br><span class="line">                &#123;</span><br><span class="line">                    minv = ones[state]; <span class="comment">// 更新最少分支数</span></span><br><span class="line">                    x = i, y = j; <span class="comment">// xy存的就是分支数量最少的格子的坐标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> state = <span class="built_in">get</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = state; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = mapp[<span class="built_in">lowbit</span>(i)]; <span class="comment">// 得到最后一个1所在的位置</span></span><br><span class="line">        <span class="built_in">draw</span>(x, y, t, <span class="literal">true</span>); <span class="comment">// 把t填进去</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(cnt - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 成功直接返回true</span></span><br><span class="line">        <span class="built_in">draw</span>(x, y, t, <span class="literal">false</span>); <span class="comment">// 失败就把填进去的值再删掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打表得到ones和mapp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ ) mapp[<span class="number">1</span> &lt;&lt; i] = i; <span class="comment">// 将所有2^k转化成k(也就是返回二进制数里唯一一个1的位置)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; N; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">            ones[i] += i &gt;&gt; j &amp; <span class="number">1</span>; <span class="comment">// 记下每个二进制数里1的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; str, str[<span class="number">0</span>] != <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 有多少位置没填</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++, k ++ )</span><br><span class="line">                <span class="keyword">if</span> (str[k] != <span class="string">&#x27;.&#x27;</span>) <span class="comment">// 位置不空就把值填进去</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> t = str[k] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="built_in">draw</span>(i, j, t, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++ ; <span class="comment">// 位置空就累加空位的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(cnt);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="木棒"><a href="#木棒" class="headerlink" title="木棒"></a>木棒</h1><p><a href="https://www.acwing.com/problem/content/169/">原题链接</a></p><p>乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过 50 个长度单位。</p><p>然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。</p><p>请你设计一个程序，帮助乔治计算木棒的可能最小长度。</p><p>每一节木棍的长度都用大于零的整数表示。</p><p><strong>输入格式</strong></p><p>输入包含多组数据，每组数据包括两行。</p><p>第一行是一个不超过 64 的整数，表示砍断之后共有多少节木棍。</p><p>第二行是截断以后，所得到的各节木棍的长度。</p><p>在最后一组数据之后，是一个零。</p><p><strong>输出格式</strong></p><p>为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。</p><p><strong>数据范围</strong></p><p>数据保证每一节木棍的长度均不大于 50。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出一些数，将其分成若干组，使每一组总和相等，问最小的总和是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>木棒：每一组的总和<br>木棍：题目中输入的数据</p><p>先从小到大枚举木棒的长度length，看木棍能不能组成该长度的木棒</p><p><strong>优化：</strong></p><ol><li>所有木棍的总长度sum必须能整除木棒的长度length，才可能有解，不能整除的情况直接回溯不要搜了</li><li>优化搜索顺序：先枚举比较长的木棍，使之后的分支较少</li><li>排除等效冗余：<br>(1) 如果一根木棒里有第一根第二根两根木棍，那么先用第一根和先用第二根达成的效果都是一样的，因此按照组合数方式枚举<br>(2) 如果当前木棍加到当前木棒中失败，那直接略过后面所有等长木棍<br>(3) 如果是木棒的第一根木棍失败（说明这根木棍没地方放），则当前状态一定失败，直接回溯不要往下搜了<br>(4) 如果是木棒的最后一根木棍失败（这里的意思是往下dfs找不到解），则当前状态一定失败（因为放入比这根木棍小的木棍拼接起来的也一定找不到解），直接回溯不要往下搜了</li></ol><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N], sum, length; <span class="comment">// w[i]:每根小棍长度 sum:所有小棍总长度 length:每组总和</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 小棍有没有用过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s, <span class="type">int</span> start)</span> <span class="comment">// u:当前枚举到哪根大棍 s:当前大棍长度 start:开始位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u * length == sum) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 符合条件</span></span><br><span class="line">    <span class="keyword">if</span> (s == length) <span class="keyword">return</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 这根木棍长度已达要求，开下一根木棍</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化3(1):从start开始枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i ++ ) <span class="comment">// 从start开始遍历木棍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line">        <span class="keyword">if</span> (s + w[i] &gt; length) <span class="keyword">continue</span>; <span class="comment">// 可行性剪枝</span></span><br><span class="line"></span><br><span class="line">        st[i] = <span class="literal">true</span>; <span class="comment">// 更改状态</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(u, s + w[i], i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 下一层遍历</span></span><br><span class="line">        st[i] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化3(3):开头不行就一定不行</span></span><br><span class="line">        <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化3(4):结尾不行就一定不行</span></span><br><span class="line">        <span class="keyword">if</span> (s + w[i] == length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化3(2):等长直接略过</span></span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; w[j] == w[i]) j ++ ;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; w[i];</span><br><span class="line">            sum += w[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化2：搜索顺序</span></span><br><span class="line">        <span class="built_in">sort</span> (w, w + n);</span><br><span class="line">        <span class="built_in">reverse</span>(w, w + n);</span><br><span class="line"></span><br><span class="line">        length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 优化1:必须是整数倍</span></span><br><span class="line">            <span class="keyword">if</span> (sum % length == <span class="number">0</span> &amp;&amp; <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; length &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            length ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生日蛋糕"><a href="#生日蛋糕" class="headerlink" title="生日蛋糕"></a>生日蛋糕</h1><p><a href="https://www.acwing.com/problem/content/170/">原题链接</a></p><p>7 月 17 日是 Mr.W 的生日，ACM-THU 为此要制作一个体积为 Nπ 的 M 层生日蛋糕，每层都是一个圆柱体。</p><p>设从下往上数第 i 层蛋糕是半径为 Ri，高度为 Hi 的圆柱。</p><p>当 $i&lt;M$ 时，要求 $Ri&gt;Ri+1$ 且 H<del>i</del> &gt; H<del>i+1</del>。</p><p>由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积 Q 最小。</p><p>令 $Q&#x3D;Sπ$ ，请编程对给出的 N 和 M，找出蛋糕的制作方案（适当的 Ri 和 Hi 的值），使 S 最小。</p><p>除 Q 外，以上所有数据皆为正整数。</p><p><strong>输入格式</strong></p><p>输入包含两行，第一行为整数 N，表示待制作的蛋糕的体积为 Nπ。</p><p>第二行为整数 M，表示蛋糕的层数为 M。</p><p><strong>输出格式</strong></p><p>输出仅一行，是一个正整数 S（若无解则 S&#x3D;0）。</p><p><strong>数据范围</strong></p><p>1 ≤ N ≤ 10000,<br>1 ≤ M ≤ 20</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">68</span></span><br></pre></td></tr></table></figure><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>多层蛋糕，给出总体积总层数，可以自定义每一层半径和高度，使得从上往下看的总面积和总侧面积之和最小，求最小值</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先明确我们的目的是让 2 * R<del>m</del> * h<del>m</del> + 2 * R<del>m-1</del> * h<del>m-1</del> + … + 2 * R<del>1</del> * h<del>1</del> + R<del>m</del>^2^ 最小（省去了所有的$π$）</p><p><strong>优化：</strong></p><ol><li>优化搜索顺序：分支少的先搜，从大到小枚举<br>(1) 要先搜面积大的，因此自底向上搜<br>(2) 半径是平方级别，高是一次方，半径对体积影响更大，因此先枚举半径</li><li>可行性剪枝：<br>(1) 设从上往下为1-m层，第 u 层的半径记为 R<del>u</del>，一定比 u 大，且比 R<del>u+1</del> - 1 小，同时，我们设第 u 层下方的所有体积为 V，那么前 u 层的体积就是 $n - V$，即有 $n - V &gt;&#x3D; R_u^2h_u$，放缩后有 $R_u &lt;&#x3D; \sqrt{n - V}$<br>据此得到：**&#x3D;&#x3D;$u &lt;&#x3D; R_u &lt;&#x3D; min{R_{u+1}-1,  \sqrt{n-V}}$&#x3D;&#x3D;**<br>(2) 同时，H<del>u</del>也&gt;&#x3D;u，且比 H<del>u+1</del>小， $n - V &gt;&#x3D; R_u^2h_u$，放缩后有 $h_u&lt;&#x3D; \frac{n-V}{R^2}$<br>据此得到：**&#x3D;&#x3D;$u &lt;&#x3D; h_u &lt;&#x3D; min{h_{u+1}-1,  \frac{n-V}{R^2}}$&#x3D;&#x3D;**</li><li>最小体积是半径和高都取1时，因此可以预处理一下前 u 层的体积最小值$minv(u)$和表面积最小值$mins(u)$，需要满足以下两个条件才有往下搜的必要，否则直接回溯：<br><strong>&#x3D;&#x3D;$V+minv(u)&lt;&#x3D;n$&#x3D;&#x3D;</strong><br><strong>&#x3D;&#x3D;$s+mins(u)&lt;ans$&#x3D;&#x3D;</strong></li><li>已知：$n-V&#x3D;\sum_{k&#x3D;1}^{u}R_k^2h_k$<br>并且：$S_{1\rightarrow u}&#x3D;\sum_{k&#x3D;1}^{u}2R_kh_k&#x3D;\frac{2}{R_{u+1}}\sum_{k&#x3D;1}^{u}R_uhR_{u+1}&gt;\frac{2}{R_{u+1}}\sum_{k&#x3D;1}^{u}R_u^2h$<br>因此：$S_{1\rightarrow u}&gt;\frac{2(n-V)}{R_{u+1}}$<br>所以当$s+\frac{2(n-V)}{R_{u+1}}&gt;&#x3D;ans$时，已经不可能是最优解了，直接回溯</li></ol><p>(好难…疯掉TAT</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> minv[N], mins[N]; <span class="comment">// 分别表示每一层及该层上方的最小体积和最小表面积</span></span><br><span class="line"><span class="type">int</span> R[N], H[N]; <span class="comment">// 表示每一层的半径和高</span></span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> s)</span> <span class="comment">// u:当前层数 v:当前体积 s:当前表面积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v + minv[u] &gt; n) <span class="keyword">return</span>; <span class="comment">// 优化3</span></span><br><span class="line">    <span class="keyword">if</span> (s + mins[u] &gt;= ans) <span class="keyword">return</span>; <span class="comment">// 优化3</span></span><br><span class="line">    <span class="keyword">if</span> (s + <span class="number">2</span> * (n - v) / R[u + <span class="number">1</span>] &gt;= ans) <span class="keyword">return</span>; <span class="comment">// 优化4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="comment">//已全部搜完</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == n) ans = s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化1:从大到小枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="built_in">min</span>(R[u + <span class="number">1</span>] - <span class="number">1</span>, (<span class="type">int</span>)<span class="built_in">sqrt</span>(n - v)); r &gt;= u; r -- ) <span class="comment">// 优化2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> h = <span class="built_in">min</span>(H[u + <span class="number">1</span>] - <span class="number">1</span>, (n - v) / r / r); h &gt;= u; h -- ) <span class="comment">// 优化2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (u == m) t = r * r; <span class="comment">// 如果是最底层，要加上底面积</span></span><br><span class="line">            R[u] = r, H[u] = h; <span class="comment">// 更新RH</span></span><br><span class="line">            <span class="built_in">dfs</span>(u - <span class="number">1</span>, v + r * r * h, s + <span class="number">2</span> * h * r + t);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打表做出minv mins</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        minv[i] = minv[i - <span class="number">1</span>] + i * i * i;</span><br><span class="line">        mins[i] = mins[i - <span class="number">1</span>] + <span class="number">2</span> * i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    R[m + <span class="number">1</span>] = H[m + <span class="number">1</span>] = inf; <span class="comment">// 设置哨兵</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(m, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans == inf) ans = <span class="number">0</span>; <span class="comment">// 无满足要求的情况</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】DFS搜索顺序</title>
      <link href="/posts/7614fc0a.html"/>
      <url>/posts/7614fc0a.html</url>
      
        <content type="html"><![CDATA[<h1 id="马走日"><a href="#马走日" class="headerlink" title="马走日"></a>马走日</h1><p><a href="https://www.acwing.com/problem/content/1118/">原题链接</a></p><p>马在中国象棋以日字形规则移动。</p><p>请编写一段程序，给定 n∗m 大小的棋盘，以及马的初始位置 (x，y)，要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。</p><p><strong>输入格式</strong></p><p>第一行为整数 T，表示测试数据组数。</p><p>每一组测试数据包含一行，为四个整数，分别为棋盘的大小以及初始位置坐标 n,m,x,y。</p><p><strong>输出格式</strong></p><p>每组测试数据包含一行，为一个整数，表示马能遍历棋盘的途径总数，若无法遍历棋盘上的所有点则输出 0。</p><p><strong>数据范围</strong></p><p>1 ≤ T ≤ 9,<br>1 ≤ m , n ≤9,<br>1 ≤ n × m ≤ 28,<br>0 ≤ x ≤ n − 1,<br>0 ≤ y ≤ m − 1</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出矩阵大小，给出马的初始位置，马只能走日。问有多少种方案让马可以遍历完棋盘上的所有点，每种方案里不可以重复经过两个点</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这就是典型的外部搜索，是不同状态之间的搜索，因此每次需要恢复现场（可以理解为悔棋）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cnt)</span> <span class="comment">// 前两个参数表示当前点坐标，第三个参数表示目前已经搜了多少个点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n * m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans ++ ;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ ) <span class="comment">// 遍历八个操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line">        <span class="built_in">dfs</span>(a, b, cnt + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    st[x][y] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙</h1><p><a href="https://www.acwing.com/problem/content/1119/">原题链接</a></p><p>单词接龙是一个与我们经常玩的成语接龙相类似的游戏。</p><p>现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”，每个单词最多被使用两次。</p><p>在两个单词相连时，其重合部分合为一部分，例如 beast 和 astonish ，如果接成一条龙则变为 beastonish。</p><p>我们可以任意选择重合部分的长度，但其长度必须大于等于1，且严格小于两个串的长度，例如 at 和 atide 间不能相连。</p><p><strong>输入格式</strong></p><p>输入的第一行为一个单独的整数 n 表示单词数，以下 n 行每行有一个单词（只含有大写或小写字母，长度不超过20），输入的最后一行为一个单个字符，表示“龙”开头的字母。</p><p>你可以假定以此字母开头的“龙”一定存在。</p><p><strong>输出格式</strong></p><p>只需输出以此字母开头的最长的“龙”的长度。</p><p><strong>数据范围</strong></p><p>n ≤ 20，<br>单词随机生成。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">at</span><br><span class="line">touch</span><br><span class="line">cheat</span><br><span class="line">choose</span><br><span class="line">tact</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>连成的“龙”为 atoucheatactactouchoose。</p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出多个字符串，首位有相同字串的两个字符串可以连接，给出开头字符，问能连接的最大长度</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>外部搜索，每次需恢复原状</p><p>从开头字符与给定字符相同的单词开始，每次遇到能接到字符串后面的就往深遍历，（形成一个搜索树一样的结构）</p><p>下方代码有详细注释</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string word[N]; <span class="comment">// 记录每个单词</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 记录每两个单词有多少重合</span></span><br><span class="line"><span class="type">int</span> used[N]; <span class="comment">// 记录这个单词被用了多少次</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string dragon, <span class="type">int</span> last)</span> <span class="comment">// 第一个参数是当前字符串 第二个参数是当前最后一个字符串编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>((<span class="type">int</span>)dragon.<span class="built_in">size</span>(), ans); <span class="comment">// 更新最大长度</span></span><br><span class="line"></span><br><span class="line">    used[last] ++ ; <span class="comment">// 更新字符串使用次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 遍历每个字符串</span></span><br><span class="line">        <span class="keyword">if</span> (g[last][i] &amp;&amp; used[i] &lt; <span class="number">2</span>) <span class="comment">// 条件：和当前最后一个字符串有重合 &amp;&amp; 使用次数不到2次</span></span><br><span class="line">            <span class="built_in">dfs</span>(dragon + word[i].<span class="built_in">substr</span>(g[last][i]), i);</span><br><span class="line"></span><br><span class="line">    used[last] -- ; <span class="comment">// 恢复</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; word[i];</span><br><span class="line">    <span class="type">char</span> start;</span><br><span class="line">    cin &gt;&gt; start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每两个字符串最短的重合字符个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            string a = word[i], b = word[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; <span class="built_in">min</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()); k ++ ) <span class="comment">// 从1开始，最长不超过较短字符串长度</span></span><br><span class="line">                <span class="keyword">if</span> (a.<span class="built_in">substr</span>(a.<span class="built_in">size</span>() - k, k) == b.<span class="built_in">substr</span>(<span class="number">0</span>, k)) <span class="comment">// 一旦重合立刻跳出</span></span><br><span class="line">                &#123;</span><br><span class="line">                    g[i][j] = k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (word[i][<span class="number">0</span>] == start)</span><br><span class="line">            <span class="built_in">dfs</span>(word[i], i);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分成互质组"><a href="#分成互质组" class="headerlink" title="分成互质组"></a>分成互质组</h1><p><a href="https://www.acwing.com/problem/content/1120/">原题链接</a></p><p>给定 n 个正整数，将它们分组，使得每组中任意两个数互质。</p><p>至少要分成多少个组？</p><p><strong>输入格式</strong></p><p>第一行是一个正整数 n。</p><p>第二行是 n 个不大于10000的正整数。</p><p><strong>输出格式</strong></p><p>一个正整数，即最少需要的组数。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 10</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">14</span> <span class="number">20</span> <span class="number">33</span> <span class="number">117</span> <span class="number">143</span> <span class="number">175</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>每个组的数要互质，给出一系列数，问最少多少组</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>按照<strong>组合的方式</strong>搜索，每个组里按照下表从小到大添加所有能加进去的元素，直到不能再加任何一个元素，就新开一个组</p><p>&#x3D;&#x3D;<strong>当某个数可以加到最后一组时，就没有必要新开一个组</strong>&#x3D;&#x3D;</p><p>下方代码中有详细注释</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 存所有元素</span></span><br><span class="line"><span class="type">int</span> group[N][N]; <span class="comment">// 存每个组以及其中元素</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 判重</span></span><br><span class="line"><span class="type">int</span> ans = N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// 找最大公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> group[], <span class="type">int</span> gc, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; gc; j ++ ) <span class="comment">// 遍历group中的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">gcd</span>(p[group[j]], p[i]) &gt; <span class="number">1</span>) <span class="comment">// 最大公约数大于1说明不是互质</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> gc, <span class="type">int</span> tc, <span class="type">int</span> start)</span> <span class="comment">// u:第几组 gc:当前组内下标 tc:当前一共有多少元素 start:当前这一组从哪个元素开始搜</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt;= ans) <span class="keyword">return</span>; <span class="comment">// 剪枝优化:如果当前组数已经大于等于ans 说明一定不是最优解 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tc == n) ans = u; <span class="comment">// 所有数都搜索完了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// true表示当前组不能继续添加新元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i ++ ) <span class="comment">// 从start开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i] &amp;&amp; <span class="built_in">check</span>(group[u], gc, i)) <span class="comment">// 该元素没用过且与当前组所有元素互质</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>; <span class="comment">// 标记该元素</span></span><br><span class="line">            group[u][gc] = i; <span class="comment">// 将该元素加入组中</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span>(u, gc + <span class="number">1</span>, tc + <span class="number">1</span>, i + <span class="number">1</span>); <span class="comment">// 下一层遍历</span></span><br><span class="line"></span><br><span class="line">            st[i] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            flag = <span class="literal">false</span>; <span class="comment">// 表示还能添加新元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">dfs</span>(u + <span class="number">1</span>, <span class="number">0</span>, tc, <span class="number">0</span>); <span class="comment">// 不能添加新元素时新开一个组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】DFS连通性模型</title>
      <link href="/posts/46c8bf03.html"/>
      <url>/posts/46c8bf03.html</url>
      
        <content type="html"><![CDATA[<p>DFS 的搜索分为两大部分：</p><ul><li><strong>内部搜索</strong>：一个图中从一个点搜到另一个点</li><li><strong>外部搜索</strong>：从一张图（状态）搜到另一张图（状态）</li></ul><p>在第一个部分里是图内部点的搜索，每个点只能搜一次，因此搜过的点不需要恢复到原来的（还没被搜过的）状态（意思就是st数组不恢复）</p><p>而第二个部分是点的集合之间的搜索，每次搜索完一定要恢复到原有状态才可以进行下一步搜索（意思就是st数组每次需要恢复原状）</p><h1 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h1><p><a href="https://www.acwing.com/problem/content/1114/">原题链接</a></p><p>一天Extense在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由 n∗n 的格点组成，每个格点只有2种状态，.和#，前者表示可以通行后者表示不能通行。</p><p>同时当Extense处在某个格点时，他只能移动到东南西北(或者说上下左右)四个方向之一的相邻格点上，Extense想要从点A走到点B，问在不走出迷宫的情况下能不能办到。</p><p>如果起点或者终点有一个不能通行(为#)，则看成无法办到。</p><p>注意：A、B不一定是两个不同的点。</p><p><strong>输入格式</strong></p><p>第1行是测试数据的组数 k，后面跟着 k 组输入。</p><p>每组测试数据的第1行是一个正整数 n，表示迷宫的规模是 n∗n 的。</p><p>接下来是一个 n∗n 的矩阵，矩阵中的元素为.或者#。</p><p>再接下来一行是 4 个整数 ha,la,hb,lb，描述 A 处在第 ha 行, 第 la 列，B 处在第 hb 行, 第 lb 列。</p><p>注意到 ha,la,hb,lb 全部是从 0 开始计数的。</p><p><strong>输出格式</strong></p><p>k行，每行输出对应一个输入。</p><p>能办到则输出“YES”，否则输出“NO”。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 100</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">.##</span><br><span class="line">..#</span><br><span class="line">#..</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">.....</span><br><span class="line">###.#</span><br><span class="line">..#..</span><br><span class="line">###..</span><br><span class="line">...#.</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一张图两个点，问能不能从一个点走到另一个点</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接bfs遍历看能不能从一个点遍历到另一个</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line"><span class="type">int</span> xa, ya, xb, yb; <span class="comment">// 标记起点终点</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g[x][y] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == xb &amp;&amp; y == yb) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) <span class="comment">// 遍历四个操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(a, b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line">        cin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(xa, ya)) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="红与黑"><a href="#红与黑" class="headerlink" title="红与黑"></a>红与黑</h1><p><a href="https://www.acwing.com/problem/content/1115/">原题链接</a></p><p>有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。</p><p>你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。</p><p>请写一个程序，计算你总共能够到达多少块黑色的瓷砖。</p><p><strong>输入格式</strong></p><p>输入包括多个数据集合。</p><p>每个数据集合的第一行是两个整数 W 和 H，分别表示 x 方向和 y 方向瓷砖的数量。</p><p>在接下来的 H 行中，每行包括 W 个字符。每个字符表示一块瓷砖的颜色，规则如下</p><p>1）‘.’：黑色的瓷砖；<br>2）‘#’：红色的瓷砖；<br>3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。</p><p>当在一行中读入的是两个零时，表示输入结束。</p><p><strong>输出格式</strong></p><p>对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。</p><p><strong>数据范围</strong></p><p>1 ≤ W , H ≤ 20</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">9</span> </span><br><span class="line">....#. </span><br><span class="line">.....# </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">#@...# </span><br><span class="line">.#..#. </span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一个图分为红黑方块，问某一个黑方块的连通块个数</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本质上是个Flood Fill问题，可以用BFS实现</p><p>用DFS也是一样的，只是搜索顺序不一样</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">        <span class="keyword">if</span> (g[a][b] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>; <span class="comment">// 不是黑色的</span></span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line"></span><br><span class="line">        cnt += <span class="built_in">dfs</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; m &gt;&gt; n, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>) <span class="comment">// 找起点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">dfs</span>(x, y) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 连通性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】Flood Fill</title>
      <link href="/posts/de9f691a.html"/>
      <url>/posts/de9f691a.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>什么是 Flood Fill 算法？<br>字面意思理解：洪水覆盖<br>也就是说，下图的格子分为两大类，一类比较高一类比较低，现在从任意一处较低的格子开始灌水，下一次水将会覆盖它&#x3D;&#x3D;相邻的&#x3D;&#x3D;、&#x3D;&#x3D;较低的&#x3D;&#x3D;格子，依此类推<br>这就相当于是BFS的思想（也可以用DFS实现，但BFS不会出现爆栈的问题）</p><p><strong>Flood Fill 算法可以在线性时间复杂度内，找到某个点所在的连通块</strong></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="池塘计数"><a href="#池塘计数" class="headerlink" title="池塘计数"></a>池塘计数</h2><p><a href="https://www.acwing.com/problem/content/1099/">原题链接</a></p><p>农夫约翰有一片 N∗M 的矩形土地。</p><p>最近，由于降雨的原因，部分土地被水淹没了。</p><p>现在用一个字符矩阵来表示他的土地。</p><p>每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。</p><p>现在，约翰想知道他的土地中形成了多少片池塘。</p><p>每组相连的积水单元格集合可以看作是一片池塘。</p><p>每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。</p><p>请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 N 和 M。</p><p>接下来 N 行，每行包含 M 个字符，字符为”W”或”.”，用以表示矩形土地的积水状况，字符之间没有空格。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示池塘数目。</p><p><strong>数据范围</strong><br>1 ≤ N, M ≤ 1000</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">12</span></span><br><span class="line">W........WW.</span><br><span class="line">.WWW.....WWW</span><br><span class="line">....WW...WW.</span><br><span class="line">.........WW.</span><br><span class="line">.........W..</span><br><span class="line">..W......W..</span><br><span class="line">.W.W.....WW.</span><br><span class="line">W.W.W.....W.</span><br><span class="line">.W.W......W.</span><br><span class="line">..W.......W.</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>模板题，问有多少连通块</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按顺序遍历图上每一个点，如果这个点是洼地且未被遍历过，就在答案的基础上加1，并且标记这个连通块的所有点，直到遍历完整个图</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t.ft - <span class="number">1</span>; i &lt;= t.ft + <span class="number">1</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = t.sd - <span class="number">1</span>; j &lt;= t.sd + <span class="number">1</span>; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == t.ft &amp;&amp; j == t.sd) <span class="keyword">continue</span>; <span class="comment">// 正好遍历到当前点</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;.&#x27;</span> || st[i][j]) <span class="keyword">continue</span>; <span class="comment">// 不是洼地或已遍历过</span></span><br><span class="line"></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                st[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;W&#x27;</span> &amp;&amp; !st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">bfs</span>(i, j);</span><br><span class="line">                cnt ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="城堡问题"><a href="#城堡问题" class="headerlink" title="城堡问题"></a>城堡问题</h2><p><a href="https://www.acwing.com/problem/content/1100/">原题链接</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   1   2   3   4   5   6   7  </span><br><span class="line">  #############################</span><br><span class="line">1 #   |   #   |   #   |   |   #</span><br><span class="line">  #####---#####---#---#####---#</span><br><span class="line">2 #   #   |   #   #   #   #   #</span><br><span class="line">  #---#####---#####---#####---#</span><br><span class="line">3 #   |   |   #   #   #   #   #</span><br><span class="line">  #---#########---#####---#---#</span><br><span class="line">4 #   #   |   |   |   |   #   #</span><br><span class="line">  #############################</span><br><span class="line">             (图 1)</span><br><span class="line"></span><br><span class="line">  #  = Wall   </span><br><span class="line">  |  = No wall</span><br><span class="line">  -  = No wall</span><br><span class="line"></span><br><span class="line">  方向：上北下南左西右东。</span><br></pre></td></tr></table></figure><p>图1是一个城堡的地形图。</p><p>请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。</p><p>城堡被分割成 m∗n 个方格区域，每个方格区域可以有0~4面墙。</p><p>注意：墙体厚度忽略不计。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 m 和 n，分别表示城堡南北方向的长度和东西方向的长度。</p><p>接下来 m 行，每行包含 n 个整数，每个整数都表示平面图对应位置的方块的墙的特征。</p><p>每个方块中墙的特征由数字 P 来描述，我们用1表示西墙，2表示北墙，4表示东墙，8表示南墙，P 为该方块包含墙的数字之和。</p><p>例如，如果一个方块的 P 为3，则 3 &#x3D; 1 + 2，该方块包含西墙和北墙。</p><p>城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。</p><p>输入的数据保证城堡至少有两个房间。</p><p><strong>输出格式</strong></p><p>共两行，第一行输出房间总数，第二行输出最大房间的面积（方块数）。</p><p><strong>数据范围</strong></p><p>1 ≤ m, n ≤ 50,<br>0 ≤ P ≤ 15</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">7</span> </span><br><span class="line"><span class="number">11</span> <span class="number">6</span> <span class="number">11</span> <span class="number">6</span> <span class="number">3</span> <span class="number">10</span> <span class="number">6</span> </span><br><span class="line"><span class="number">7</span> <span class="number">9</span> <span class="number">6</span> <span class="number">13</span> <span class="number">5</span> <span class="number">15</span> <span class="number">5</span> </span><br><span class="line"><span class="number">1</span> <span class="number">10</span> <span class="number">12</span> <span class="number">7</span> <span class="number">13</span> <span class="number">7</span> <span class="number">5</span> </span><br><span class="line"><span class="number">13</span> <span class="number">11</span> <span class="number">10</span> <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">13</span> </span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个城堡中每个房间四面是否有墙壁，输出该城堡有多少个连通的房间，最大的连通块面积是多少</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>和上一题基本一样，判断每个房间的四面墙壁情况，只是要额外加一个面积的计算</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        area ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; <span class="comment">// 已被遍历</span></span><br><span class="line">            <span class="keyword">if</span> (g[t.ft][t.sd] &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 这个方向是墙</span></span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">            st[a][b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                area = <span class="built_in">max</span>(area, <span class="built_in">bfs</span>(i, j));</span><br><span class="line">                cnt ++ ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="山峰和山谷"><a href="#山峰和山谷" class="headerlink" title="山峰和山谷"></a>山峰和山谷</h2><p><a href="https://www.acwing.com/problem/content/1108/">原题链接</a></p><p>FGD小朋友特别喜欢爬山，在爬山的时候他就在研究山峰和山谷。</p><p>为了能够对旅程有一个安排，他想知道山峰和山谷的数量。</p><p>给定一个地图，为FGD想要旅行的区域，地图被分为 n×n 的网格，每个格子 (i,j) 的高度 w(i,j) 是给定的。</p><p>若两个格子有公共顶点，那么它们就是相邻的格子，如与 (i,j) 相邻的格子有(i−1,j−1),(i−1,j),(i−1,j+1),(i,j−1),(i,j+1),(i+1,j−1),(i+1,j),(i+1,j+1)。</p><p>我们定义一个格子的集合 S 为山峰（山谷）当且仅当：</p><ol><li>S 的所有格子都有相同的高度。</li><li>S 的所有格子都连通。</li><li>对于 s 属于 S，与 s 相邻的 s′ 不属于 S，都有 ws&gt;ws′（山峰），或者 ws&lt;ws′（山谷）。</li><li>如果周围不存在相邻区域，则同时将其视为山峰和山谷。</li></ol><p>你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。</p><p><strong>输入格式</strong></p><p>第一行包含一个正整数 n，表示地图的大小。</p><p>接下来一个 n×n 的矩阵，表示地图上每个格子的高度 w。</p><p><strong>输出格式</strong></p><p>共一行，包含两个整数，表示山峰和山谷的数量。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 1000,<br>0 ≤ w ≤ 109</p><p><strong>输入样例1</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">7</span> <span class="number">7</span> <span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>输出样例1</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输入样例2</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>输出样例2</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出不同地块的高度，高度相同的连通块周边高度都小于等于该连通块高度，那么该连通块为山峰，反之为山谷，问山峰山谷数量</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>依旧是遍历每一个点，如果没有遍历过该点，就遍历该点所在连通块，直到找到连通块边界，再判断这个连通块是否为山峰或山谷</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N][N];</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">bool</span>&amp; has_higher, <span class="type">bool</span>&amp; has_lower)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t.ft - <span class="number">1</span>; i &lt;= t.ft + <span class="number">1</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = t.sd - <span class="number">1</span>; j &lt;= t.sd + <span class="number">1</span>; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == t.ft &amp;&amp; j == t.sd) <span class="keyword">continue</span>; <span class="comment">// 遍历到自身</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">                <span class="keyword">if</span> (h[i][j] != h[t.ft][t.sd]) <span class="comment">// 边界</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (h[i][j] &gt; h[t.ft][t.sd]) has_higher = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> has_lower = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!st[i][j]) <span class="comment">// 非边界且未遍历</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                    st[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cin &gt;&gt; h[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> peak = <span class="number">0</span>, valley = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> has_higher = <span class="literal">false</span>, has_lower = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bfs</span>(i, j, has_higher, has_lower);</span><br><span class="line">                <span class="keyword">if</span> (!has_higher) peak ++ ;</span><br><span class="line">                <span class="keyword">if</span> (!has_lower) valley ++ ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; peak &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; valley &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> Flood Fill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】BFS中的最短路模型</title>
      <link href="/posts/922f99a.html"/>
      <url>/posts/922f99a.html</url>
      
        <content type="html"><![CDATA[<p>BFS可以解决边权为1的最短路问题，下面是相关例题</p><h1 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h1><p>将源点在开始时存进队列</p><h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><p><a href="https://www.acwing.com/problem/content/1078/">原题链接</a></p><p>给定一个 n×n 的二维数组，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maze[5][5] = &#123;</span><br><span class="line"></span><br><span class="line">0, 1, 0, 0, 0,</span><br><span class="line"></span><br><span class="line">0, 1, 0, 1, 0,</span><br><span class="line"></span><br><span class="line">0, 0, 0, 0, 0,</span><br><span class="line"></span><br><span class="line">0, 1, 1, 1, 0,</span><br><span class="line"></span><br><span class="line">0, 0, 0, 1, 0,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。</p><p>数据保证至少存在一条从左上角走到右下角的路径。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n。</p><p>接下来 n 行，每行包含 n 个整数 0 或 1，表示迷宫。</p><p><strong>输出格式</strong></p><p>输出从左上角到右下角的最短路线，如果答案不唯一，输出任意一条路径均可。</p><p>按顺序，每行输出一个路径中经过的单元格的坐标，左上角坐标为 (0,0)，右下角坐标为 (n−1,n−1)。</p><p><strong>数据范围</strong></p><p>0 ≤ n ≤ 1000</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个矩阵，0代表有路1代表没有路，问从左上角走到右下角的最短路径</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为边权均为1，所以利用BFS可以求出从起点到终点的最短路，同时利用一个小技巧从终点往起点走，即可在后续输出路径时正向输出</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line">PII pre[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 代表上下左右四个移动方向</span></span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            <span class="keyword">if</span> (g[a][b]) <span class="keyword">continue</span>; <span class="comment">// 没路</span></span><br><span class="line">            <span class="keyword">if</span> (pre[a][b].ft != <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 走过了</span></span><br><span class="line">            </span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">            pre[a][b] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>(n - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">PII <span class="title">end</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; end.ft &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; end.sd &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (end.ft == n - <span class="number">1</span> &amp;&amp; end.sd == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        end = pre[end.ft][end.sd];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="武士风度的牛"><a href="#武士风度的牛" class="headerlink" title="武士风度的牛"></a>武士风度的牛</h2><p><a href="https://www.acwing.com/problem/content/190/">原题链接</a></p><p>农民 John 有很多牛，他想交易其中一头被 Don 称为 The Knight 的牛。</p><p>这头牛有一个独一无二的超能力，在农场里像 Knight 一样地跳（就是我们熟悉的象棋中马的走法）。</p><p>虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个 x，y 的坐标图来表示。</p><p>这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了 The Knight 的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。</p><p>现在你的任务是，确定 The Knight 要想吃到草，至少需要跳多少次。</p><p>The Knight 的位置用 K 来标记，障碍的位置用 * 来标记，草的位置用 H 来标记。</p><p>这里有一个地图的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11 | . . . . . . . . . .</span><br><span class="line">10 | . . . . * . . . . . </span><br><span class="line"> 9 | . . . . . . . . . . </span><br><span class="line"> 8 | . . . * . * . . . . </span><br><span class="line"> 7 | . . . . . . . * . . </span><br><span class="line"> 6 | . . * . . * . . . H </span><br><span class="line"> 5 | * . . . . . . . . . </span><br><span class="line"> 4 | . . . * . . . * . . </span><br><span class="line"> 3 | . K . . . . . . . . </span><br><span class="line"> 2 | . . . * . . . . . * </span><br><span class="line"> 1 | . . * . . . . * . . </span><br><span class="line"> 0 ----------------------</span><br><span class="line">                       1 </span><br><span class="line">   0 1 2 3 4 5 6 7 8 9 0 </span><br></pre></td></tr></table></figure><p>The Knight 可以按照下图中的 A,B,C,D… 这条路径用 5 次跳到草的地方（有可能其它路线的长度也是 5）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11 | . . . . . . . . . .</span><br><span class="line">10 | . . . . * . . . . .</span><br><span class="line"> 9 | . . . . . . . . . .</span><br><span class="line"> 8 | . . . * . * . . . .</span><br><span class="line"> 7 | . . . . . . . * . .</span><br><span class="line"> 6 | . . * . . * . . . F&lt;</span><br><span class="line"> 5 | * . B . . . . . . .</span><br><span class="line"> 4 | . . . * C . . * E .</span><br><span class="line"> 3 | .&gt;A . . . . D . . .</span><br><span class="line"> 2 | . . . * . . . . . *</span><br><span class="line"> 1 | . . * . . . . * . .</span><br><span class="line"> 0 ----------------------</span><br><span class="line">                       1</span><br><span class="line">   0 1 2 3 4 5 6 7 8 9 0</span><br></pre></td></tr></table></figure><p>注意： 数据保证一定有解。</p><p><strong>输入格式</strong></p><p>第 1 行： 两个数，表示农场的列数 C 和行数 R。</p><p>第 2..R+1 行: 每行一个由 C 个字符组成的字符串，共同描绘出牧场地图。</p><p><strong>输出格式</strong></p><p>一个整数，表示跳跃的最小次数。</p><p><strong>数据范围</strong></p><p>1 ≤ R , C ≤ 150</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">11</span></span><br><span class="line">..........</span><br><span class="line">....*.....</span><br><span class="line">..........</span><br><span class="line">...*.*....</span><br><span class="line">.......*..</span><br><span class="line">..*..*...H</span><br><span class="line">*.........</span><br><span class="line">...*...*..</span><br><span class="line">.K........</span><br><span class="line">...*.....*</span><br><span class="line">..*....*..</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>图中<code>*</code>代表没有路，<code>.</code>代表有路，求以日字型从K走到H的最短路</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>dx dy改成向八个不同方向移，其余思路一样，第一次遍历到H时输出即可</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">155</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// 记录距离+判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">                x = i, y = j;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[x][y] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>; <span class="comment">// 没路</span></span><br><span class="line">            <span class="keyword">if</span> (dist[a][b] != <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;H&#x27;</span>) <span class="keyword">return</span> dist[t.ft][t.sd] + <span class="number">1</span>; <span class="comment">// 走到终点</span></span><br><span class="line"></span><br><span class="line">            dist[a][b] = dist[t.ft][t.sd] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抓住那头牛"><a href="#抓住那头牛" class="headerlink" title="抓住那头牛"></a>抓住那头牛</h2><p><a href="https://www.acwing.com/problem/content/1102/">原题链接</a></p><p>农夫知道一头牛的位置，想要抓住它。</p><p>农夫和牛都位于数轴上，农夫起始位于点 N，牛位于点 K。</p><p>农夫有两种移动方式：</p><ol><li>从 X 移动到 X−1 或 X+1，每次移动花费一分钟</li><li>从 X 移动到 2∗X，每次移动花费一分钟</li></ol><p>假设牛没有意识到农夫的行动，站在原地不动。</p><p>农夫最少要花多少时间才能抓住牛？</p><p><strong>输入格式</strong></p><p>共一行，包含两个整数N和K。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示抓到牛所花费的最少时间。</p><p><strong>数据范围</strong></p><p>0 ≤ N , K ≤ 105</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">17</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>要求从N到K，每次只能进行一个操作：向右一步 &#x2F; 向左一步 &#x2F; 坐标变为现在的两倍，求最短路</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这一题刚开始看第一反应是dp，但后来发现BFS最短路来做也很简单</p><p>每次更新所有该轮操作可以到达的位置</p><p>无需更新负值，因为只能通过-1到达负值，而从负值到正值只能通过+1，二者相互抵消，不可能是最短路</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[n] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t == k) <span class="keyword">return</span> dist[k]; <span class="comment">// 已到终点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新三个距离</span></span><br><span class="line">        <span class="keyword">if</span> (t + <span class="number">1</span> &lt; N &amp;&amp; dist[t + <span class="number">1</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t + <span class="number">1</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t - <span class="number">1</span> &lt; N &amp;&amp; dist[t - <span class="number">1</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t - <span class="number">1</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t * <span class="number">2</span> &lt; N &amp;&amp; dist[t * <span class="number">2</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t * <span class="number">2</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h1><p>设置虚拟源点，到所有源点的距离都为0，也就是在起始时将每一个起点都存进队列</p><h2 id="矩阵距离"><a href="#矩阵距离" class="headerlink" title="矩阵距离"></a>矩阵距离</h2><p><a href="https://www.acwing.com/problem/content/175/">原题链接</a></p><p>给定一个 N 行 M 列的 01 矩阵 A，A[i][j] 与 A[k][l] 之间的曼哈顿距离定义为：</p><p><code>dist(A[i][j], A[k][l]) = |i − k| + |j − l|</code></p><p>输出一个 N 行 M 列的整数矩阵 B，其中：</p><p><code>B[i][j] = min~1≤x≤N,1≤y≤M,A[x][y]=1~ dist(A[i][j], A[x][y])</code></p><p><strong>输入格式</strong></p><p>第一行两个整数 N,M。</p><p>接下来一个 N 行 M 列的 01 矩阵，数字之间没有空格。</p><p><strong>输出格式</strong></p><p>一个 N 行 M 列的矩阵 B，相邻两个整数之间用一个空格隔开。</p><p><strong>数据范围</strong></p><p>1 ≤ N, M ≤ 1000</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">0001</span></span><br><span class="line"><span class="number">0011</span></span><br><span class="line"><span class="number">0110</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个矩阵，求所有0距离最近的1的曼哈顿距离</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>设置虚拟源点，先将所有的1入队，更新所有0到达1的最短距离输出即可</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 所有源点入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            <span class="keyword">if</span> (dist[a][b] != <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 已被遍历</span></span><br><span class="line"></span><br><span class="line">            dist[a][b] = dist[t.ft][t.sd] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            cout &lt;&lt; dist[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双端队列BFS"><a href="#双端队列BFS" class="headerlink" title="双端队列BFS"></a>双端队列BFS</h1><h2 id="电路维修"><a href="#电路维修" class="headerlink" title="电路维修"></a>电路维修</h2><p><a href="https://www.acwing.com/problem/content/177/">原题链接</a></p><p>达达是来自异世界的魔女，她在漫无目的地四处漂流的时候，遇到了善良的少女翰翰，从而被收留在地球上。</p><p>翰翰的家里有一辆飞行车。</p><p>有一天飞行车的电路板突然出现了故障，导致无法启动。</p><p>电路板的整体结构是一个 R 行 C 列的网格（R,C≤500），如下图所示。</p><img src="/posts/922f99a/1.png" class><p>每个格点都是电线的接点，每个格子都包含一个电子元件。</p><p>电子元件的主要部分是一个可旋转的、连接一条对角线上的两个接点的短电缆。</p><p>在旋转之后，它就可以连接另一条对角线的两个接点。</p><p>电路板左上角的接点接入直流电源，右下角的接点接入飞行车的发动装置。</p><p>达达发现因为某些元件的方向不小心发生了改变，电路板可能处于断路的状态。</p><p>她准备通过计算，旋转最少数量的元件，使电源与发动装置通过若干条短缆相连。</p><p>不过，电路的规模实在是太大了，达达并不擅长编程，希望你能够帮她解决这个问题。</p><p>注意：只能走斜向的线段，水平和竖直线段不能走。</p><p><strong>输入格式</strong></p><p>输入文件包含多组测试数据。</p><p>第一行包含一个整数 T，表示测试数据的数目。</p><p>对于每组测试数据，第一行包含正整数 R 和 C，表示电路板的行数和列数。</p><p>之后 R 行，每行 C 个字符，字符是”&#x2F;“和”&quot;中的一个，表示标准件的方向。</p><p><strong>输出格式</strong></p><p>对于每组测试数据，在单独的一行输出一个正整数，表示所需的最小旋转次数。</p><p>如果无论怎样都不能使得电源和发动机之间连通，输出 NO SOLUTION。</p><p><strong>数据范围</strong></p><p>1 ≤ R , C ≤ 500,<br>1 ≤ T ≤ 5</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line">\\/\\</span><br><span class="line">\\<span class="comment">///</span></span><br><span class="line">/\\\\</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>样例解释</strong></p><p>样例的输入对应于题目描述中的情况。</p><p>只需要按照下面的方式旋转标准件，就可以使得电源和发动机之间连通。</p><img src="/posts/922f99a/2.png" class><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>从左上角走到右下角，只能走斜线，使斜线方向改变需要消耗1，问消耗最少的路径</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>首先转换一些题目语言，我们可以理解为，不需要改变斜线方向时边权是0，需要改变斜线方向时边权是1，那这个问题就转换成了边权是0 &#x2F; 1 的最短路问题，用Dijkstra是可以解决的</p><p>那能不能用BFS解决呢？</p><p>当然也可以，考虑到BFS中队列的二段性，本题我们使用双端队列，每次将边权为0的边放到队头，边权为1的边放到队尾（感觉有点贪心的思想）</p><p>（另外，绝对不会出现一条边未转换时走一次，然后转换了再走一次的情况，因为图中总有一半的点是走不到的</p><p>接下来的难点在于图的存储，需要对点和格子分别作出记录</p><h3 id="代码（加了注释）"><a href="#代码（加了注释）" class="headerlink" title="代码（加了注释）"></a>代码（加了注释）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图上的每条边</span></span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// 存每个点到起点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    deque&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cs[] = <span class="string">&quot;\\/\\/&quot;</span>; <span class="comment">// 分别表示往左上角、右上角、右下角、左下角走</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;; <span class="comment">// 进行这些操作点坐标的改变</span></span><br><span class="line">    <span class="type">int</span> ix[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, iy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 进行这些操作需要踩过哪些格子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[t.ft][t.sd]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t.ft][t.sd] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i]; <span class="comment">// 点坐标</span></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt; n || b &lt; <span class="number">0</span> || b &gt; m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> aa = t.ft + ix[i], bb = t.sd + iy[i]; <span class="comment">// 格子坐标</span></span><br><span class="line">            <span class="type">int</span> d = dist[t.ft][t.sd] + (g[aa][bb] != cs[i]); <span class="comment">// 原有距离加上当前格子的边权</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d &lt; dist[a][b]) <span class="comment">// 如果距离更小就更新</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[a][b] = d;</span><br><span class="line">                <span class="comment">// 根据边权情况选择加入队头or队尾</span></span><br><span class="line">                <span class="keyword">if</span> (g[aa][bb] != cs[i]) q.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_front</span>(&#123;a, b&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">&quot;NO SOLUTION\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> BFS </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】最小步数（双向广搜与A*算法）</title>
      <link href="/posts/e9a0dd50.html"/>
      <url>/posts/e9a0dd50.html</url>
      
        <content type="html"><![CDATA[<h1 id="最小步数"><a href="#最小步数" class="headerlink" title="最小步数"></a>最小步数</h1><h2 id="魔板"><a href="#魔板" class="headerlink" title="魔板"></a>魔板</h2><p><a href="https://www.acwing.com/problem/content/1109/">原题链接</a></p><p>Rubik 先生在发明了风靡全球的魔方之后，又发明了它的二维版本——魔板。</p><p>这是一张有 8 个大小相同的格子的魔板：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">8 7 6 5</span><br></pre></td></tr></table></figure><p>我们知道魔板的每一个方格都有一种颜色。</p><p>这 8 种颜色用前 8 个正整数来表示。</p><p>可以用颜色的序列来表示一种魔板状态，规定从魔板的左上角开始，沿顺时针方向依次取出整数，构成一个颜色序列。</p><p>对于上图的魔板状态，我们用序列 (1,2,3,4,5,6,7,8) 来表示，这是基本状态。</p><p>这里提供三种基本操作，分别用大写字母 A，B，C 来表示（可以通过这些操作改变魔板的状态）：</p><p>A：交换上下两行；<br>B：将最右边的一列插入到最左边；<br>C：魔板中央对的4个数作顺时针旋转。</p><p>下面是对基本状态进行操作的示范：</p><p>A：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 7 6 5</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><p>B：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1 2 3</span><br><span class="line">5 8 7 6</span><br></pre></td></tr></table></figure><p>C：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 7 2 4</span><br><span class="line">8 6 3 5</span><br></pre></td></tr></table></figure><p>对于每种可能的状态，这三种基本操作都可以使用。</p><p>你要编程计算用最少的基本操作完成基本状态到特殊状态的转换，输出基本操作序列。</p><p>注意：数据保证一定有解。</p><p><strong>输入格式</strong></p><p>输入仅一行，包括 8 个整数，用空格分开，表示目标状态。</p><p><strong>输出格式</strong></p><p>输出文件的第一行包括一个整数，表示最短操作序列的长度。</p><p>如果操作序列的长度大于0，则在第二行输出字典序最小的操作序列。</p><p><strong>数据范围</strong></p><p>输入数据中的所有数字均为 1 到 8 之间的整数。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line">BCABCCB</span><br></pre></td></tr></table></figure><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个原始状态，问怎么经过最少步骤转换成特殊状态，以及转换步骤是什么</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路比较简单但是代码实现有难度，依然是把原始状态先入队，然后每次更新队头序列可以进行的操作<br>每个操作直接打表更简单</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[<span class="number">10</span>];</span><br><span class="line">string endd;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; dist; <span class="comment">// 存储每一个状态到最终状态的距离</span></span><br><span class="line">map&lt;string, pair&lt;<span class="type">char</span>, string&gt; &gt; pre; <span class="comment">// 存储从后一个状态到前一个状态的具体操作</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">get</span><span class="params">(string t, <span class="type">int</span> op)</span> <span class="comment">// 模拟每个操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string k;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">0</span>) k = &#123;t[<span class="number">4</span>], t[<span class="number">5</span>], t[<span class="number">6</span>], t[<span class="number">7</span>], t[<span class="number">0</span>], t[<span class="number">1</span>], t[<span class="number">2</span>], t[<span class="number">3</span>]&#125;;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) k = &#123;t[<span class="number">3</span>], t[<span class="number">0</span>], t[<span class="number">1</span>], t[<span class="number">2</span>], t[<span class="number">7</span>], t[<span class="number">4</span>], t[<span class="number">5</span>], t[<span class="number">6</span>]&#125;;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">2</span>) k = &#123;t[<span class="number">0</span>], t[<span class="number">5</span>], t[<span class="number">1</span>], t[<span class="number">3</span>], t[<span class="number">4</span>], t[<span class="number">6</span>], t[<span class="number">2</span>], t[<span class="number">7</span>]&#125;;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;12348765&quot;</span>;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t == endd) <span class="keyword">return</span> dist[t];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ ) <span class="comment">// 更新每个操作后的新序列</span></span><br><span class="line">        &#123;</span><br><span class="line">            string s = <span class="built_in">get</span>(t, i);</span><br><span class="line">            <span class="keyword">if</span> (!dist.<span class="built_in">count</span>(s))</span><br><span class="line">            &#123;</span><br><span class="line">                dist[s] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                pre[s] = &#123;<span class="string">&#x27;A&#x27;</span> + i, t&#125;;</span><br><span class="line">                q.<span class="built_in">push</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start = <span class="string">&quot;12348765&quot;</span>, ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">reverse</span>(a + <span class="number">5</span>, a + <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i ++ ) endd.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (endd != start)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += pre[endd].first;</span><br><span class="line">        endd = pre[endd].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双向广搜"><a href="#双向广搜" class="headerlink" title="双向广搜"></a>双向广搜</h1><p>因为BFS越到后面，每一层可以扩展的情况越多（会成指数型增长），为了防止TLE &#x2F; MLE，可以用双向广搜对其进行优化</p><p>从两端开始搜索，到中间相遇，使得搜索次数降低，避免了中间大部分不必要的搜索环节</p><h2 id="字串变换"><a href="#字串变换" class="headerlink" title="字串变换"></a>字串变换</h2><p><a href="https://www.acwing.com/problem/content/192/">原题链接</a></p><p>已知有两个字串 A, B 及一组字串变换的规则（至多 6 个规则）:</p><p>A1→B1<br>A2→B2<br>…</p><p>规则的含义为：在 A 中的子串 A1 可以变换为 B1、A2 可以变换为 B2…。</p><p>例如：A＝abcd B＝xyz</p><p>变换规则为：<br>abc → xu ud → y y → yz</p><p>则此时，A 可以经过一系列的变换变为 B，其变换的过程为：</p><p>abcd → xud → xy → xyz</p><p>共进行了三次变换，使得 A 变换为 B。</p><p>注意，一次变换只能变换一个子串，例如 A＝aa B＝bb</p><p>变换规则为：</p><p>a → b</p><p>此时，不能将两个 a 在一步中全部转换为 b，而应当分两步完成。</p><p><strong>输入格式</strong></p><p>输入格式如下：<br>A B<br>A1 B1<br>A2 B2<br>… …</p><p>第一行是两个给定的字符串 A 和 B。</p><p>接下来若干行，每行描述一组字串变换的规则。</p><p>所有字符串长度的上限为 20。</p><p><strong>输出格式</strong></p><p>若在 10 步（包含 10 步）以内能将 A 变换为 B ，则输出最少的变换步数；否则输出 NO ANSWER!。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">abcd xyz</span><br><span class="line">abc xu</span><br><span class="line">ud y</span><br><span class="line">y yz</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>一个字符串想转变成另一个字符串，现在给出若干个变换规则（某个字串可以转换成另一个字串），问最少的步骤数目是多少</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>从开始和结尾两个字符串同时往中间搜索，搜索过程中相遇就直接输出，具体看代码注释</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string A, B;</span><br><span class="line">string a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(queue&lt;string&gt;&amp; q, unordered_map&lt;string, <span class="type">int</span>&gt;&amp; da, unordered_map&lt;string, <span class="type">int</span>&gt;&amp; db, string a[N], string b[N])</span> <span class="comment">// 要处理da 从a-&gt;b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = da[q.<span class="built_in">front</span>()];</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; da[q.<span class="built_in">front</span>()] == d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 遍历每个规则</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t.<span class="built_in">size</span>(); j ++ ) <span class="comment">// 遍历每个元素作为开头</span></span><br><span class="line">                <span class="keyword">if</span> (t.<span class="built_in">substr</span>(j, a[i].<span class="built_in">size</span>()) == a[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    string r = t.<span class="built_in">substr</span>(<span class="number">0</span>, j) + b[i] + t.<span class="built_in">substr</span>(j + a[i].<span class="built_in">size</span>()); <span class="comment">// 记录新字符串</span></span><br><span class="line">                    <span class="keyword">if</span> (db.<span class="built_in">count</span>(r)) <span class="keyword">return</span> da[t] + db[r] + <span class="number">1</span>; <span class="comment">// 在另一个里找到了，直接输出</span></span><br><span class="line">                    <span class="keyword">if</span> (da.<span class="built_in">count</span>(r)) <span class="keyword">continue</span>; <span class="comment">// 在自己里找到了，说明重复了直接开始下一次循环</span></span><br><span class="line">                    da[r] = da[t] + <span class="number">1</span>; <span class="comment">// 更新距离</span></span><br><span class="line">                    q.<span class="built_in">push</span>(r); <span class="comment">// 新字符串入队</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == B) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    queue&lt;string&gt; qa, qb; <span class="comment">// qa qb两个队列同时搜索</span></span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; da, db; <span class="comment">// 不同字符串到起始字符串的步骤数</span></span><br><span class="line"></span><br><span class="line">    qa.<span class="built_in">push</span>(A), qb.<span class="built_in">push</span>(B); <span class="comment">// 队头入队</span></span><br><span class="line">    da[A] = db[B] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (qa.<span class="built_in">size</span>() &amp;&amp; qb.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="comment">// 每次对队列长的那边进行操作</span></span><br><span class="line">        <span class="keyword">if</span> (qa.<span class="built_in">size</span>() &lt; qb.<span class="built_in">size</span>()) t = <span class="built_in">extend</span>(qa, da, db, a, b);</span><br><span class="line">        <span class="keyword">else</span> t = <span class="built_in">extend</span>(qb, db, da, b, a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t &lt;= <span class="number">10</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">if</span> ( ++ step == <span class="number">10</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a[n] &gt;&gt; b[n]) n ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">-1</span>) cout &lt;&lt; <span class="string">&quot;NO ANSWER!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h1><p>A*与双向广搜解决的问题类似，利用<strong>估价函数</strong>，在非常少的步骤内从一个状态到达另一个状态</p><p>可以解决任何边权的问题，只要没有负权回路</p><p>步骤：</p><ol><li>把BFS中的队列换成优先队列（小根堆），队列中存的是从起点到当前点的真实距离（不一定是最短距离）和从当前点到终点的估计距离（<del>算法的尽头是玄学</del>），优先队列排序的依据是存储的两个距离相加，也就是从起点到终点的估计距离</li><li>取出优先队列队头（也就是估计距离最短的点）</li><li>for循环 t 的所有邻边，能更新的话就更新并将邻边入队</li><li>当终点第一次出队时break</li></ol><p>（和Dijkstra非常像，可以看为Dijkstra中所有从当前点到终点的估计距离都取0（（但本质上没什么关系</p><p><strong>必须要保证当前点到终点的估计距离一定要小于等于真实距离，并且要保证有解（否则效率很低）</strong></p><p>A*只能保证终点距离起点是最优的，不能保证其他点第一次出队时也是最优的，除了终点外，每个点不一定只扩展一次</p><h2 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h2><p><a href="https://www.acwing.com/problem/content/181/">原题链接</a></p><p>在一个 3×3 的网格中，1∼8 这 8 个数字和一个 X 恰好不重不漏地分布在这 3×3 的网格中。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">X 4 6</span><br><span class="line">7 5 8</span><br></pre></td></tr></table></figure><p>在游戏过程中，可以把 X 与其上、下、左、右四个方向之一的数字交换（如果存在）。</p><p>我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 X</span><br></pre></td></tr></table></figure><p>例如，示例中图形就可以通过让 X 先后与右、下、右三个方向的数字交换成功得到正确排列。</p><p>交换过程如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3   1 2 3   1 2 3   1 2 3</span><br><span class="line">X 4 6   4 X 6   4 5 6   4 5 6</span><br><span class="line">7 5 8   7 5 8   7 X 8   7 8 X</span><br></pre></td></tr></table></figure><p>把 X 与上下左右方向数字交换的行动记录为 u、d、l、r。</p><p>现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列。</p><p><strong>输入格式</strong></p><p>输入占一行，将 3×3 的初始网格描绘出来。</p><p>例如，如果初始网格如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">x 4 6 </span><br><span class="line">7 5 8 </span><br></pre></td></tr></table></figure><p>则输入为：<code>1 2 3 x 4 6 7 5 8</code></p><p><strong>输出格式</strong></p><p>输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。</p><p>如果答案不唯一，输出任意一种合法方案即可。</p><p>如果不存在解决方案，则输出 <code>unsolvable</code>。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">5</span>  x  <span class="number">7</span>  <span class="number">6</span>  <span class="number">8</span> </span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ullddrurdllurdruldr</span><br></pre></td></tr></table></figure><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>每次可以修改一个数字上下左右移动，输出一个从给定状态转化到标准状态的最少步骤</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>首先，怎么判断是否有解？</p><p>我们将九宫格中的数字转换成字符串，每次将数字左右移动时，字符串中的逆序对数量不变，上下移动时，逆序对数量总是改变2，所以奇偶性不变<br>我们知道最终要求的状态的逆序对是偶数，所以看初始状态的逆序对数量，是偶数就一定有解，是奇数就一定无解</p><p>然后是最关键的问题：怎么设计估计函数？</p><p>注意到每次移动，最好的情况是将移动的数字向目标位置移动一格，因此估价函数可以取当前的每一个数字和最终目标位置之间的曼哈顿距离之和（这样可以保证估计值一定小于等于真实值）</p><h3 id="代码（＋详细注释）"><a href="#代码（＋详细注释）" class="headerlink" title="代码（＋详细注释）"></a>代码（＋详细注释）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, string&gt; PIS;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(string state)</span> <span class="comment">// 估价函数（曼哈顿距离）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        <span class="keyword">if</span> (state[i] != <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = state[i] - <span class="string">&#x27;1&#x27;</span>; <span class="comment">// 转换成数字</span></span><br><span class="line">            res += <span class="built_in">abs</span>(i / <span class="number">3</span> - t / <span class="number">3</span>) + <span class="built_in">abs</span>(i % <span class="number">3</span> - t % <span class="number">3</span>); <span class="comment">// 计算曼哈顿距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">bfs</span><span class="params">(string start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string end = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">    <span class="type">char</span> op[] = <span class="string">&quot;urdl&quot;</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; dist; <span class="comment">// 记录每个状态距离初始状态的步数</span></span><br><span class="line">    unordered_map&lt;string, pair&lt;<span class="type">char</span>, string&gt; &gt; prev; <span class="comment">// 前一个字符串是由后一个字符串经过什么操作得来的</span></span><br><span class="line">    priority_queue&lt;PIS, vector&lt;PIS&gt;, greater&lt;PIS&gt; &gt; heap; <span class="comment">// 第一个参数是估计距离 第二个参数是当前状态</span></span><br><span class="line"></span><br><span class="line">    dist[start] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="built_in">f</span>(start), start&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>(); <span class="comment">// 取出队头元素</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        string state = t.sd; <span class="comment">// 当前状态</span></span><br><span class="line">        <span class="keyword">if</span> (state == end) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x, y; <span class="comment">// xy表示空位的坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (state[i] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x = i / <span class="number">3</span>, y = i % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        string source = state; <span class="comment">// 记录当前状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) <span class="comment">// 遍历四个操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = x + dx[i], b = y + dy[i]; <span class="comment">// 操作后坐标</span></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= <span class="number">3</span> || b &lt; <span class="number">0</span> || b &gt;= <span class="number">3</span>) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            state = source; <span class="comment">// 将state在每个操作前恢复至初始状态</span></span><br><span class="line">            <span class="built_in">swap</span>(state[x * <span class="number">3</span> + y], state[a * <span class="number">3</span> + b]); <span class="comment">// 修改操作后字符窜</span></span><br><span class="line">            <span class="keyword">if</span> (!dist.<span class="built_in">count</span>(state) || dist[state] &gt; dist[source] + <span class="number">1</span>) <span class="comment">// 没更新过或者有更优解</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[state] = dist[source] + <span class="number">1</span>; <span class="comment">// 更新距离</span></span><br><span class="line">                prev[state] = &#123;op[i], source&#125;; <span class="comment">// 记录操作</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[state] + <span class="built_in">f</span>(state), state&#125;); <span class="comment">// 存进优先队列中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res; <span class="comment">// 记录操作字符串</span></span><br><span class="line">    <span class="keyword">while</span> (end != start)</span><br><span class="line">    &#123;</span><br><span class="line">        res += prev[end].ft;</span><br><span class="line">        end = prev[end].sd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start, seq;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        start += c;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;x&#x27;</span>) seq += c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 逆序对数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; <span class="number">8</span>; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (seq[i] &gt; seq[j]) cnt ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;unsolvable\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">bfs</span>(start) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第K短路"><a href="#第K短路" class="headerlink" title="第K短路"></a>第K短路</h2><p><a href="https://www.acwing.com/problem/content/180/">原题链接</a></p><p>给定一张 N 个点（编号 1,2…N），M 条边的有向图，求从起点 S 到终点 T 的第 K 短路的长度，路径允许重复经过点或边。</p><p>注意： 每条最短路中至少要包含一条边。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 N 和 M。</p><p>接下来 M 行，每行包含三个整数 A,B 和 L，表示点 A 与点 B 之间存在有向边，且边长为 L。</p><p>最后一行包含三个整数 S,T 和 K，分别表示起点 S，终点 T 和第 K 短路。</p><p><strong>输出格式</strong></p><p>输出占一行，包含一个整数，表示第 K 短路的长度，如果第 K 短路不存在，则输出 −1。</p><p><strong>数据范围</strong></p><p>1 ≤ S , T ≤ N ≤ 1000,<br>0 ≤ M ≤ 104,<br>1 ≤ K ≤ 1000,<br>1 ≤ L ≤ 100</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>找到起点到终点第k短的路径</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这一题和之前不同的地方在于，之前只有需要更新距离的时候才将点存进队列，现在不管是否需要更新距离，都要存进队列</p><p>估价函数：从起点到终点的最短路（用Dijkstra求）（这样就可以保证估计距离小于等于真实距离）</p><p>之前求最短路的时候我们认为终点第一次从队列中弹出时是最小值，在这里第k次从队列中弹出时是第k小值（因为每个点最多只能走不超过K次）（可以证明）</p><h3 id="代码（-详细注释）"><a href="#代码（-详细注释）" class="headerlink" title="代码（ + 详细注释）"></a>代码（ + 详细注释）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, PII&gt; PIII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, S, T, K;</span><br><span class="line"><span class="type">int</span> h[N], rh[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap; <span class="comment">// 第二个参数是点 第一个参数是第二个参数到终点的距离</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, T&#125;); <span class="comment">// 终点入队</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[T] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.sd; <span class="comment">// 记录当前遍历的点</span></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = rh[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i]) <span class="comment">// 不是最优解就更新距离并入队</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">astar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt; &gt; heap; <span class="comment">// 第一个参数是估计距离 第二个参数中 ft:到起始点的距离 sd:当前点</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;dist[S], &#123;<span class="number">0</span>, S&#125;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.sd.sd, distance = t.sd.ft; <span class="comment">// distance是到起点的真实距离</span></span><br><span class="line">        cnt[ver] ++ ; <span class="comment">// 第几次遍历该点</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[T] == K) <span class="keyword">return</span> distance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i]) <span class="comment">// 遍历所有邻接点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt[j] &lt; K) <span class="comment">// 没遍历k次以上的就入队</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;distance + w[i] + dist[j], &#123;distance + w[i], j&#125;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(rh, <span class="number">-1</span>, <span class="keyword">sizeof</span> rh);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(h, a, b, c); <span class="comment">// 存正向边</span></span><br><span class="line">        <span class="built_in">add</span>(rh, b, a, c); <span class="comment">// 存反向边（因为dijkstra里需要计算所有点到终点的最短路</span></span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; S &gt;&gt; T &gt;&gt; K;</span><br><span class="line">    <span class="keyword">if</span> (S == T) K ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">astar</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 最小步数 </tag>
            
            <tag> 双向广搜 </tag>
            
            <tag> A* </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】莫队</title>
      <link href="/posts/3dab568c.html"/>
      <url>/posts/3dab568c.html</url>
      
        <content type="html"><![CDATA[<p>这篇博客起源于本人把一道 $pow(2,n)$ 的问题考虑成求组合数前缀和的问题qwq，于是接触到了这个新算法来总结一下</p><p>参考自<a href="https://www.cnblogs.com/WAMonster/p/10118934.html#!comments">这篇文章</a>，写得太好了</p><p>首先是一道<a href="https://www.luogu.com.cn/problem/SP3267">模板题</a></p><p>题目意思是，给出一个数组a，再给出多个区间，问这些区间里分别有多少不一样的数字</p><p>焗个栗子：</p><img src="/posts/3dab568c/1.jpg" class><p>比如给出的是这样一个数组，询问的两个区间是红色和绿色标注的区间</p><p>如果我们分别遍历每一个区间，复杂度就太高了，因此就有大佬提出这样一种算法——</p><p>首先定义双指针 $l$、$r$，初始化为 $l&#x3D;0,r&#x3D;-1$（表示此时区间内没有任何元素），然后用<code>unorderd_map&lt;int, int&gt; map</code>存储当前区间内每个元素的个数</p><p>看我们要求的第一个区间 $[0,5]$</p><p>$l$ 此时等于$0$，和所求区间的左端点相同，因此无需移动</p><p>$r$ 此时等于$-1$，在所求区间右端点的左侧，因此需要向右移</p><p>首先向右移一位变成 $0$，此时区间内添加了一个元素 5,因为<code>map[5] = 0</code>，元素5不存在于原来的区间里，因此元素种类数<code>cnt</code>加一，<code>map[5] ++ </code></p><p>然后 $r$ 再右移一位变成 1，此时区间内添加了一个元素 7,因为<code>map[7] = 0</code>，元素7不存在于原来的区间里，因此元素种类数<code>cnt</code>加一，<code>map[7] ++ </code></p><p>依此类推，直到 $r$ 右移到了 5，此时区间内添加了一个元素 7，但是添加前的<code>map[7] = 1</code>，添加了当前的 7 并不会让区间内元素的个数增多，因此<code>cnt</code>无需改变，<code>map[7] ++</code></p><p>之后从红色区间挪到绿色区间的操作也是类似的</p><p>上文介绍了如何往区间内添加数，当然，删除一个数的操作也是类似的，只不过添加数时，我们要先看被添加的数有没有出现在原来的区间里，也就是<code>map[x]</code>是否等于0，如果等于0说明不存在于原来的区间，区间内元素种类数<code>cnt</code>才能加一，而删除数时，我们要先把当前数删除，也就是<code>map[x]</code>减一，然后再判断当前区间里还有没有x，如果没有x也就是<code>map[x] == 0</code>，那么区间内元素种类数<code>cnt</code>减一</p><p><strong>code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!map[a[pos]]) cnt ++ ; <span class="comment">// 在区间中新出现，总数要+1</span></span><br><span class="line">    map[a[pos]] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map[a[pos]] -- ;</span><br><span class="line">    <span class="keyword">if</span> (!map[a[pos]]) cnt -- ; <span class="comment">// 在区间中不再出现，总数要-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入询问区间的左右端点</span></span><br><span class="line">        <span class="type">int</span> ql, qr;</span><br><span class="line">        cin &gt;&gt; ql &gt;&gt; qr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; ql) <span class="built_in">del</span>(l++); <span class="comment">// 如左指针在查询区间左方，左指针向右移直到与查询区间左端点重合</span></span><br><span class="line">        <span class="keyword">while</span> (l &gt; ql) <span class="built_in">add</span>(--l); <span class="comment">// 如左指针在查询区间左端点右方，左指针左移</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; qr) <span class="built_in">add</span>(++r); <span class="comment">// 右指针在查询区间右端点左方，右指针右移</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; qr) <span class="built_in">del</span>(r--);        <span class="comment">// 否则左移</span></span><br><span class="line">        cout &lt;&lt; cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就 <del>结束啦</del> qwq</p><p>才怪</p><p>还可以对这个算法继续优化</p><p> <strong>莫队算法优化的核心是&#x3D;&#x3D;分块&#x3D;&#x3D;和&#x3D;&#x3D;排序&#x3D;&#x3D;</strong></p><p>把长度为 $n$ 的序列分成 $\sqrt{n}$ 个块，然后按照左端点所在的块排序，如果左端点在同一个块内，则按右端点排序</p><p><strong>优化1</strong><br>这种排序方法也可以接着优化：如果左端点在同一奇数块内，则按右端点从小到大排序，如果左端点在同一偶数块内，则按右端点从大到小排序，这样排序是为了减少右端点移动的次数进而提高效率）</p><p><strong>优化2</strong><br>听说开O2优化能产生奇妙反应，实在没办法了可以考虑考虑这个</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br></pre></td></tr></table></figure><p><strong>优化3</strong><br>某佬把上面的一长串代码简化成了下面这样</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; ql) cnt -= !--map[a[l++]];</span><br><span class="line"><span class="keyword">while</span>(l &gt; ql) cnt += !map[a[--l]]++;</span><br><span class="line"><span class="keyword">while</span>(r &lt; qr) cnt += !map[a[++r]]++;</span><br><span class="line"><span class="keyword">while</span>(r &gt; qr) cnt -= !--map[a[r--]];</span><br></pre></td></tr></table></figure><p>于是模板题的代码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; PPI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="type">int</span> bnum = <span class="built_in">ceil</span>((<span class="type">double</span>)n / size); <span class="comment">// 把序列分成了多少块</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">belong</span><span class="params">(<span class="number">1e6</span> + <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bnum; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = (i - <span class="number">1</span>) * size + <span class="number">1</span>; j &lt;= i * size; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            belong[j] = i; <span class="comment">// 标记每个元素属于哪个块</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;PPI&gt; <span class="title">q</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; q[i].first.first &gt;&gt; q[i].first.second;</span><br><span class="line">        q[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">bool</span>(PPI a, PPI b)&gt; cmp = [&amp;](PPI a, PPI b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// return (belong[a.first.first] ^ belong[b.first.first]) ? belong[a.first.first] &lt; belong[b.first.first] : ((belong[a.first.first] &amp; 1) ? a.first.second &lt; b.first.second : a.first.second &gt; b.first.second);</span></span><br><span class="line">        <span class="keyword">if</span> (belong[a.first.first] != belong[b.first.first]) <span class="keyword">return</span> belong[a.first.first] &lt; belong[b.first.first];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (belong[a.first.first] % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> belong[a.first.second] &lt; belong[b.first.second];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> belong[a.first.second] &gt; belong[b.first.second];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ql = q[i].first.first, qr = q[i].first.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; ql) cnt -= !--map[a[l ++ ]];</span><br><span class="line">        <span class="keyword">while</span>(l &gt; ql) cnt += !map[a[-- l]] ++;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; qr) cnt += !map[a[++ r]] ++;</span><br><span class="line">        <span class="keyword">while</span>(r &gt; qr) cnt -= !--map[a[r -- ]];</span><br><span class="line"></span><br><span class="line">        ans[q[i].second] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的之后更新~~qwq</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】ST表与RMQ算法</title>
      <link href="/posts/7527e30.html"/>
      <url>/posts/7527e30.html</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://zhuanlan.zhihu.com/p/123360481">【朝夕的ACM笔记】数据结构-ST表</a></p><p>在练习线段树的过程中经常会感叹代码怎么这么长啊啊啊懒标记怎么这么难传啊啊啊</p><p>于是在得知有一种代码量远小于线段树的算法时、、、（其实是因为做到了<a href="https://www.luogu.com.cn/problem/P2471">[SCOI2007] 降雨量</a></p><p>就是ST表啦~</p><p>在什么情况下可以用ST表代替线段树呢？</p><p><strong>&#x3D;&#x3D;不需要区间修改&#x3D;&#x3D;的&#x3D;&#x3D;可重复贡献问题&#x3D;&#x3D;</strong></p><p>不需要区间修改很好理解，什么叫做可重复贡献呢？</p><p>我们知道，求一个数组的最大值（比如说长度为10的数组），我们可以先求前六个数的最大值，再求后七个数的最大值，最后求这两个最大值的最大值，虽然这中间有重复的元素，但是对最终的最大值结果不会有影响，这就叫做可重复贡献问题。</p><p>但是如果我们要求一个数组中所有元素的和（还是比如说长度为10的数组），我们就不能用前六个元素的和加上后七个元素的和了，这就叫做不可重复贡献问题。</p><p>常见的可重复贡献问题包括：求<strong>区间最大&#x2F;小值</strong>，<strong>区间按位和&#x2F;或</strong>，<strong>区间gcd</strong>…</p><p><strong>怎么构建ST表呢？</strong></p><p>ST表是一种基于<strong>倍增</strong>算法的数据结构</p><p>我们设<code>f[i][j]</code>表示区间 $[i, i + 2^j - 1]$ 的最大值，因此<code>f[i][0]</code>表示的就是第 i 个元素本身了</p><p>由倍增思想，区间 $[i, i + 2^j - 1]$ 可以被我们拆成两个长度为 $2^{j - 1}$ 的子区间，所以可以的到递推式 $f[i][j]&#x3D;max(f[i][j - 1], f[i + 2^{j-1}][j-1])$，因此先枚举 $j$，再枚举 $i$，就可以得到 $f[i][j]$ 的值了</p><p><strong>怎么查询区间信息呢？–&gt; RMQ算法</strong></p><p>如果我们想知道 $[l, r]$ 的最值，我们可能会输出 $f[l][x]$, $l+2^x-1&#x3D;r$，这样解出x，会发现 $x&#x3D;log_2(r-l+1)$，这样得到的 x 就不一定是个整数了，向下取整的话可能会使区间有所损失</p><p>这时可重复贡献的性质就发挥作用了，我们把要查询的区间 $[l,r]$ 分成长度为 $\lfloor{x}\rfloor$ 两部分，一部分以 l 开头，一部分以 r 结尾，也就是 $[l, l+2^x-1]$ 和 $[r-2^x+1,r]$，只要找到这两个区间的最大值，再取最大值，就可以得到整个区间的最大值了</p><p><strong>时间复杂度</strong></p><p>预处理 $O(nlogn)$<br>查询 $O(1)$</p><p><strong>板子</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">100005</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> logn[<span class="number">100005</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span> <span class="comment">// 预处理log 防止查询时T</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    logn[<span class="number">1</span>] = <span class="number">0</span>, logn[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">        logn[i] = logn[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入数组本身</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; f[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">21</span>; j++) <span class="comment">// 2的21次方满足两百万数据 数据变大上限也要变大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i ++ )</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]); <span class="comment">// 这里根据所求内容不同需要做相应修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RMQ查询</span></span><br><span class="line">        <span class="type">int</span> lg = logn[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(f[l][lg], f[r - (<span class="number">1</span> &lt;&lt; lg) + <span class="number">1</span>][lg]);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> ST表 </tag>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】线段树</title>
      <link href="/posts/63fc9272.html"/>
      <url>/posts/63fc9272.html</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&#x3D;&#x3D;<strong>时间复杂度：O(logn)</strong>&#x3D;&#x3D;</p><p>线段树是一棵二叉树，把一段区间分成多个部分</p><img src="/posts/63fc9272/1.png" class title="This is an test image"><p>类似堆的方式，用一维数组存整棵树</p><p>对于编号x的结点：</p><ul><li>父结点 $\lfloor x \rfloor$，表示为 <code>x &gt;&gt; 1</code></li><li>左子树 $2x$，表示为 <code>x &lt;&lt; 1</code></li><li>右子树 $2x+1$，表示为 <code>x &lt;&lt; 1 | 1</code></li></ul><p>对于长度为n的区间，最坏估计有 $4n-1$ 个结点，因此 &#x3D;&#x3D;<strong>开数组时空间一般开 $4n$</strong>&#x3D;&#x3D;</p><h1 id="pushup"><a href="#pushup" class="headerlink" title="pushup"></a>pushup</h1><p><strong>由子结点计算父结点的信息</strong></p><p>模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u表示当前树中结点编号 lr表示树中结点左右子结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 此处用[l]和[r]的值更新[u] */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="build"><a href="#build" class="headerlink" title="build"></a>build</h1><p><strong>将一段区间初始化为线段树</strong></p><ol><li>首先记录下当前区间的左右端点，如果左端点和右端点相等就直接返回</li><li>如果不相等，取中间值 <code>mid</code>，然后分别递归左右两段</li></ol><p>模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u表示当前树中结点编号 lr表示区间左右端点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="comment">// 左右端点相同表示到达叶子结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;    &#125;; <span class="comment">// 创建该结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r); <span class="comment">// 分别构造左右两棵子树</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 利用pushup更新该点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="modify"><a href="#modify" class="headerlink" title="modify"></a>modify</h1><p><strong>修改单点或区间（需要用到push_down操作）</strong></p><p><strong>修改单点</strong>模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u为当前树中结点编号 要把x位置的值更新为v</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x) <span class="comment">// 到达叶子结点 直接更新</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;     &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v); <span class="comment">// 要更新的位置在左半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v); <span class="comment">// 要更新的位置在右半部分</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 更新此位置结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改区间</strong>模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="comment">// 当前树中结点在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (i64)(tr[u].r - tr[u].l + <span class="number">1</span>) * d; <span class="comment">// 更新区间信息</span></span><br><span class="line">        tr[u].add += d; <span class="comment">// 打上懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 当前树中结点不在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u); <span class="comment">// 将懒标记向下传递</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 由于modify修改了区间结点的信息，所以被修改的结点的祖先结点都需要重算一遍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="query"><a href="#query" class="headerlink" title="query"></a>query</h1><p><strong>查询区间信息</strong></p><p>假设我们要查询某区间的最大值</p><p>定义 <code>[l, r]</code> 为我们要查询的区间，<code>[Tl, Tr]</code> 为树中结点（当前我们正在维护的区间），这两个区间会有如下两种关系：</p><ul><li>$[Tl, Tr]\subset[l, r]$，树中结点完全包含在要查询的区间内部<br>这种情况直接返回当前区间最大值即可</li><li>$[l, r]\bigcap[Tl, Tr]\not&#x3D;\emptyset$，二者有交集<br>和左边有交集就递归到左边做一遍，和右边有交集就递归到右边做一遍<br>即<code>l &gt; mid</code>只递归右边，<code>r &lt;= mid</code>只递归左边，否则左右都递归</li></ul><p>模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u]; <span class="comment">// 当前区间在被查询区间之内 直接返回</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r); <span class="comment">// 被查询区间在当前区间左半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r); <span class="comment">// 被查询区间在当前区间右半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 被查询区间横跨当前区间的左右两部分</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r); <span class="comment">// 计算出左半部分值</span></span><br><span class="line">            <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r); <span class="comment">// 计算出右半部分值</span></span><br><span class="line">            Node res;</span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right); <span class="comment">// 更新结果</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="pushdown（懒标记-延迟标记）"><a href="#pushdown（懒标记-延迟标记）" class="headerlink" title="pushdown（懒标记 &#x2F; 延迟标记）"></a>pushdown（懒标记 &#x2F; 延迟标记）</h1><p><strong>将父结点的修改更新到子结点</strong></p><p>单点修改可以只用pushup，涉及到区间修改就需要使用pushdown</p><p><strong>懒标记</strong> ：在当前树中结点上打上懒标记，就表示对<strong>以当前树中结点为根结点</strong>的<strong>每一个子树</strong>都进行操作（根结点自己不用操作）</p><p>那么懒标记怎么进行传递呢？</p><p>焗个栗子：比如我们在蓝色的这一段区间上打上懒标记</p><p>每当我们需要遍历蓝色区间结点下方的子结点时，我们就把懒标记传递给下一层结点，同时把根结点的懒标记删除，就像这样：</p><p>当然，除了传递标记，我们还需要对线段树中记录的值进行更新，比如说这个线段树记录的是区间和，打上懒标记表示这一段区间每一个数都要加上<code>a</code>，那么我们在传递懒标记的同时，还需要让下方结点的区间和加上<code>(r - l + 1) * a</code>，其中<code>(l - r + 1)</code>表示下方被更新结点的区间长度</p><p>以此类推，每当我们需要遍历下方结点时，就把懒标记向下传，并更新下方结点的值</p><p>以上就是pushdown操作的基本内容</p><p>模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (root.add) <span class="comment">// 当前结点有懒标记 向下传递</span></span><br><span class="line">    &#123;</span><br><span class="line">        left.add += root.add, left.sum += (i64)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (i64)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题：一个简单的整数问题2"><a href="#例题：一个简单的整数问题2" class="headerlink" title="例题：一个简单的整数问题2"></a>例题：一个简单的整数问题2</h1><p><a href="https://www.acwing.com/problem/content/244/">原题链接</a></p><p>给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p><p><code>C l r d</code>，表示把 A[l],A[l+1],…,A[r] 都加上 d。<br><code>Q l r</code>，表示询问数列中第 l∼r 个数的和。<br>对于每个询问，输出一个整数表示答案。</p><p><strong>输入格式</strong></p><p>第一行两个整数 N,M。</p><p>第二行 N 个整数 A[i]。</p><p>接下来 M 行表示 M 条指令，每条指令的格式如题目描述所示。</p><p><strong>输出格式</strong></p><p>对于每个询问，输出一个整数表示答案。</p><p>每个答案占一行。</p><p><strong>数据范围</strong></p><p>$1≤N,M≤105,$<br>$|d|≤10000,$<br>$|A[i]|≤109$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">Q <span class="number">4</span> <span class="number">4</span></span><br><span class="line">Q <span class="number">1</span> <span class="number">10</span></span><br><span class="line">Q <span class="number">2</span> <span class="number">4</span></span><br><span class="line">C <span class="number">3</span> <span class="number">6</span> <span class="number">3</span></span><br><span class="line">Q <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><p><strong>code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    i64 sum, add; <span class="comment">// 区间和和懒标记</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (root.add) <span class="comment">// 当前结点有懒标记 向下传递</span></span><br><span class="line">    &#123;</span><br><span class="line">        left.add += root.add, left.sum += (i64)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (i64)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="comment">// 当前树中结点在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (i64)(tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[u].add += d; <span class="comment">// 打上懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 当前树中结点不在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u); <span class="comment">// 将懒标记向下传递</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 由于modify修改了区间结点的信息，所以被修改的结点的祖先结点都需要重算一遍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u); <span class="comment">// 为了让查询到的最小结点都已计算过祖先结点的懒标记</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    i64 sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> l, r, d;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; d;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扫描线法"><a href="#扫描线法" class="headerlink" title="扫描线法"></a>扫描线法</h1><p>放一道例题</p><h2 id="亚特兰蒂斯"><a href="#亚特兰蒂斯" class="headerlink" title="亚特兰蒂斯"></a>亚特兰蒂斯</h2><p><a href="https://www.acwing.com/problem/content/249/">原题链接</a></p><p>有几个古希腊书籍中包含了对传说中的亚特兰蒂斯岛的描述。</p><p>其中一些甚至包括岛屿部分地图。</p><p>但不幸的是，这些地图描述了亚特兰蒂斯的不同区域。</p><p>您的朋友 Bill 必须知道地图的总面积。</p><p>你自告奋勇写了一个计算这个总面积的程序。</p><p><strong>输入格式</strong></p><p>输入包含多组测试用例。</p><p>对于每组测试用例，第一行包含整数 n，表示总的地图数量。</p><p>接下来 n 行，描绘了每张地图，每行包含四个数字 x1,y1,x2,y2（不一定是整数），(x1,y1) 和 (x2,y2) 分别是地图的左上角位置和右下角位置。</p><p>注意，坐标轴 x 轴从上向下延伸，y 轴从左向右延伸。</p><p>当输入用例 n&#x3D;0 时，表示输入终止，该用例无需处理。</p><p><strong>输出格式</strong></p><p>每组测试用例输出两行。</p><p>第一行输出 Test case #k，其中 k 是测试用例的编号，从 1 开始。</p><p>第二行输出 Total explored area: a，其中 a 是总地图面积（即此测试用例中所有矩形的面积并，注意如果一片区域被多个地图包含，则在计算总面积时只计算一次），精确到小数点后两位数。</p><p>在每个测试用例后输出一个空行。</p><p><strong>数据范围</strong></p><p>$1≤n≤10000,$<br>$0≤x1&lt;x2≤100000,$<br>$0≤y1&lt;y2≤100000$</p><p>注意，本题 n 的范围上限加强至 10000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span> <span class="number">20</span> <span class="number">20</span></span><br><span class="line"><span class="number">15</span> <span class="number">15</span> <span class="number">25</span> <span class="number">25.5</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Test <span class="keyword">case</span> #<span class="number">1</span></span><br><span class="line">Total explored area: <span class="number">180.00</span> </span><br></pre></td></tr></table></figure><p><strong>code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x, y1, y2;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Segment &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">double</span> len;</span><br><span class="line">&#125;tr[N * <span class="number">8</span>]; <span class="comment">// 线段树</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; ys; <span class="comment">// 存储纵坐标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), y) - ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].cnt) tr[u].len = ys[tr[u].r + <span class="number">1</span>] - ys[tr[u].l]; <span class="comment">// 这一段被完全覆盖 所以直接算长度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[u].l != tr[u].r) <span class="comment">// 没有被完全覆盖 分成左右两段分别来看</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = <span class="number">0</span>; <span class="comment">// 叶子结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l != r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// cnt和len都是0所以不需要pushdown</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="comment">// 完全覆盖</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].cnt += k;</span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 更新该节点的len</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        ys.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> x1, x2, y1, y2;</span><br><span class="line">            cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            <span class="comment">// 把所有竖着的线段存进segment</span></span><br><span class="line">            seg[j ++ ] = &#123;x1, y1, y2, <span class="number">1</span>&#125;;</span><br><span class="line">            seg[j ++ ] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">            ys.<span class="built_in">push_back</span>(y1), ys.<span class="built_in">push_back</span>(y2); <span class="comment">// 把所有纵坐标存进ys</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 纵坐标去重</span></span><br><span class="line">        <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>());</span><br><span class="line">        ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>()), ys.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, ys.<span class="built_in">size</span>() - <span class="number">2</span>); <span class="comment">// 纵坐标点的数量到ys-1 线段数量就是ys-2</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(seg, seg + n * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i) res += tr[<span class="number">1</span>].len * (seg[i].x - seg[i - <span class="number">1</span>].x);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test case #&quot;</span> &lt;&lt; T &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        T ++ ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】树状数组</title>
      <link href="/posts/b289bb13.html"/>
      <url>/posts/b289bb13.html</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/574739597">https://zhuanlan.zhihu.com/p/574739597</a></p><p>树状数组主要是支持两种操作：</p><ul><li><strong>单点修改</strong></li><li><strong>区间查询</strong></li></ul><p>这两个操作的时间复杂度都是 <em>O(logn)</em><br>根据前缀和的原理，任意一段区间求和都可以转换成两个前缀和的差，因此区间求和问题转换成求前缀和问题</p><h1 id="前提准备：计算-lowbit"><a href="#前提准备：计算-lowbit" class="headerlink" title="前提准备：计算 lowbit"></a>前提准备：计算 lowbit</h1><p>在此我们定义一个 <code>lowbit(x)</code> ，表示 x 的最末尾一个 1 与这个 1 后面的所有 0 组成的二进制数<br><code>lowbit(x)</code> 应该怎么实现呢？<br>很简单，这里直接给出结论 <code>lowbit(x) = x &amp; -x</code><br>还是通过例子来说明</p><blockquote><p>现有二进制数 101100<br>x &#x3D; 101100<br>反码：010011<br>补码：010100</p></blockquote><p>可以注意到，-x 是 x 末尾的一个 1 到结束的 0 不动，前面全部取反的结果<br>那么 <code>x &amp; -x</code> 就只保留了末尾的 1 和后面的 0<br>因此得到我们的 lowbit 函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树状数组的含义"><a href="#树状数组的含义" class="headerlink" title="树状数组的含义"></a>树状数组的含义</h1><p>我们定义原数组为<code>a</code>，用一个数组 <code>tree</code> 维护若干个小区间，<code>tree[i]</code> 表示<strong>以<code>a[i]</code>为结尾、长度为<code>lowbit(i)</code>的区间的和，也就是<code>(i-lowbit(i), i]</code>（左开右闭）这一区间的和</strong>（这一点很重要，请务必记住）<br>举个栗子吧</p><blockquote><p>i &#x3D; 5 &#x3D; 101<del>(2)</del><br>lowbit(i) &#x3D; lowbit(101) &#x3D; 001<del>(2)</del> &#x3D; 1         i - lowbit(i) &#x3D; 100<del>(2)</del> &#x3D; 4<br>i &#x3D; i - lowbit(i) &#x3D; 4 &#x3D; 100<del>(2)</del><br>lowbit(i) &#x3D; lowbit(100) &#x3D; 100<del>(2)</del>         i - lowbit(i) &#x3D; 0<br>因此 lowbit(5) 就等于以 a[5] 结尾，长度为 lowbit(5) &#x3D; 1 的区间的和，也就是等于 a[5]</p></blockquote><ul><li>单点修改时，只更新<strong>包含这一元素的区间</strong></li><li>求前 n 项和时，通过将区间进行<strong>组合</strong>，得到从 1 到 n 的区间，然后对所有用到的区间求和。<br>将 n 转换为二进制，任意一个数都可以看作是几个二进制数表示区间的和<br>举个栗子<blockquote><p>11<del>(10)</del> &#x3D; 1011<del>(2)</del><br>求前 11 项的和，可以转换成求 1010 - 1011、1000 - 1010、0000 - 1000 这几个区间的和</p></blockquote></li></ul><p>这个步骤就是在不断地删去最末尾的一个 1<br>而我们刚刚在前提准备里提到，lowbit 运算，就是不断删去末尾的 1 的过程</p><p>因此单点修改时，我们只需要从<code>tree[1]</code>开始，每次将<code>i</code> 更新成<code>i + lowbit(i)</code>，修改当前的<code>tree[i]</code>，直到<code>i</code>被更新为 N<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= N)</span><br><span class="line">&#123;</span><br><span class="line">tree[i] += x;</span><br><span class="line">i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求 <code>a[i]</code> 的前缀和时，可以利用循环来求解，每次将 <code>i</code> 更新为 <code>i - lowbit(i)</code>，加上修改后的 <code>i</code> 的 <code>tree[i]</code> 即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefix_sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">presum += tree[i];</span><br><span class="line">i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> presum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，区间求和的代码也显而易见了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">prefix_sum</span>(r) - <span class="built_in">prefix_sum</span>(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓展应用"><a href="#拓展应用" class="headerlink" title="拓展应用"></a>拓展应用</h1><h2 id="拓展一：区间修改、单点查询"><a href="#拓展一：区间修改、单点查询" class="headerlink" title="拓展一：区间修改、单点查询"></a>拓展一：区间修改、单点查询</h2><p>区间修改，我们需要给区间内的每个数加上同一个给定值 x，很容易想到利用差分来降低复杂度，记原数组为<code>a[i]</code>，差分数组为<code>b[i]</code>，<code>b[i] = a[i] - a[i - 1]</code><br>在<code>b[i]</code>上建立树状数组<code>tree[i]</code>，每次对<code>a</code>中<code>[l, r]</code>区间上的修改，就相当于<code>b[l] += x</code>和<code>b[r + 1] -= x</code>，这样我们也可以对<code>tree[i]</code>做出相应的两次单点修改，于是区间修改也被我们转换成单点修改得到解决了</p><p>单点查询，根据差分数组的性质，<code>a[i] = b[1] + b[2] + … + b[i]</code>，即可将单点查询转换成求<code>b</code>的前缀和，进而利用树状数组进行计算</p><h2 id="拓展二：区间查询、区间修改"><a href="#拓展二：区间查询、区间修改" class="headerlink" title="拓展二：区间查询、区间修改"></a>拓展二：区间查询、区间修改</h2><p>计算<code>a[i]</code>时，需要计算<code>b[i]</code>的前缀和<br>所以计算<code>a[i]</code>的前缀和时，我们就需要计算<code>b[i]</code>的前缀和的前缀和<br>用数学公式表达如下：（计算<code>a[p]</code>的前缀和）</p><p>$\sum_{i &#x3D; 1}^{p} a[i] &#x3D; \sum_{i &#x3D; 1}^{p}(\sum_{j &#x3D; 1}^{i} b[j])$</p><p>等号右侧中，<code>b[1]</code>出现了 p 次，<code>b[2]</code>出现了 p - 1 次，<code>b[j]</code>出现了 p + 1 - j 次。因此可知：</p><p>$\sum_{i &#x3D; 1}^{p} a[i] &#x3D; (p + 1)\sum_{j &#x3D; i  -1}^{p}b[j] - \sum_{j &#x3D; 1}^{p}b[j] * j$</p><p>可以理解为：我们先把每个<code>b[j]</code>都算作出现了<code>p + 1</code>次，然后再把多算的 <code>j</code> 次减去。</p><p>因此——</p><ul><li><code>b[i] = a[i] - a[i - 1]</code></li><li><code>c[i] = b[i] * i</code></li></ul><p>对于<code>b[i]</code>和<code>c[i]</code>都建立树状数组，这样就可以很容易求出<code>b[i]</code>和<code>c[i]</code>的前缀和，也就得到了<code>a[i]</code>的前缀和，区间查询完成</p><p>对于区间修改，我们将<code>a</code>的<code>[l, r]</code>每个元素加上 x，<code>b</code>的变化方式为<code>b[l] += x</code>和<code>b[r + 1] -= x</code>，相应的，<code>c</code>的变化方式为<code>c[l] += x * l ，c[r + 1] -= x * (r + 1)</code>，也就是对 b 和 c 进行两次单点修改，这个步骤已经在上面写过就不重复了</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】并查集</title>
      <link href="/posts/2e7813af.html"/>
      <url>/posts/2e7813af.html</url>
      
        <content type="html"><![CDATA[<p>今天补题遇到了这个知识点，能想到这个方法但是自己没办法实现，所以来复习一下相关知识做个总结~</p><p>并查集，简单来说，就是合并两个集合，然后能迅速判断两个元素是否在同一集合中<br><strong>板子</strong><br>返回 x 的祖先结点，同时进行路径压缩，让 p[x] 直接指向祖先结点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现方法：</strong><br>首先所有元素各为一个集合，创建数组 p[i]，意为 i 的父结点，起初，p[i] 全部等于 i </p><ul><li>当两个元素 a b 进行合并时（实际上就是两个集合进行合并），让 a 的祖先结点的父结点等于 b 的祖先结点，a 的祖先结点直接指向 b 的祖先结点<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure></li><li>当询问两个元素 a b 是否在同一个集合中时，只需要看 a b 的祖先结点是不是同一个，也就是判断 find(a) &#x3D;&#x3D; find(b) 是否成立</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】位运算</title>
      <link href="/posts/4befabc3.html"/>
      <url>/posts/4befabc3.html</url>
      
        <content type="html"><![CDATA[<p>因为对位运算实在是太太太太太不熟悉了！所以每次遇到位运算相关的题都要卡好久才能把题目意思转化成容易理解的样子，今晚又被卡了所以一怒之下总结一篇等下次被卡就来翻翻qwq</p><h1 id="与"><a href="#与" class="headerlink" title="与 &amp;"></a>与 &amp;</h1><p>翻译：同为1取1，只要有0就取0</p><ul><li>可以用&amp;来取每一位上的数，如果要判断n的第三位是否为1，就进行 $n$ &amp; $2^{3-1}$ 运算，如果结果为 $2^{3-1}$ ，就说明当前判断的位数上是1，结果是0，就说明当前判断的位数上是0</li><li><strong>判断奇偶</strong><br><code>a &amp; 1 == 1</code> a为奇数<br><code>a &amp; 1 == 0</code> a为偶数</li></ul><h1 id="或-（OR）"><a href="#或-（OR）" class="headerlink" title="或 | （OR）"></a>或 | （OR）</h1><p>翻译：有1取1，无1取0</p><ul><li>一个数对另一个数进行 | 操作，当前位上是0将不产生任何影响，<strong>当前位上是1将会把对应位上变成1</strong></li><li><strong>把一个数变成最接近的偶数</strong>：<code>a = a | 1 - 1</code></li></ul><h1 id="异或-（XOR）"><a href="#异或-（XOR）" class="headerlink" title="异或 ^ （XOR）"></a>异或 ^ （XOR）</h1><p>翻译：相同为0，不同为1</p><ul><li>一个数和本身进行异或运算得到结果为0</li><li>一个数和0进行异或运算得到结果为本身</li><li>上两条推出：<strong>奇数个相同的数异或运算得到结果为本身，偶数个相同的数异或运算得到结果为0</strong></li></ul><h1 id="左移"><a href="#左移" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h1><p>翻译：<code>a &lt;&lt; b = a x 2^b</code></p><h1 id="右移"><a href="#右移" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h1><p>翻译：<code>a &gt;&gt; b = a / 2^b</code></p><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>按位反（~）&gt; 位移运算（&lt;&lt;,&gt;&gt;）&gt; 按位与（&amp;）&gt; 按位异或（^）&gt; 按位或（|）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> C++ </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基础算法】逆序对</title>
      <link href="/posts/5ccba1a0.html"/>
      <url>/posts/5ccba1a0.html</url>
      
        <content type="html"><![CDATA[<p><strong>逆序对</strong>，简单来说，就是<code>i &gt; j</code>*，但<code>a[i] &lt; a[j]</code>，那么<code>a[i] 和 a[j]</code>就是一组逆序对</p><p>求逆序对有三种方式——</p><ul><li>暴力 复杂度 O(n^2^) 谁用谁T 不多赘述了</li><li>归并排序 复杂度 O(nlogn)</li><li>树状数组 复杂度 O(nlogn)</li></ul><p><strong>归并排序</strong></p><p>首先看一下归并排序的原理，就是将一个序列无限二分，直到每一部分都只有一个元素，这时每一部分都有序，然后逐次合并相邻部分，让合并后的各个部分有序<br>举个栗子<br>现在我们要合并两个部分：1 3 5 7 9 | 2 4 6 8 10<br>先比较 1、2，发现 1 &lt; 2，所以把 1 先放到合并后的数组里<br>现在剩下的两部分是：3 5 7 9 | 2 4 6 8 10<br>现在比较3、2，发现 3 &gt; 2，所以把 2 放到合并后的数组，由于左半部分是有序的，所以 2 小于左半部分剩下的所有数，但 2 又在左半边剩下的所有数后面，所以 2 和这些数都构成逆序对，逆序对的数量就是<code>mid - i</code><br>每一次右半部分的第一个数小于左半部分的第一个数时，右半部分的第一个数和左半部分剩下的所有数都构成逆序对，因此在原来的基础上加上<code>mid - i</code>即可</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> a[N], temp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_pai</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = l, j = mid, p = l;</span><br><span class="line"><span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; a[j]) temp[p ++ ] = a[i ++ ];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp[p ++ ] = a[j ++ ];</span><br><span class="line">ans += mid - i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; mid) temp[p ++ ] = a[i ++ ];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r) temp[p ++ ] = a[j ++ ];</span><br><span class="line">p = l;</span><br><span class="line"><span class="keyword">while</span> (p &lt; mid) a[p ++ ] = temp[p ++ ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(l, mid);</span><br><span class="line"><span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">merge_pai</span>(l, r, mid + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">merge_sort</span>(<span class="number">1</span>, n);</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>树状数组</strong></p><p>树状数组的原理在这里就不多说啦，如果有不懂的同学可以去看看<a href="https://blog.csdn.net/dhxbshbdjzxy/article/details/131718607?spm=1001.2014.3001.5502">这篇</a></p><p>建立一个数组<code>c[i]</code>，表示元素 i 出现的次数，起初每一项都为0<br>同时我们也可以得到<code>c[i]</code>的树状数组<code>tree[i]</code><br>每次插入一个数 x ，我们都将利用树状数组单点修改的性质更新<code>tree[i]</code>的值，此时区间查询<code>c[i - 1]</code>的前缀和，我们就可以得到在 x 前输出，比 x 的值小的元素个数，用总共输入的元素个数和它相减，就可以得到<strong>在 x 前输出，且比 x 大的元素个数</strong>，这也就是逆序对的个数了<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= N)</span><br><span class="line">&#123;</span><br><span class="line">tree[i] += x;</span><br><span class="line">i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefix_sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">presum += tree[i];</span><br><span class="line">i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> presum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> a[n + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">add</span>(a[i], <span class="number">1</span>);</span><br><span class="line">ans += (i - <span class="built_in">prefix_sum</span>(a[i]));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> 逆序对 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基础算法】前缀和与差分</title>
      <link href="/posts/470a5ef6.html"/>
      <url>/posts/470a5ef6.html</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><p>一维数组中，计算出所有前 n 个数的和，存储在一个单独的数组里，便于后续计算</p><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>s[i] 计算的就是前 i 个数的和<br>当我们需要计算第 l 个数到第 r 个数的和时，只需要用 s[r] - s[l - 1] 即可</p><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><p>二维数组中，计算出长为 0 - l， 宽为 0 - r 的矩阵和<br>这个值等于长为 0 - (l - 1) 宽为 0 - r 的矩阵加上 长为 0 - l 宽为 0 - (r - 1) 的矩阵减去 长为 0 - (l - 1) 宽为 0 - (r - 1)的矩阵 最后加上该位置的值</p><h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要计算左上角坐标为 (x1, y1)， 右下角坐标为 (x2, y2) 的矩阵时，只需要用 s[x2][y2] - s[x1 - 1][y1] - s[x1][y1 - 1] + s[x1 - 1][y1 - 1] 即可</p><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>差分与前缀和是逆运算，数组 a 是数组 b 的前缀和，数组 b 就是数组 a 的差分<br>即<br>a[i] &#x3D; b[0] + b[1] + … + b[i]<br>b[i] &#x3D; a[i] - a[i - 1]</p><h2 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h2><p>在一维数组中，将从 l 到 r 的每一个数都加上给定值 c<br>因为在给定区间内的每一个数都加了 c ，所以它们之间的差值不变，只有第 l - 1 与第 i 个数、第 r 与第 r + 1 个数的差值发生了改变，因此修改差分数组时只需要修改两个值，极大提高计算速度<br>适用于需要多次修改数组的情况</p><h3 id="板子-2"><a href="#板子-2" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">insert</span>(i, i, a[i]); <span class="comment">// 差分数组的建立</span></span><br><span class="line"><span class="type">int</span> l, r, c;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="built_in">insert</span>(l, r, c); <span class="comment">// 差分数组的修改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) b[i] += b[i - <span class="number">1</span>]; <span class="comment">// 将差分数组恢复成原数组</span></span><br></pre></td></tr></table></figure><h2 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h2><p>二维数组中，将长为 0 - l， 宽为 0 - r 的矩阵中每一个元素都加上一个给定值 c<br>对于差分矩阵，需要进行如下操作：</p><ul><li>b[x1][y1] +&#x3D; c</li><li>b[x2 + 1][y2 + 1] +&#x3D; c</li><li>b[x2 + 1][y1] -&#x3D; c</li><li>b[x1][y2 + 1] -&#x3D; c</li></ul><h3 id="板子-3"><a href="#板子-3" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        cin &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        <span class="built_in">insert</span>(i, j, i, j, a[i][j]); <span class="comment">// 构造差分数组</span></span><br><span class="line"><span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line"><span class="built_in">insert</span>(x1, y1, x2, y2, c); <span class="comment">// 修改差分数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 恢复原数组</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基础算法】高精度</title>
      <link href="/posts/40a4a6dc.html"/>
      <url>/posts/40a4a6dc.html</url>
      
        <content type="html"><![CDATA[<p>当比赛中给定数字位数过多，无法直接进行加减乘除运算时，使用高精度计算</p><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p>高精度加法相当于一个列竖式计算的过程，从最低位开始（因此所有数都要倒着存），遇十进位</p><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">//记录进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i ++ ) <span class="comment">// 就是一个竖式计算的过程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="comment">// 将a、b倒着存进去，便于从低位开始进行运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B); <span class="comment">// C 也是倒着存储的 所以下面倒着输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><p>高精度减法也是相当于一个列竖式计算的过程，用大数减小数，从最低位开始（因此所有数都要倒着存），不够减就借位</p><h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较AB大小 用大数减小数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 位数不等，位数多的大</span></span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 位数相等，从高位开始判断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- )</span><br><span class="line">    <span class="keyword">if</span> (A[i] != B[i]) <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 存储计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t; <span class="comment">// 先处理借位情况</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i]; <span class="comment">// B还没减完时</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>); <span class="comment">// 防止t小于0</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>; <span class="comment">// 说明不够减要借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>; <span class="comment">// 无需借位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 除去前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先判断AB大小，确保大数减小数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B, A);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><p>高精度乘法要求其中的一个数是 int 类型，同样是列竖式计算的过程</p><h3 id="板子-2"><a href="#板子-2" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 存储计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 低位开始，每次取结果的个位存进C中</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 删去前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><p>同样是竖式计算的过程，要求除数是 int 类型</p><h3 id="板子-3"><a href="#板子-3" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>; <span class="comment">// 记录余数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i]; <span class="comment">// 余数乘10加新一位</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b; <span class="comment">// 更新余数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>()); <span class="comment">// 翻转C便于删去前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> r; <span class="comment">// 余数</span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基础算法】二分</title>
      <link href="/posts/91181467.html"/>
      <url>/posts/91181467.html</url>
      
        <content type="html"><![CDATA[<p>二分适用于满足二段性的序列，当一个序列中一段满足条件，另一段不满足条件时可以考虑使用二分来加快查找速度</p><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x 是需要查找的数</span></span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q[mid] &gt;= x) r = mid; <span class="comment">// 符号按需要更改</span></span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure><h2 id="符号判断"><a href="#符号判断" class="headerlink" title="符号判断"></a>符号判断</h2><p>二分中使用什么符号曾经困扰了我很久，现总结如下：<br>大原则：<strong>搞不清就带等号</strong>，带等号的时候和字面理解意思相同<br>其中，以下两个式子表示含义相同：</p><ul><li><strong>&gt;&#x3D;</strong> 会输出满足大于等于条件的第一个数</li><li><strong>&lt;</strong> 会输出从后往前看不满足小于条件的第一个数</li></ul><p>以下两个式子表示含义相同：</p><ul><li><strong>&lt;&#x3D;</strong> 会输出从后往前看满足小于等于条件的第一个数</li><li><strong>&gt;</strong>  会输出不满足条件的最后一个数</li></ul><p>举个栗子</p><blockquote><p>现有如下序列：1 2 3 4 5 5 5 6 7 8 9</p></blockquote><p>现需查找 “5” ——</p><ul><li>当使用 <strong>&gt;&#x3D;</strong> 时，找到的是第 1 个 5</li><li>当使用 <strong>&lt;&#x3D;</strong> 时，找到的是第 3 个 5</li><li>当使用 <strong>&gt;</strong> 时，找到的是第 1 个 5</li><li>当使用 <strong>&lt;</strong> 时，找到的是第 3 个 5</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在前面的话</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 Texcavator 的 Blog！</p><p>这里将记录下我学习过程中的笔记和心得</p><p>没想好这里还要写什么，之后再来补充啦~</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
