<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【搜索】双向DFS</title>
      <link href="/posts/c90ca664.html"/>
      <url>/posts/c90ca664.html</url>
      
        <content type="html"><![CDATA[<p>双向BFS和前面的双向DFS思路基本一样，都是为了从两端搜索从而避免搜索中间一大块复杂的情况</p><h1 id="送礼物"><a href="#送礼物" class="headerlink" title="送礼物"></a>送礼物</h1><p><a href="https://www.acwing.com/problem/content/173/">原题链接</a></p><p>达达帮翰翰给女生送礼物，翰翰一共准备了 $N$ 个礼物，其中第 i 个礼物的重量是 $G[i]$。</p><p>达达的力气很大，他一次可以搬动重量之和不超过 $W$ 的任意多个物品。</p><p>达达希望一次搬掉尽量重的一些物品，请你告诉达达在他的力气范围内一次性能搬动的最大重量是多少。</p><p><strong>输入格式</strong></p><p>第一行两个整数，分别代表 $W$ 和 $N$。</p><p>以后 $N$ 行，每行一个正整数表示 $G[i]$。</p><p><strong>输出格式</strong></p><p>仅一个整数，表示达达在他的力气范围内一次性能搬动的最大重量。</p><p><strong>数据范围</strong></p><p>$1 ≤ N ≤ 46,$<br>$1 ≤ W , G[i] ≤ 2^{31}−1$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出背包体积和每个物品体积，问一次最多装多少物品</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看数据范围判断背包问题一定会TLE，但N范围比较小，因此使用爆搜，把所有可能方案枚举一遍，取一个最大值<br>但是直接爆搜，时间复杂度 2^46^，也是会超时的</p><p><strong>优化——双向DFS</strong> 用空间换时间<br>先枚举前一半数能凑出来的集合，再枚举后一半数，然后在两个集合中分别找 $a、b$，看能不能找到使$a+b&lt;&#x3D;w$（$w$是要求的最大总重量）<br>爆搜b，二分查找a，借此优化时间复杂度</p><p>本题思路总结如下：</p><ol><li>将所有物品重量从大到小排序</li><li>先将前k件物品能凑出的所有重量打表，然后排序判重</li><li>搜索剩下的n-k件物品的选择方式，然后在表中二分出不超过w的最大值</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">46</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="type">int</span> w[N]; <span class="comment">// 每个物品重量</span></span><br><span class="line"><span class="type">int</span> weights[<span class="number">1</span> &lt;&lt; <span class="number">25</span>], cnt; <span class="comment">// 能凑出来的重量</span></span><br><span class="line"><span class="type">int</span> ans; <span class="comment">// 全局最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s)</span> <span class="comment">// u:枚举到哪个数 s:当前的和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == k)</span><br><span class="line">    &#123;</span><br><span class="line">        weights[cnt ++ ] = s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(u + <span class="number">1</span>, s); <span class="comment">// 不选第u个</span></span><br><span class="line">    <span class="keyword">if</span> ((i64)s + w[u] &lt;= m) <span class="built_in">dfs1</span>(u + <span class="number">1</span>, s + w[u]); <span class="comment">// 选第u个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 二分查找前一部分</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (weights[mid] &lt;= m - s)  l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, weights[l] + s); <span class="comment">// 更新答案</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs2</span>(u + <span class="number">1</span>, s); <span class="comment">// 不选第u个</span></span><br><span class="line">    <span class="keyword">if</span> ((i64)s + w[u] &lt;= m) <span class="built_in">dfs2</span>(u + <span class="number">1</span>, s + w[u]); <span class="comment">// 选第u个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(w, w + n);</span><br><span class="line">    <span class="built_in">reverse</span>(w, w + n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对前k个数打表预处理</span></span><br><span class="line">    k = n / <span class="number">2</span>; <span class="comment">// 防止n==1死循环</span></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序去重</span></span><br><span class="line">    <span class="built_in">sort</span>(weights, weights + cnt);</span><br><span class="line">    cnt = <span class="built_in">unique</span>(weights, weights + cnt) - weights; <span class="comment">// 返回当前数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs2</span>(k, <span class="number">0</span>); <span class="comment">// 爆搜后一部分</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> DFS </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】DFS迭代加深与IDA*</title>
      <link href="/posts/78aeb4cc.html"/>
      <url>/posts/78aeb4cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h1><p>搜索时可能会遇到这样一种情况：</p><img src="/posts/undefined/1.png" class><p>明明答案就在第一层！但是因为DFS的缘故浪费很多时间<br>迭代加深就是用来解决这个问题的算法</p><p>定义一个 max_depth ，每次搜索时，超过这一层就全部剪掉、<br>（相当于我们划定一个区域，在这个区域内找解，如果找不到，再扩大区域）</p><p>？迭代加深和BFS有什么区别呢<br>BFS用队列存储，浪费空间，迭代加深本质是还是DFS，只存储本条路径，还是O(n)的算法</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="加成序列"><a href="#加成序列" class="headerlink" title="加成序列"></a>加成序列</h3><p><a href="https://www.acwing.com/problem/content/172/">原题链接</a></p><p>满足如下条件的序列 X（序列中元素被标号为 1、2、3…m）被称为“加成序列”：</p><ol><li>$X[1]&#x3D;1$</li><li>$X[m]&#x3D;n$</li><li>$X[1]&lt;X[2]&lt;…&lt;X[m−1]&lt;X[m]$</li><li>对于每个 k（2 ≤ k ≤ m）都存在两个整数 i 和 j （1 ≤ i , j ≤ k − 1，i 和 j 可相等），使得 $X[k]&#x3D;X[i]+X[j]$。</li></ol><p>你的任务是：给定一个整数 n，找出符合上述条件的长度 m 最小的“加成序列”。</p><p>如果有多个满足要求的答案，只需要找出任意一个可行解。</p><p><strong>输入格式</strong></p><p>输入包含多组测试用例。</p><p>每组测试用例占据一行，包含一个整数 n。</p><p>当输入为单行的 0 时，表示输入结束。</p><p><strong>输出格式</strong></p><p>对于每个测试用例，输出一个满足需求的整数序列，数字之间用空格隔开。</p><p>每个输出占一行。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 100</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">77</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">12</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">10</span> <span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">17</span> <span class="number">34</span> <span class="number">68</span> <span class="number">77</span></span><br></pre></td></tr></table></figure><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给出 n 构造一个序列，要求第一个数是1，最后一个数是n，严格递增，且后面的数一定要是前面两个数之和（两个数可以是同一个数），输出一个长度最小的序列</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>序列的最小规模：1 2 4 8 16 32 64 128 此时就已经超过100了，说明正确答案的深度不会很深，适合用迭代加深来做<br>层数从1开始，依次考虑每一位选什么数字</p><p><strong>优化：</strong></p><ol><li>优化搜索顺序：优先枚举较大的数，层数较少，更快的找到 n</li><li>排除等效冗余：举个栗子：1 2 3 4 现在枚举下一个数，不管选择1+4还是2+3结果都是5，就可以不用计算两次了（方法是开一个bool数组存储每个数是否被用过）</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 标记某数是否被用过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span> <span class="comment">// 分别是当前层数和最大层数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; depth) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当前层数&gt;最大层数</span></span><br><span class="line">    <span class="keyword">if</span> (path[u - <span class="number">1</span>] == n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 最后一个数为n满足条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = u - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = path[i] + path[j];</span><br><span class="line">            <span class="keyword">if</span> (s &gt; n || s &lt;= path[u - <span class="number">1</span>] || st[s]) <span class="keyword">continue</span>; <span class="comment">// 大于最大值or小于前一个值or已被用过 都不满足条件</span></span><br><span class="line"></span><br><span class="line">            st[s] = <span class="literal">true</span>; <span class="comment">// 标记s已被用过</span></span><br><span class="line">            path[u] = s; <span class="comment">// 记录s</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(u + <span class="number">1</span>, depth)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 下一位</span></span><br><span class="line">            st[s] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">1</span>, depth)) depth ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i ++ ) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA*"></a>IDA*</h1><p>IDA*是什么意思？</p><p>IDA*就是特殊的剪枝，一般情况下和<strong>迭代加深</strong>结合起来使用，需要定义一个max_depth，我们搜索到一个结点的时候就开始预估这个结点和正确答案的步数，如果说在这个步数内无论如何都找不到正确答案，那就不继续往下搜了提前退出</p><p>要求：估价函数&lt;&#x3D;真实值</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="排书"><a href="#排书" class="headerlink" title="排书"></a>排书</h3><p><a href="https://www.acwing.com/problem/content/182/">原题链接</a></p><p>给定 $n$ 本书，编号为 $1∼n$。</p><p>在初始状态下，书是任意排列的。</p><p>在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。</p><p>我们的目标状态是把书按照 $1∼n$ 的顺序依次排列。</p><p>求最少需要多少次操作。</p><p><strong>输入格式</strong></p><p>第一行包含整数 $T$，表示共有 T 组测试数据。</p><p>每组数据包含两行，第一行为整数 $n$，表示书的数量。</p><p>第二行为 $n$ 个整数，表示 $1∼n$ 的一种任意排列。</p><p>同行数之间用空格隔开。</p><p><strong>输出格式</strong></p><p>每组数据输出一个最少操作次数。</p><p>如果最少操作次数大于或等于 5 次，则输出 <code>5 or more</code>。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><p>$1 ≤ n ≤ 15$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">6</span> <span class="number">8</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">7</span> <span class="number">2</span> <span class="number">9</span> <span class="number">1</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">or</span> more</span><br></pre></td></tr></table></figure><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>一列数，每次可以取出其中一个子串插到其他地方，问至少多少次能让数列递增</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>采用迭代加深框架，每次估计当前序列最少要进行多少次操作才能把它变成排好序的序列</p><p>怎么确定估价函数呢？</p><p>我们观察每一位数的后继（也就是后面那个数），如果序列排好序，那么每个元素的后继都应该比元素本身大1<br>每操作一次会修改三个元素的后继，如下图所示：</p><img src="/posts/undefined/2.png" class><p>因此我们先统计出有 tot 个元素的后继不正确，因为每次操作可以修改三个后继，我们假设三个后继都变成正确的了，所以最少进行的操作步数就是$\lceil\frac{tot}{3}\rceil$，也就是$\lfloor\frac{tot+2}{3}\rfloor$，用它作为估价函数可以保证一定满足条件</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> w[<span class="number">5</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> <span class="comment">// 估价函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>; <span class="comment">// 错误的后继数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (q[i + <span class="number">1</span>] != q[i] + <span class="number">1</span>) tot ++ ;</span><br><span class="line">    <span class="keyword">return</span> (tot + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> max_depth)</span> <span class="comment">// 分别表示当前层数和最大层数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth + <span class="built_in">f</span>() &gt; max_depth) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当前深度大于最大深度</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 估价函数=0说明当前就是正确答案</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len ++ ) <span class="comment">// 枚举长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l + len - <span class="number">1</span> &lt; n; l ++ ) <span class="comment">// 枚举从哪开始截</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = r + <span class="number">1</span>; k &lt; n; k ++ ) <span class="comment">// 枚举挪到哪个位置（k是结尾位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(w[depth], q, <span class="keyword">sizeof</span> q); <span class="comment">// 把原数组存到w里</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 挪位</span></span><br><span class="line">                <span class="type">int</span> y = l;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = r + <span class="number">1</span>; x &lt;= k; x ++, y ++ ) q[y] = w[depth][x];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = l; x &lt;= r; x ++, y ++ ) q[y] = w[depth][x];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth + <span class="number">1</span>, max_depth)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(q, w[depth], <span class="keyword">sizeof</span> q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代加深</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>; <span class="comment">// 最大层数</span></span><br><span class="line">        <span class="keyword">while</span> (depth &lt; <span class="number">5</span> &amp;&amp; !<span class="built_in">dfs</span>(<span class="number">0</span>, depth)) depth ++ ; <span class="comment">// 这里注意循环判断条件一定要把depth&lt;5放前面！否则TLE</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= <span class="number">5</span>) cout &lt;&lt; <span class="string">&quot;5 or more\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; depth &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挪位理解不了就画图</p><img src="/posts/undefined/3.png" class><h3 id="回转游戏"><a href="#回转游戏" class="headerlink" title="回转游戏"></a>回转游戏</h3><p><a href="https://www.acwing.com/problem/content/183/">原题链接</a></p><p>如下图所示，有一个 # 形的棋盘，上面有 1,2,3 三种数字各 8 个。</p><p>给定 8 种操作，分别为图中的 $A∼H$。</p><p>这些操作会按照图中字母和箭头所指明的方向，把一条长为 7 的序列循环移动 1 个单位。</p><p>例如下图最左边的 # 形棋盘执行操作 $A$ 后，会变为下图中间的 # 形棋盘，再执行操作 $C$ 后会变成下图最右边的 # 形棋盘。</p><p>给定一个初始状态，请使用最少的操作次数，使 # 形棋盘最中间的 8 个格子里的数字相同。</p><img src="/posts/undefined/4.png" class><p><strong>输入格式</strong></p><p>输入包含多组测试用例。</p><p>每个测试用例占一行，包含 24 个数字，表示将初始棋盘中的每一个位置的数字，按整体从上到下，同行从左到右的顺序依次列出。</p><p>输入样例中的第一个测试用例，对应上图最左边棋盘的初始状态。</p><p>当输入只包含一个 0 的行时，表示输入终止。</p><p><strong>输出格式</strong></p><p>每个测试用例输出占两行。</p><p>第一行包含所有移动步骤，每步移动用大写字母 $A∼H$ 中的一个表示，字母之间没有空格，如果不需要移动则输出 <code>No moves needed</code>。</p><p>第二行包含一个整数，表示移动完成后，中间 8 个格子里的数字。</p><p>如果有多种方案，则输出字典序最小的解决方案。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AC</span><br><span class="line"><span class="number">2</span></span><br><span class="line">DDHH</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>井字格，每次可以拉动任意一条边，要求用最小的操作次数使中间的八个格子数字一样</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>要求字典序最小，因此按照字典序搜索即可</p><p>每次往下搜所层数都很深，但是根据 <del>搜索问题的玄学性，</del> 直觉来看正确答案的层数不会很深，所以选择迭代加深的算法来做<br>迭代加深搜索的过程中我们加入估价函数，让迭代加深升级为IDA*</p><p>每拉动一次，中间的八个格子只有一个格子的数字会改变，所以先统计八个格子里出现次数最多的数字出现了多少次（记作 $cnt$），那最好的情况就是每操作一次，都使得一个不是最多数的数字变成最多数，因此可以将估价函数设置为 $f()&#x3D;8-cnt$，就可以保证这个数字一定小于等于正确答案</p><p>本题还有一个难点就是怎么表示出这几个操作，我们可以先打表，给格子编号，然后预先处理出几个操作的具体步骤<br>{asset_image 5.png}</p><p><strong>优化：</strong> 本次枚举的操作一定不能是上一次的逆操作</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储每个操作移动的位置</span></span><br><span class="line"><span class="type">int</span> op[<span class="number">8</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">22</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>&#125;,</span><br><span class="line">    &#123;<span class="number">23</span>, <span class="number">21</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">22</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储每个操作对应的逆操作</span></span><br><span class="line"><span class="type">int</span> opposite[<span class="number">8</span>] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储中间的八个数</span></span><br><span class="line"><span class="type">int</span> center[<span class="number">8</span>] = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> path[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> <span class="comment">// 估价函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ ) sum[q[center[i]]] ++ ; <span class="comment">// 找到每个数出现几次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i ++ ) s = <span class="built_in">max</span>(s, sum[i]); <span class="comment">// 找到出现最多的次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> - s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operate</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = q[op[x][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i ++ ) q[op[x][i]] = q[op[x][i + <span class="number">1</span>]];</span><br><span class="line">    q[op[x][<span class="number">6</span>]] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> max_depth, <span class="type">int</span> last)</span> <span class="comment">// depth:当前层数 max_depth:最大层数 last:上一步</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth + <span class="built_in">f</span>() &gt; max_depth) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 范围内找不到解</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到正确答案</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (opposite[i] != last) <span class="comment">// 只要不是逆操作就往下搜</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">operate</span>(i);</span><br><span class="line">            path[depth] = i; <span class="comment">// 记录操作</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth + <span class="number">1</span>, max_depth, i)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 递归操作</span></span><br><span class="line">            <span class="built_in">operate</span>(opposite[i]); <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; q[<span class="number">0</span>], q[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代加深</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">0</span>, depth, <span class="number">-1</span>)) depth ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!depth) cout &lt;&lt; <span class="string">&quot;No moves needed&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i ++ ) cout &lt;&lt; (<span class="type">char</span>)(path[i] + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; q[<span class="number">6</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> DFS </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 迭代加深 </tag>
            
            <tag> IDA* </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】DFS剪枝与优化</title>
      <link href="/posts/2e580918.html"/>
      <url>/posts/2e580918.html</url>
      
        <content type="html"><![CDATA[<p><strong>剪枝</strong>是什么意思呢？</p><p>我们知道，不管是内部搜索还是外部搜索，都可以形成一棵搜索树，如果将搜索树全部遍历一遍，效率会很低，但如果我们能在搜索的过程中，提前预知，判断某一些不可能是正确答案的情况，就可以不用遍历其下的子树，从而提高我们的算法效率</p><p>我们可以从以下几个角度考虑剪枝：</p><ol><li>优化搜索顺序<br>优先选择分支较少的结点</li><li>排除等效冗余<br>尽量保证不搜索重复的状态（就是在不考虑顺序时，采用组合的方式搜索）</li><li>可行性剪枝<br>不合法提前退出</li><li>最优性剪枝<br>如果当前答案无论如何都比目前的最优解要差，那就可以不要往下搜了</li><li>记忆化搜索（DP）</li></ol><p>接下来将通过例题来讲解</p><h1 id="小猫爬山"><a href="#小猫爬山" class="headerlink" title="小猫爬山"></a>小猫爬山</h1><p><a href="https://www.acwing.com/problem/content/167/">原题链接</a></p><p>翰翰和达达饲养了 N 只小猫，这天，小猫们要去爬山。</p><p>经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕&gt;_&lt;）。</p><p>翰翰和达达只好花钱让它们坐索道下山。</p><p>索道上的缆车最大承重量为 W，而 N 只小猫的重量分别是 C1、C2……CN。</p><p>当然，每辆缆车上的小猫的重量之和不能超过 W。</p><p>每租用一辆缆车，翰翰和达达就要付 1 美元，所以他们想知道，最少需要付多少美元才能把这 N 只小猫都运送下山？</p><p><strong>输入格式</strong></p><p>第 1 行：包含两个用空格隔开的整数，N 和 W。</p><p>第 2..N+1 行：每行一个整数，其中第 i+1 行的整数表示第 i 只小猫的重量 Ci。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。</p><p><strong>数据范围</strong></p><p>1 ≤ N ≤ 18,<br>1 ≤ C<del>i</del> ≤ W ≤ 108</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">1996</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1994</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出小猫重量、缆车承重，问最少要多少缆车能把所有小猫运走</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>枚举每只小猫，有两种状态：</p><ul><li>放到当前这辆车上</li><li>新开一辆车</li></ul><p><strong>优化：</strong> </p><ol><li>优化搜索顺序：比较一只比较轻的猫和另一只比较重的猫，显然是比较重的猫带来的分支数量较少，因为如果猫非常重可以直接把车占满，但是猫很轻的话我们就要考虑还要加什么别的猫，因此：将所有猫按从大到小排序，优先放重猫</li><li>可行性剪枝：当发现目前小猫的重量已经超过缆车承重，就不要再往下搜了</li><li>最优性剪枝：当发现目前缆车数量已经大于等于当前计算出的缆车最少数量，就不要再搜索了</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> ans = N; <span class="comment">// 最坏的情况:每只小猫占一辆车</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span> <span class="comment">// u:当前在搜第几只猫 k:当前在搜第几辆车</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 最优性剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ ) <span class="comment">// 遍历每一辆车</span></span><br><span class="line">        <span class="comment">// 可行性剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (sum[i] + w[u] &lt;= m) <span class="comment">// 称重符合条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum[i] += w[u];</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, k);</span><br><span class="line">            sum[i] -= w[u]; <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新开一辆车</span></span><br><span class="line">    sum[k] = w[u];</span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">    sum[k] = <span class="number">0</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化搜索顺序</span></span><br><span class="line">    <span class="built_in">sort</span>(w, w + n);</span><br><span class="line">    <span class="built_in">reverse</span>(w, w + n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数独"><a href="#数独" class="headerlink" title="数独"></a>数独</h1><p><a href="https://www.acwing.com/problem/content/168/">原题链接</a></p><p>数独是一种传统益智游戏，你需要把一个 9×9 的数独补充完整，使得数独中每行、每列、每个 3×3 的九宫格内数字 1∼9 均恰好出现一次。</p><p>请编写一个程序填写数独。</p><p><strong>输入格式</strong></p><p>输入包含多组测试用例。</p><p>每个测试用例占一行，包含 81 个字符，代表数独的 81 个格内数据（顺序总体由上到下，同行由左到右）。</p><p>每个字符都是一个数字（1−9）或一个 .（表示尚未填充）。</p><p>您可以假设输入中的每个谜题都只有一个解决方案。</p><p>文件结尾处为包含单词 end 的单行，表示输入结束。</p><p><strong>输出格式</strong></p><p>每个测试用例，输出一行数据，代表填充完全后的数独。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4.</span>...<span class="number">.8</span><span class="number">.5</span><span class="number">.3</span>.........<span class="number">.7</span>.....<span class="number">.2</span>....<span class="number">.6</span>....<span class="number">.8</span><span class="number">.4</span>.....<span class="number">.1</span>......<span class="number">.6</span><span class="number">.3</span><span class="number">.7</span><span class="number">.5</span>.<span class="number">.2</span>....<span class="number">.1</span><span class="number">.4</span>......</span><br><span class="line">.....<span class="number">.52</span>.<span class="number">.8</span><span class="number">.4</span>.....<span class="number">.3</span>..<span class="number">.9</span>..<span class="number">.5</span><span class="number">.1</span>..<span class="number">.6</span>.<span class="number">.2</span>.<span class="number">.7</span>.......<span class="number">.3</span>....<span class="number">.6</span>..<span class="number">.1</span>.........<span class="number">.7</span><span class="number">.4</span>......<span class="number">.3</span>.</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">417369825632158947958724316825437169791586432346912758289643571573291684164875293</span></span><br><span class="line"><span class="number">416837529982465371735129468571298643293746185864351297647913852359682714128574936</span></span><br></pre></td></tr></table></figure><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>填好数独，保证每行每列、每个3x3方块都包含1-9</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>先做一个小优化，看比如说一个3x3小方格中有哪些数字没被用过，随意选择一个格子，然后对这些数字依次枚举搜索即可</p><p><strong>优化：</strong></p><ol><li>优化搜索顺序：选择格子时，尽量选择分支数量较少的格子，比如说一个格子有2种填法，另一个格子有5种，那肯定优先选择2种的</li><li>可行性剪枝：一旦与行列九宫格重复时就不要继续搜了</li><li>&#x3D;&#x3D;<strong>位运算优化：</strong>&#x3D;&#x3D; 特殊优化，可以用一个九位的二进制数表示每一行数使用的状态<br>比如：0 1 0 0 1 1 1 0 0 可以用来表示2 5 6 7还没用其他数字用过了<br>我们考虑这一位上能不能填这个数时，应该考虑二进制数的交集，即在行、列、九宫格的二进制数列上，这个数字都为1，表示在行、列、九宫格内这个数字都没有被使用，我们才能用这个数（直接按位与&amp;）<br>这里有个比循环九次更好的办法——<strong>lowbit</strong><br>lowbit运算可以帮助我们在O(1)的时间复杂度内，返回当前数里的最后一个1，因此用lowbit循环就可以抠出来所有的1</li></ol><p>好难啊好难啊qaq看代码注释吧还是</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">9</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ones[M]; <span class="comment">// 每个二进制数里1的个数</span></span><br><span class="line"><span class="type">int</span> mapp[M]; <span class="comment">// 把二进制数换成第几位是1</span></span><br><span class="line"><span class="type">int</span> row[N], col[N], cell[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 初始化，将所有位置都标记成没用过(也就是标记成1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ ) row[i] = col[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            cell[i][j] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> t, <span class="type">bool</span> is_set)</span> <span class="comment">// 在(x,y)这个位置填上/删去t 填上的话is_set为true 删去为false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_set) str[x * N + y] = <span class="string">&#x27;1&#x27;</span> + t; <span class="comment">// t属于0-8 要把它换算成1-9</span></span><br><span class="line">    <span class="keyword">else</span> str[x * N + y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span> &lt;&lt; t; <span class="comment">// t换算到在每一行的位置</span></span><br><span class="line">    <span class="keyword">if</span> (!is_set) v = -v; <span class="comment">// 若为清空操作则取反</span></span><br><span class="line"></span><br><span class="line">    row[x] -= v;</span><br><span class="line">    col[y] -= v;</span><br><span class="line">    cell[x / <span class="number">3</span>][y / <span class="number">3</span>] -= v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 返回二进制数的最后一个1以及这个1之后的所有0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">// 返回(x,y)能填的数字(二进制序列)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x / <span class="number">3</span>][y / <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cnt) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 全部填完</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> minv = <span class="number">10</span>; <span class="comment">// 首先找分支数最少的空格，将最少的分支数赋给maxx</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (str[i * N + j] == <span class="string">&#x27;.&#x27;</span>) <span class="comment">// 格子为空可以填数字</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> state = <span class="built_in">get</span>(i, j); <span class="comment">// 该格子能填的数字的交集</span></span><br><span class="line">                <span class="keyword">if</span> (ones[state] &lt; minv)</span><br><span class="line">                &#123;</span><br><span class="line">                    minv = ones[state]; <span class="comment">// 更新最少分支数</span></span><br><span class="line">                    x = i, y = j; <span class="comment">// xy存的就是分支数量最少的格子的坐标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> state = <span class="built_in">get</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = state; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = mapp[<span class="built_in">lowbit</span>(i)]; <span class="comment">// 得到最后一个1所在的位置</span></span><br><span class="line">        <span class="built_in">draw</span>(x, y, t, <span class="literal">true</span>); <span class="comment">// 把t填进去</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(cnt - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 成功直接返回true</span></span><br><span class="line">        <span class="built_in">draw</span>(x, y, t, <span class="literal">false</span>); <span class="comment">// 失败就把填进去的值再删掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打表得到ones和mapp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ ) mapp[<span class="number">1</span> &lt;&lt; i] = i; <span class="comment">// 将所有2^k转化成k(也就是返回二进制数里唯一一个1的位置)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; N; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">            ones[i] += i &gt;&gt; j &amp; <span class="number">1</span>; <span class="comment">// 记下每个二进制数里1的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; str, str[<span class="number">0</span>] != <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 有多少位置没填</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++, k ++ )</span><br><span class="line">                <span class="keyword">if</span> (str[k] != <span class="string">&#x27;.&#x27;</span>) <span class="comment">// 位置不空就把值填进去</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> t = str[k] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="built_in">draw</span>(i, j, t, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++ ; <span class="comment">// 位置空就累加空位的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(cnt);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="木棒"><a href="#木棒" class="headerlink" title="木棒"></a>木棒</h1><p><a href="https://www.acwing.com/problem/content/169/">原题链接</a></p><p>乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过 50 个长度单位。</p><p>然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。</p><p>请你设计一个程序，帮助乔治计算木棒的可能最小长度。</p><p>每一节木棍的长度都用大于零的整数表示。</p><p><strong>输入格式</strong></p><p>输入包含多组数据，每组数据包括两行。</p><p>第一行是一个不超过 64 的整数，表示砍断之后共有多少节木棍。</p><p>第二行是截断以后，所得到的各节木棍的长度。</p><p>在最后一组数据之后，是一个零。</p><p><strong>输出格式</strong></p><p>为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。</p><p><strong>数据范围</strong></p><p>数据保证每一节木棍的长度均不大于 50。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出一些数，将其分成若干组，使每一组总和相等，问最小的总和是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>木棒：每一组的总和<br>木棍：题目中输入的数据</p><p>先从小到大枚举木棒的长度length，看木棍能不能组成该长度的木棒</p><p><strong>优化：</strong></p><ol><li>所有木棍的总长度sum必须能整除木棒的长度length，才可能有解，不能整除的情况直接回溯不要搜了</li><li>优化搜索顺序：先枚举比较长的木棍，使之后的分支较少</li><li>排除等效冗余：<br>(1) 如果一根木棒里有第一根第二根两根木棍，那么先用第一根和先用第二根达成的效果都是一样的，因此按照组合数方式枚举<br>(2) 如果当前木棍加到当前木棒中失败，那直接略过后面所有等长木棍<br>(3) 如果是木棒的第一根木棍失败（说明这根木棍没地方放），则当前状态一定失败，直接回溯不要往下搜了<br>(4) 如果是木棒的最后一根木棍失败（这里的意思是往下dfs找不到解），则当前状态一定失败（因为放入比这根木棍小的木棍拼接起来的也一定找不到解），直接回溯不要往下搜了</li></ol><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N], sum, length; <span class="comment">// w[i]:每根小棍长度 sum:所有小棍总长度 length:每组总和</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 小棍有没有用过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s, <span class="type">int</span> start)</span> <span class="comment">// u:当前枚举到哪根大棍 s:当前大棍长度 start:开始位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u * length == sum) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 符合条件</span></span><br><span class="line">    <span class="keyword">if</span> (s == length) <span class="keyword">return</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 这根木棍长度已达要求，开下一根木棍</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化3(1):从start开始枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i ++ ) <span class="comment">// 从start开始遍历木棍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line">        <span class="keyword">if</span> (s + w[i] &gt; length) <span class="keyword">continue</span>; <span class="comment">// 可行性剪枝</span></span><br><span class="line"></span><br><span class="line">        st[i] = <span class="literal">true</span>; <span class="comment">// 更改状态</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(u, s + w[i], i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 下一层遍历</span></span><br><span class="line">        st[i] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化3(3):开头不行就一定不行</span></span><br><span class="line">        <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化3(4):结尾不行就一定不行</span></span><br><span class="line">        <span class="keyword">if</span> (s + w[i] == length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化3(2):等长直接略过</span></span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; w[j] == w[i]) j ++ ;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; w[i];</span><br><span class="line">            sum += w[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化2：搜索顺序</span></span><br><span class="line">        <span class="built_in">sort</span> (w, w + n);</span><br><span class="line">        <span class="built_in">reverse</span>(w, w + n);</span><br><span class="line"></span><br><span class="line">        length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 优化1:必须是整数倍</span></span><br><span class="line">            <span class="keyword">if</span> (sum % length == <span class="number">0</span> &amp;&amp; <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; length &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            length ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生日蛋糕"><a href="#生日蛋糕" class="headerlink" title="生日蛋糕"></a>生日蛋糕</h1><p><a href="https://www.acwing.com/problem/content/170/">原题链接</a></p><p>7 月 17 日是 Mr.W 的生日，ACM-THU 为此要制作一个体积为 Nπ 的 M 层生日蛋糕，每层都是一个圆柱体。</p><p>设从下往上数第 i 层蛋糕是半径为 Ri，高度为 Hi 的圆柱。</p><p>当 $i&lt;M$ 时，要求 $Ri&gt;Ri+1$ 且 H<del>i</del> &gt; H<del>i+1</del>。</p><p>由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积 Q 最小。</p><p>令 $Q&#x3D;Sπ$ ，请编程对给出的 N 和 M，找出蛋糕的制作方案（适当的 Ri 和 Hi 的值），使 S 最小。</p><p>除 Q 外，以上所有数据皆为正整数。</p><p><strong>输入格式</strong></p><p>输入包含两行，第一行为整数 N，表示待制作的蛋糕的体积为 Nπ。</p><p>第二行为整数 M，表示蛋糕的层数为 M。</p><p><strong>输出格式</strong></p><p>输出仅一行，是一个正整数 S（若无解则 S&#x3D;0）。</p><p><strong>数据范围</strong></p><p>1 ≤ N ≤ 10000,<br>1 ≤ M ≤ 20</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">68</span></span><br></pre></td></tr></table></figure><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>多层蛋糕，给出总体积总层数，可以自定义每一层半径和高度，使得从上往下看的总面积和总侧面积之和最小，求最小值</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先明确我们的目的是让 2 * R<del>m</del> * h<del>m</del> + 2 * R<del>m-1</del> * h<del>m-1</del> + … + 2 * R<del>1</del> * h<del>1</del> + R<del>m</del>^2^ 最小（省去了所有的$π$）</p><p><strong>优化：</strong></p><ol><li>优化搜索顺序：分支少的先搜，从大到小枚举<br>(1) 要先搜面积大的，因此自底向上搜<br>(2) 半径是平方级别，高是一次方，半径对体积影响更大，因此先枚举半径</li><li>可行性剪枝：<br>(1) 设从上往下为1-m层，第 u 层的半径记为 R<del>u</del>，一定比 u 大，且比 R<del>u+1</del> - 1 小，同时，我们设第 u 层下方的所有体积为 V，那么前 u 层的体积就是 $n - V$，即有 $n - V &gt;&#x3D; R_u^2h_u$，放缩后有 $R_u &lt;&#x3D; \sqrt{n - V}$<br>据此得到：**&#x3D;&#x3D;$u &lt;&#x3D; R_u &lt;&#x3D; min{R_{u+1}-1,  \sqrt{n-V}}$&#x3D;&#x3D;**<br>(2) 同时，H<del>u</del>也&gt;&#x3D;u，且比 H<del>u+1</del>小， $n - V &gt;&#x3D; R_u^2h_u$，放缩后有 $h_u&lt;&#x3D; \frac{n-V}{R^2}$<br>据此得到：**&#x3D;&#x3D;$u &lt;&#x3D; h_u &lt;&#x3D; min{h_{u+1}-1,  \frac{n-V}{R^2}}$&#x3D;&#x3D;**</li><li>最小体积是半径和高都取1时，因此可以预处理一下前 u 层的体积最小值$minv(u)$和表面积最小值$mins(u)$，需要满足以下两个条件才有往下搜的必要，否则直接回溯：<br><strong>&#x3D;&#x3D;$V+minv(u)&lt;&#x3D;n$&#x3D;&#x3D;</strong><br><strong>&#x3D;&#x3D;$s+mins(u)&lt;ans$&#x3D;&#x3D;</strong></li><li>已知：$n-V&#x3D;\sum_{k&#x3D;1}^{u}R_k^2h_k$<br>并且：$S_{1\rightarrow u}&#x3D;\sum_{k&#x3D;1}^{u}2R_kh_k&#x3D;\frac{2}{R_{u+1}}\sum_{k&#x3D;1}^{u}R_uhR_{u+1}&gt;\frac{2}{R_{u+1}}\sum_{k&#x3D;1}^{u}R_u^2h$<br>因此：$S_{1\rightarrow u}&gt;\frac{2(n-V)}{R_{u+1}}$<br>所以当$s+\frac{2(n-V)}{R_{u+1}}&gt;&#x3D;ans$时，已经不可能是最优解了，直接回溯</li></ol><p>(好难…疯掉TAT</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> minv[N], mins[N]; <span class="comment">// 分别表示每一层及该层上方的最小体积和最小表面积</span></span><br><span class="line"><span class="type">int</span> R[N], H[N]; <span class="comment">// 表示每一层的半径和高</span></span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> s)</span> <span class="comment">// u:当前层数 v:当前体积 s:当前表面积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v + minv[u] &gt; n) <span class="keyword">return</span>; <span class="comment">// 优化3</span></span><br><span class="line">    <span class="keyword">if</span> (s + mins[u] &gt;= ans) <span class="keyword">return</span>; <span class="comment">// 优化3</span></span><br><span class="line">    <span class="keyword">if</span> (s + <span class="number">2</span> * (n - v) / R[u + <span class="number">1</span>] &gt;= ans) <span class="keyword">return</span>; <span class="comment">// 优化4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="comment">//已全部搜完</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == n) ans = s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化1:从大到小枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="built_in">min</span>(R[u + <span class="number">1</span>] - <span class="number">1</span>, (<span class="type">int</span>)<span class="built_in">sqrt</span>(n - v)); r &gt;= u; r -- ) <span class="comment">// 优化2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> h = <span class="built_in">min</span>(H[u + <span class="number">1</span>] - <span class="number">1</span>, (n - v) / r / r); h &gt;= u; h -- ) <span class="comment">// 优化2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (u == m) t = r * r; <span class="comment">// 如果是最底层，要加上底面积</span></span><br><span class="line">            R[u] = r, H[u] = h; <span class="comment">// 更新RH</span></span><br><span class="line">            <span class="built_in">dfs</span>(u - <span class="number">1</span>, v + r * r * h, s + <span class="number">2</span> * h * r + t);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打表做出minv mins</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        minv[i] = minv[i - <span class="number">1</span>] + i * i * i;</span><br><span class="line">        mins[i] = mins[i - <span class="number">1</span>] + <span class="number">2</span> * i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    R[m + <span class="number">1</span>] = H[m + <span class="number">1</span>] = inf; <span class="comment">// 设置哨兵</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(m, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans == inf) ans = <span class="number">0</span>; <span class="comment">// 无满足要求的情况</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> DFS </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】DFS搜索顺序</title>
      <link href="/posts/7614fc0a.html"/>
      <url>/posts/7614fc0a.html</url>
      
        <content type="html"><![CDATA[<h1 id="马走日"><a href="#马走日" class="headerlink" title="马走日"></a>马走日</h1><p><a href="https://www.acwing.com/problem/content/1118/">原题链接</a></p><p>马在中国象棋以日字形规则移动。</p><p>请编写一段程序，给定 n∗m 大小的棋盘，以及马的初始位置 (x，y)，要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。</p><p><strong>输入格式</strong></p><p>第一行为整数 T，表示测试数据组数。</p><p>每一组测试数据包含一行，为四个整数，分别为棋盘的大小以及初始位置坐标 n,m,x,y。</p><p><strong>输出格式</strong></p><p>每组测试数据包含一行，为一个整数，表示马能遍历棋盘的途径总数，若无法遍历棋盘上的所有点则输出 0。</p><p><strong>数据范围</strong></p><p>1 ≤ T ≤ 9,<br>1 ≤ m , n ≤9,<br>1 ≤ n × m ≤ 28,<br>0 ≤ x ≤ n − 1,<br>0 ≤ y ≤ m − 1</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出矩阵大小，给出马的初始位置，马只能走日。问有多少种方案让马可以遍历完棋盘上的所有点，每种方案里不可以重复经过两个点</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这就是典型的外部搜索，是不同状态之间的搜索，因此每次需要恢复现场（可以理解为悔棋）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cnt)</span> <span class="comment">// 前两个参数表示当前点坐标，第三个参数表示目前已经搜了多少个点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n * m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans ++ ;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ ) <span class="comment">// 遍历八个操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line">        <span class="built_in">dfs</span>(a, b, cnt + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    st[x][y] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙</h1><p><a href="https://www.acwing.com/problem/content/1119/">原题链接</a></p><p>单词接龙是一个与我们经常玩的成语接龙相类似的游戏。</p><p>现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”，每个单词最多被使用两次。</p><p>在两个单词相连时，其重合部分合为一部分，例如 beast 和 astonish ，如果接成一条龙则变为 beastonish。</p><p>我们可以任意选择重合部分的长度，但其长度必须大于等于1，且严格小于两个串的长度，例如 at 和 atide 间不能相连。</p><p><strong>输入格式</strong></p><p>输入的第一行为一个单独的整数 n 表示单词数，以下 n 行每行有一个单词（只含有大写或小写字母，长度不超过20），输入的最后一行为一个单个字符，表示“龙”开头的字母。</p><p>你可以假定以此字母开头的“龙”一定存在。</p><p><strong>输出格式</strong></p><p>只需输出以此字母开头的最长的“龙”的长度。</p><p><strong>数据范围</strong></p><p>n ≤ 20，<br>单词随机生成。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">at</span><br><span class="line">touch</span><br><span class="line">cheat</span><br><span class="line">choose</span><br><span class="line">tact</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>连成的“龙”为 atoucheatactactouchoose。</p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出多个字符串，首位有相同字串的两个字符串可以连接，给出开头字符，问能连接的最大长度</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>外部搜索，每次需恢复原状</p><p>从开头字符与给定字符相同的单词开始，每次遇到能接到字符串后面的就往深遍历，（形成一个搜索树一样的结构）</p><p>下方代码有详细注释</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string word[N]; <span class="comment">// 记录每个单词</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 记录每两个单词有多少重合</span></span><br><span class="line"><span class="type">int</span> used[N]; <span class="comment">// 记录这个单词被用了多少次</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string dragon, <span class="type">int</span> last)</span> <span class="comment">// 第一个参数是当前字符串 第二个参数是当前最后一个字符串编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>((<span class="type">int</span>)dragon.<span class="built_in">size</span>(), ans); <span class="comment">// 更新最大长度</span></span><br><span class="line"></span><br><span class="line">    used[last] ++ ; <span class="comment">// 更新字符串使用次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 遍历每个字符串</span></span><br><span class="line">        <span class="keyword">if</span> (g[last][i] &amp;&amp; used[i] &lt; <span class="number">2</span>) <span class="comment">// 条件：和当前最后一个字符串有重合 &amp;&amp; 使用次数不到2次</span></span><br><span class="line">            <span class="built_in">dfs</span>(dragon + word[i].<span class="built_in">substr</span>(g[last][i]), i);</span><br><span class="line"></span><br><span class="line">    used[last] -- ; <span class="comment">// 恢复</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; word[i];</span><br><span class="line">    <span class="type">char</span> start;</span><br><span class="line">    cin &gt;&gt; start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每两个字符串最短的重合字符个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            string a = word[i], b = word[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; <span class="built_in">min</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()); k ++ ) <span class="comment">// 从1开始，最长不超过较短字符串长度</span></span><br><span class="line">                <span class="keyword">if</span> (a.<span class="built_in">substr</span>(a.<span class="built_in">size</span>() - k, k) == b.<span class="built_in">substr</span>(<span class="number">0</span>, k)) <span class="comment">// 一旦重合立刻跳出</span></span><br><span class="line">                &#123;</span><br><span class="line">                    g[i][j] = k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (word[i][<span class="number">0</span>] == start)</span><br><span class="line">            <span class="built_in">dfs</span>(word[i], i);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分成互质组"><a href="#分成互质组" class="headerlink" title="分成互质组"></a>分成互质组</h1><p><a href="https://www.acwing.com/problem/content/1120/">原题链接</a></p><p>给定 n 个正整数，将它们分组，使得每组中任意两个数互质。</p><p>至少要分成多少个组？</p><p><strong>输入格式</strong></p><p>第一行是一个正整数 n。</p><p>第二行是 n 个不大于10000的正整数。</p><p><strong>输出格式</strong></p><p>一个正整数，即最少需要的组数。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 10</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">14</span> <span class="number">20</span> <span class="number">33</span> <span class="number">117</span> <span class="number">143</span> <span class="number">175</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>每个组的数要互质，给出一系列数，问最少多少组</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>按照<strong>组合的方式</strong>搜索，每个组里按照下表从小到大添加所有能加进去的元素，直到不能再加任何一个元素，就新开一个组</p><p>&#x3D;&#x3D;<strong>当某个数可以加到最后一组时，就没有必要新开一个组</strong>&#x3D;&#x3D;</p><p>下方代码中有详细注释</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 存所有元素</span></span><br><span class="line"><span class="type">int</span> group[N][N]; <span class="comment">// 存每个组以及其中元素</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 判重</span></span><br><span class="line"><span class="type">int</span> ans = N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// 找最大公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> group[], <span class="type">int</span> gc, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; gc; j ++ ) <span class="comment">// 遍历group中的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">gcd</span>(p[group[j]], p[i]) &gt; <span class="number">1</span>) <span class="comment">// 最大公约数大于1说明不是互质</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> gc, <span class="type">int</span> tc, <span class="type">int</span> start)</span> <span class="comment">// u:第几组 gc:当前组内下标 tc:当前一共有多少元素 start:当前这一组从哪个元素开始搜</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt;= ans) <span class="keyword">return</span>; <span class="comment">// 剪枝优化:如果当前组数已经大于等于ans 说明一定不是最优解 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tc == n) ans = u; <span class="comment">// 所有数都搜索完了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// true表示当前组不能继续添加新元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i ++ ) <span class="comment">// 从start开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i] &amp;&amp; <span class="built_in">check</span>(group[u], gc, i)) <span class="comment">// 该元素没用过且与当前组所有元素互质</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>; <span class="comment">// 标记该元素</span></span><br><span class="line">            group[u][gc] = i; <span class="comment">// 将该元素加入组中</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span>(u, gc + <span class="number">1</span>, tc + <span class="number">1</span>, i + <span class="number">1</span>); <span class="comment">// 下一层遍历</span></span><br><span class="line"></span><br><span class="line">            st[i] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            flag = <span class="literal">false</span>; <span class="comment">// 表示还能添加新元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">dfs</span>(u + <span class="number">1</span>, <span class="number">0</span>, tc, <span class="number">0</span>); <span class="comment">// 不能添加新元素时新开一个组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> DFS </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】DFS连通性模型</title>
      <link href="/posts/46c8bf03.html"/>
      <url>/posts/46c8bf03.html</url>
      
        <content type="html"><![CDATA[<p>DFS 的搜索分为两大部分：</p><ul><li><strong>内部搜索</strong>：一个图中从一个点搜到另一个点</li><li><strong>外部搜索</strong>：从一张图（状态）搜到另一张图（状态）</li></ul><p>在第一个部分里是图内部点的搜索，每个点只能搜一次，因此搜过的点不需要恢复到原来的（还没被搜过的）状态（意思就是st数组不恢复）</p><p>而第二个部分是点的集合之间的搜索，每次搜索完一定要恢复到原有状态才可以进行下一步搜索（意思就是st数组每次需要恢复原状）</p><h1 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h1><p><a href="https://www.acwing.com/problem/content/1114/">原题链接</a></p><p>一天Extense在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由 n∗n 的格点组成，每个格点只有2种状态，.和#，前者表示可以通行后者表示不能通行。</p><p>同时当Extense处在某个格点时，他只能移动到东南西北(或者说上下左右)四个方向之一的相邻格点上，Extense想要从点A走到点B，问在不走出迷宫的情况下能不能办到。</p><p>如果起点或者终点有一个不能通行(为#)，则看成无法办到。</p><p>注意：A、B不一定是两个不同的点。</p><p><strong>输入格式</strong></p><p>第1行是测试数据的组数 k，后面跟着 k 组输入。</p><p>每组测试数据的第1行是一个正整数 n，表示迷宫的规模是 n∗n 的。</p><p>接下来是一个 n∗n 的矩阵，矩阵中的元素为.或者#。</p><p>再接下来一行是 4 个整数 ha,la,hb,lb，描述 A 处在第 ha 行, 第 la 列，B 处在第 hb 行, 第 lb 列。</p><p>注意到 ha,la,hb,lb 全部是从 0 开始计数的。</p><p><strong>输出格式</strong></p><p>k行，每行输出对应一个输入。</p><p>能办到则输出“YES”，否则输出“NO”。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 100</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">.##</span><br><span class="line">..#</span><br><span class="line">#..</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">.....</span><br><span class="line">###.#</span><br><span class="line">..#..</span><br><span class="line">###..</span><br><span class="line">...#.</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一张图两个点，问能不能从一个点走到另一个点</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接bfs遍历看能不能从一个点遍历到另一个</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line"><span class="type">int</span> xa, ya, xb, yb; <span class="comment">// 标记起点终点</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g[x][y] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == xb &amp;&amp; y == yb) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) <span class="comment">// 遍历四个操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(a, b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line">        cin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(xa, ya)) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="红与黑"><a href="#红与黑" class="headerlink" title="红与黑"></a>红与黑</h1><p><a href="https://www.acwing.com/problem/content/1115/">原题链接</a></p><p>有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。</p><p>你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。</p><p>请写一个程序，计算你总共能够到达多少块黑色的瓷砖。</p><p><strong>输入格式</strong></p><p>输入包括多个数据集合。</p><p>每个数据集合的第一行是两个整数 W 和 H，分别表示 x 方向和 y 方向瓷砖的数量。</p><p>在接下来的 H 行中，每行包括 W 个字符。每个字符表示一块瓷砖的颜色，规则如下</p><p>1）‘.’：黑色的瓷砖；<br>2）‘#’：红色的瓷砖；<br>3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。</p><p>当在一行中读入的是两个零时，表示输入结束。</p><p><strong>输出格式</strong></p><p>对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。</p><p><strong>数据范围</strong></p><p>1 ≤ W , H ≤ 20</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">9</span> </span><br><span class="line">....#. </span><br><span class="line">.....# </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">#@...# </span><br><span class="line">.#..#. </span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一个图分为红黑方块，问某一个黑方块的连通块个数</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本质上是个Flood Fill问题，可以用BFS实现</p><p>用DFS也是一样的，只是搜索顺序不一样</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">        <span class="keyword">if</span> (g[a][b] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>; <span class="comment">// 不是黑色的</span></span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line"></span><br><span class="line">        cnt += <span class="built_in">dfs</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; m &gt;&gt; n, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>) <span class="comment">// 找起点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">dfs</span>(x, y) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> DFS </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 连通性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】Flood Fill</title>
      <link href="/posts/de9f691a.html"/>
      <url>/posts/de9f691a.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>什么是 Flood Fill 算法？<br>字面意思理解：洪水覆盖<br>也就是说，下图的格子分为两大类，一类比较高一类比较低，现在从任意一处较低的格子开始灌水，下一次水将会覆盖它&#x3D;&#x3D;相邻的&#x3D;&#x3D;、&#x3D;&#x3D;较低的&#x3D;&#x3D;格子，依此类推<br>这就相当于是BFS的思想（也可以用DFS实现，但BFS不会出现爆栈的问题）</p><p><strong>Flood Fill 算法可以在线性时间复杂度内，找到某个点所在的连通块</strong></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="池塘计数"><a href="#池塘计数" class="headerlink" title="池塘计数"></a>池塘计数</h2><p><a href="https://www.acwing.com/problem/content/1099/">原题链接</a></p><p>农夫约翰有一片 N∗M 的矩形土地。</p><p>最近，由于降雨的原因，部分土地被水淹没了。</p><p>现在用一个字符矩阵来表示他的土地。</p><p>每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。</p><p>现在，约翰想知道他的土地中形成了多少片池塘。</p><p>每组相连的积水单元格集合可以看作是一片池塘。</p><p>每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。</p><p>请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 N 和 M。</p><p>接下来 N 行，每行包含 M 个字符，字符为”W”或”.”，用以表示矩形土地的积水状况，字符之间没有空格。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示池塘数目。</p><p><strong>数据范围</strong><br>1 ≤ N, M ≤ 1000</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">12</span></span><br><span class="line">W........WW.</span><br><span class="line">.WWW.....WWW</span><br><span class="line">....WW...WW.</span><br><span class="line">.........WW.</span><br><span class="line">.........W..</span><br><span class="line">..W......W..</span><br><span class="line">.W.W.....WW.</span><br><span class="line">W.W.W.....W.</span><br><span class="line">.W.W......W.</span><br><span class="line">..W.......W.</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>模板题，问有多少连通块</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按顺序遍历图上每一个点，如果这个点是洼地且未被遍历过，就在答案的基础上加1，并且标记这个连通块的所有点，直到遍历完整个图</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t.ft - <span class="number">1</span>; i &lt;= t.ft + <span class="number">1</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = t.sd - <span class="number">1</span>; j &lt;= t.sd + <span class="number">1</span>; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == t.ft &amp;&amp; j == t.sd) <span class="keyword">continue</span>; <span class="comment">// 正好遍历到当前点</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;.&#x27;</span> || st[i][j]) <span class="keyword">continue</span>; <span class="comment">// 不是洼地或已遍历过</span></span><br><span class="line"></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                st[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;W&#x27;</span> &amp;&amp; !st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">bfs</span>(i, j);</span><br><span class="line">                cnt ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="城堡问题"><a href="#城堡问题" class="headerlink" title="城堡问题"></a>城堡问题</h2><p><a href="https://www.acwing.com/problem/content/1100/">原题链接</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   1   2   3   4   5   6   7  </span><br><span class="line">  #############################</span><br><span class="line">1 #   |   #   |   #   |   |   #</span><br><span class="line">  #####---#####---#---#####---#</span><br><span class="line">2 #   #   |   #   #   #   #   #</span><br><span class="line">  #---#####---#####---#####---#</span><br><span class="line">3 #   |   |   #   #   #   #   #</span><br><span class="line">  #---#########---#####---#---#</span><br><span class="line">4 #   #   |   |   |   |   #   #</span><br><span class="line">  #############################</span><br><span class="line">             (图 1)</span><br><span class="line"></span><br><span class="line">  #  = Wall   </span><br><span class="line">  |  = No wall</span><br><span class="line">  -  = No wall</span><br><span class="line"></span><br><span class="line">  方向：上北下南左西右东。</span><br></pre></td></tr></table></figure><p>图1是一个城堡的地形图。</p><p>请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。</p><p>城堡被分割成 m∗n 个方格区域，每个方格区域可以有0~4面墙。</p><p>注意：墙体厚度忽略不计。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 m 和 n，分别表示城堡南北方向的长度和东西方向的长度。</p><p>接下来 m 行，每行包含 n 个整数，每个整数都表示平面图对应位置的方块的墙的特征。</p><p>每个方块中墙的特征由数字 P 来描述，我们用1表示西墙，2表示北墙，4表示东墙，8表示南墙，P 为该方块包含墙的数字之和。</p><p>例如，如果一个方块的 P 为3，则 3 &#x3D; 1 + 2，该方块包含西墙和北墙。</p><p>城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。</p><p>输入的数据保证城堡至少有两个房间。</p><p><strong>输出格式</strong></p><p>共两行，第一行输出房间总数，第二行输出最大房间的面积（方块数）。</p><p><strong>数据范围</strong></p><p>1 ≤ m, n ≤ 50,<br>0 ≤ P ≤ 15</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">7</span> </span><br><span class="line"><span class="number">11</span> <span class="number">6</span> <span class="number">11</span> <span class="number">6</span> <span class="number">3</span> <span class="number">10</span> <span class="number">6</span> </span><br><span class="line"><span class="number">7</span> <span class="number">9</span> <span class="number">6</span> <span class="number">13</span> <span class="number">5</span> <span class="number">15</span> <span class="number">5</span> </span><br><span class="line"><span class="number">1</span> <span class="number">10</span> <span class="number">12</span> <span class="number">7</span> <span class="number">13</span> <span class="number">7</span> <span class="number">5</span> </span><br><span class="line"><span class="number">13</span> <span class="number">11</span> <span class="number">10</span> <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">13</span> </span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个城堡中每个房间四面是否有墙壁，输出该城堡有多少个连通的房间，最大的连通块面积是多少</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>和上一题基本一样，判断每个房间的四面墙壁情况，只是要额外加一个面积的计算</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        area ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; <span class="comment">// 已被遍历</span></span><br><span class="line">            <span class="keyword">if</span> (g[t.ft][t.sd] &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 这个方向是墙</span></span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">            st[a][b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                area = <span class="built_in">max</span>(area, <span class="built_in">bfs</span>(i, j));</span><br><span class="line">                cnt ++ ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="山峰和山谷"><a href="#山峰和山谷" class="headerlink" title="山峰和山谷"></a>山峰和山谷</h2><p><a href="https://www.acwing.com/problem/content/1108/">原题链接</a></p><p>FGD小朋友特别喜欢爬山，在爬山的时候他就在研究山峰和山谷。</p><p>为了能够对旅程有一个安排，他想知道山峰和山谷的数量。</p><p>给定一个地图，为FGD想要旅行的区域，地图被分为 n×n 的网格，每个格子 (i,j) 的高度 w(i,j) 是给定的。</p><p>若两个格子有公共顶点，那么它们就是相邻的格子，如与 (i,j) 相邻的格子有(i−1,j−1),(i−1,j),(i−1,j+1),(i,j−1),(i,j+1),(i+1,j−1),(i+1,j),(i+1,j+1)。</p><p>我们定义一个格子的集合 S 为山峰（山谷）当且仅当：</p><ol><li>S 的所有格子都有相同的高度。</li><li>S 的所有格子都连通。</li><li>对于 s 属于 S，与 s 相邻的 s′ 不属于 S，都有 ws&gt;ws′（山峰），或者 ws&lt;ws′（山谷）。</li><li>如果周围不存在相邻区域，则同时将其视为山峰和山谷。</li></ol><p>你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。</p><p><strong>输入格式</strong></p><p>第一行包含一个正整数 n，表示地图的大小。</p><p>接下来一个 n×n 的矩阵，表示地图上每个格子的高度 w。</p><p><strong>输出格式</strong></p><p>共一行，包含两个整数，表示山峰和山谷的数量。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 1000,<br>0 ≤ w ≤ 109</p><p><strong>输入样例1</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">7</span> <span class="number">7</span> <span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>输出样例1</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输入样例2</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">6</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>输出样例2</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出不同地块的高度，高度相同的连通块周边高度都小于等于该连通块高度，那么该连通块为山峰，反之为山谷，问山峰山谷数量</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>依旧是遍历每一个点，如果没有遍历过该点，就遍历该点所在连通块，直到找到连通块边界，再判断这个连通块是否为山峰或山谷</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N][N];</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">bool</span>&amp; has_higher, <span class="type">bool</span>&amp; has_lower)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t.ft - <span class="number">1</span>; i &lt;= t.ft + <span class="number">1</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = t.sd - <span class="number">1</span>; j &lt;= t.sd + <span class="number">1</span>; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == t.ft &amp;&amp; j == t.sd) <span class="keyword">continue</span>; <span class="comment">// 遍历到自身</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">                <span class="keyword">if</span> (h[i][j] != h[t.ft][t.sd]) <span class="comment">// 边界</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (h[i][j] &gt; h[t.ft][t.sd]) has_higher = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> has_lower = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!st[i][j]) <span class="comment">// 非边界且未遍历</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                    st[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cin &gt;&gt; h[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> peak = <span class="number">0</span>, valley = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> has_higher = <span class="literal">false</span>, has_lower = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bfs</span>(i, j, has_higher, has_lower);</span><br><span class="line">                <span class="keyword">if</span> (!has_higher) peak ++ ;</span><br><span class="line">                <span class="keyword">if</span> (!has_lower) valley ++ ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; peak &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; valley &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> Flood Fill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】BFS中的最短路模型</title>
      <link href="/posts/922f99a.html"/>
      <url>/posts/922f99a.html</url>
      
        <content type="html"><![CDATA[<p>BFS可以解决边权为1的最短路问题，下面是相关例题</p><h1 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h1><p>将源点在开始时存进队列</p><h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><p><a href="https://www.acwing.com/problem/content/1078/">原题链接</a></p><p>给定一个 n×n 的二维数组，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maze[5][5] = &#123;</span><br><span class="line"></span><br><span class="line">0, 1, 0, 0, 0,</span><br><span class="line"></span><br><span class="line">0, 1, 0, 1, 0,</span><br><span class="line"></span><br><span class="line">0, 0, 0, 0, 0,</span><br><span class="line"></span><br><span class="line">0, 1, 1, 1, 0,</span><br><span class="line"></span><br><span class="line">0, 0, 0, 1, 0,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。</p><p>数据保证至少存在一条从左上角走到右下角的路径。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n。</p><p>接下来 n 行，每行包含 n 个整数 0 或 1，表示迷宫。</p><p><strong>输出格式</strong></p><p>输出从左上角到右下角的最短路线，如果答案不唯一，输出任意一条路径均可。</p><p>按顺序，每行输出一个路径中经过的单元格的坐标，左上角坐标为 (0,0)，右下角坐标为 (n−1,n−1)。</p><p><strong>数据范围</strong></p><p>0 ≤ n ≤ 1000</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个矩阵，0代表有路1代表没有路，问从左上角走到右下角的最短路径</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为边权均为1，所以利用BFS可以求出从起点到终点的最短路，同时利用一个小技巧从终点往起点走，即可在后续输出路径时正向输出</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line">PII pre[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 代表上下左右四个移动方向</span></span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            <span class="keyword">if</span> (g[a][b]) <span class="keyword">continue</span>; <span class="comment">// 没路</span></span><br><span class="line">            <span class="keyword">if</span> (pre[a][b].ft != <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 走过了</span></span><br><span class="line">            </span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">            pre[a][b] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>(n - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">PII <span class="title">end</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; end.ft &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; end.sd &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (end.ft == n - <span class="number">1</span> &amp;&amp; end.sd == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        end = pre[end.ft][end.sd];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="武士风度的牛"><a href="#武士风度的牛" class="headerlink" title="武士风度的牛"></a>武士风度的牛</h2><p><a href="https://www.acwing.com/problem/content/190/">原题链接</a></p><p>农民 John 有很多牛，他想交易其中一头被 Don 称为 The Knight 的牛。</p><p>这头牛有一个独一无二的超能力，在农场里像 Knight 一样地跳（就是我们熟悉的象棋中马的走法）。</p><p>虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个 x，y 的坐标图来表示。</p><p>这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了 The Knight 的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。</p><p>现在你的任务是，确定 The Knight 要想吃到草，至少需要跳多少次。</p><p>The Knight 的位置用 K 来标记，障碍的位置用 * 来标记，草的位置用 H 来标记。</p><p>这里有一个地图的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11 | . . . . . . . . . .</span><br><span class="line">10 | . . . . * . . . . . </span><br><span class="line"> 9 | . . . . . . . . . . </span><br><span class="line"> 8 | . . . * . * . . . . </span><br><span class="line"> 7 | . . . . . . . * . . </span><br><span class="line"> 6 | . . * . . * . . . H </span><br><span class="line"> 5 | * . . . . . . . . . </span><br><span class="line"> 4 | . . . * . . . * . . </span><br><span class="line"> 3 | . K . . . . . . . . </span><br><span class="line"> 2 | . . . * . . . . . * </span><br><span class="line"> 1 | . . * . . . . * . . </span><br><span class="line"> 0 ----------------------</span><br><span class="line">                       1 </span><br><span class="line">   0 1 2 3 4 5 6 7 8 9 0 </span><br></pre></td></tr></table></figure><p>The Knight 可以按照下图中的 A,B,C,D… 这条路径用 5 次跳到草的地方（有可能其它路线的长度也是 5）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11 | . . . . . . . . . .</span><br><span class="line">10 | . . . . * . . . . .</span><br><span class="line"> 9 | . . . . . . . . . .</span><br><span class="line"> 8 | . . . * . * . . . .</span><br><span class="line"> 7 | . . . . . . . * . .</span><br><span class="line"> 6 | . . * . . * . . . F&lt;</span><br><span class="line"> 5 | * . B . . . . . . .</span><br><span class="line"> 4 | . . . * C . . * E .</span><br><span class="line"> 3 | .&gt;A . . . . D . . .</span><br><span class="line"> 2 | . . . * . . . . . *</span><br><span class="line"> 1 | . . * . . . . * . .</span><br><span class="line"> 0 ----------------------</span><br><span class="line">                       1</span><br><span class="line">   0 1 2 3 4 5 6 7 8 9 0</span><br></pre></td></tr></table></figure><p>注意： 数据保证一定有解。</p><p><strong>输入格式</strong></p><p>第 1 行： 两个数，表示农场的列数 C 和行数 R。</p><p>第 2..R+1 行: 每行一个由 C 个字符组成的字符串，共同描绘出牧场地图。</p><p><strong>输出格式</strong></p><p>一个整数，表示跳跃的最小次数。</p><p><strong>数据范围</strong></p><p>1 ≤ R , C ≤ 150</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">11</span></span><br><span class="line">..........</span><br><span class="line">....*.....</span><br><span class="line">..........</span><br><span class="line">...*.*....</span><br><span class="line">.......*..</span><br><span class="line">..*..*...H</span><br><span class="line">*.........</span><br><span class="line">...*...*..</span><br><span class="line">.K........</span><br><span class="line">...*.....*</span><br><span class="line">..*....*..</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>图中<code>*</code>代表没有路，<code>.</code>代表有路，求以日字型从K走到H的最短路</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>dx dy改成向八个不同方向移，其余思路一样，第一次遍历到H时输出即可</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">155</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图</span></span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// 记录距离+判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">                x = i, y = j;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[x][y] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>; <span class="comment">// 没路</span></span><br><span class="line">            <span class="keyword">if</span> (dist[a][b] != <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 已遍历</span></span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;H&#x27;</span>) <span class="keyword">return</span> dist[t.ft][t.sd] + <span class="number">1</span>; <span class="comment">// 走到终点</span></span><br><span class="line"></span><br><span class="line">            dist[a][b] = dist[t.ft][t.sd] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抓住那头牛"><a href="#抓住那头牛" class="headerlink" title="抓住那头牛"></a>抓住那头牛</h2><p><a href="https://www.acwing.com/problem/content/1102/">原题链接</a></p><p>农夫知道一头牛的位置，想要抓住它。</p><p>农夫和牛都位于数轴上，农夫起始位于点 N，牛位于点 K。</p><p>农夫有两种移动方式：</p><ol><li>从 X 移动到 X−1 或 X+1，每次移动花费一分钟</li><li>从 X 移动到 2∗X，每次移动花费一分钟</li></ol><p>假设牛没有意识到农夫的行动，站在原地不动。</p><p>农夫最少要花多少时间才能抓住牛？</p><p><strong>输入格式</strong></p><p>共一行，包含两个整数N和K。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示抓到牛所花费的最少时间。</p><p><strong>数据范围</strong></p><p>0 ≤ N , K ≤ 105</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">17</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>要求从N到K，每次只能进行一个操作：向右一步 &#x2F; 向左一步 &#x2F; 坐标变为现在的两倍，求最短路</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这一题刚开始看第一反应是dp，但后来发现BFS最短路来做也很简单</p><p>每次更新所有该轮操作可以到达的位置</p><p>无需更新负值，因为只能通过-1到达负值，而从负值到正值只能通过+1，二者相互抵消，不可能是最短路</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[n] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t == k) <span class="keyword">return</span> dist[k]; <span class="comment">// 已到终点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新三个距离</span></span><br><span class="line">        <span class="keyword">if</span> (t + <span class="number">1</span> &lt; N &amp;&amp; dist[t + <span class="number">1</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t + <span class="number">1</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t - <span class="number">1</span> &lt; N &amp;&amp; dist[t - <span class="number">1</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t - <span class="number">1</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t * <span class="number">2</span> &lt; N &amp;&amp; dist[t * <span class="number">2</span>] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[t * <span class="number">2</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h1><p>设置虚拟源点，到所有源点的距离都为0，也就是在起始时将每一个起点都存进队列</p><h2 id="矩阵距离"><a href="#矩阵距离" class="headerlink" title="矩阵距离"></a>矩阵距离</h2><p><a href="https://www.acwing.com/problem/content/175/">原题链接</a></p><p>给定一个 N 行 M 列的 01 矩阵 A，A[i][j] 与 A[k][l] 之间的曼哈顿距离定义为：</p><p><code>dist(A[i][j], A[k][l]) = |i − k| + |j − l|</code></p><p>输出一个 N 行 M 列的整数矩阵 B，其中：</p><p><code>B[i][j] = min~1≤x≤N,1≤y≤M,A[x][y]=1~ dist(A[i][j], A[x][y])</code></p><p><strong>输入格式</strong></p><p>第一行两个整数 N,M。</p><p>接下来一个 N 行 M 列的 01 矩阵，数字之间没有空格。</p><p><strong>输出格式</strong></p><p>一个 N 行 M 列的矩阵 B，相邻两个整数之间用一个空格隔开。</p><p><strong>数据范围</strong></p><p>1 ≤ N, M ≤ 1000</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">0001</span></span><br><span class="line"><span class="number">0011</span></span><br><span class="line"><span class="number">0110</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个矩阵，求所有0距离最近的1的曼哈顿距离</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>设置虚拟源点，先将所有的1入队，更新所有0到达1的最短距离输出即可</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 所有源点入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            <span class="keyword">if</span> (dist[a][b] != <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 已被遍历</span></span><br><span class="line"></span><br><span class="line">            dist[a][b] = dist[t.ft][t.sd] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            cout &lt;&lt; dist[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双端队列BFS"><a href="#双端队列BFS" class="headerlink" title="双端队列BFS"></a>双端队列BFS</h1><h2 id="电路维修"><a href="#电路维修" class="headerlink" title="电路维修"></a>电路维修</h2><p><a href="https://www.acwing.com/problem/content/177/">原题链接</a></p><p>达达是来自异世界的魔女，她在漫无目的地四处漂流的时候，遇到了善良的少女翰翰，从而被收留在地球上。</p><p>翰翰的家里有一辆飞行车。</p><p>有一天飞行车的电路板突然出现了故障，导致无法启动。</p><p>电路板的整体结构是一个 R 行 C 列的网格（R,C≤500），如下图所示。</p><img src="/posts/undefined/1.png" class><p>每个格点都是电线的接点，每个格子都包含一个电子元件。</p><p>电子元件的主要部分是一个可旋转的、连接一条对角线上的两个接点的短电缆。</p><p>在旋转之后，它就可以连接另一条对角线的两个接点。</p><p>电路板左上角的接点接入直流电源，右下角的接点接入飞行车的发动装置。</p><p>达达发现因为某些元件的方向不小心发生了改变，电路板可能处于断路的状态。</p><p>她准备通过计算，旋转最少数量的元件，使电源与发动装置通过若干条短缆相连。</p><p>不过，电路的规模实在是太大了，达达并不擅长编程，希望你能够帮她解决这个问题。</p><p>注意：只能走斜向的线段，水平和竖直线段不能走。</p><p><strong>输入格式</strong></p><p>输入文件包含多组测试数据。</p><p>第一行包含一个整数 T，表示测试数据的数目。</p><p>对于每组测试数据，第一行包含正整数 R 和 C，表示电路板的行数和列数。</p><p>之后 R 行，每行 C 个字符，字符是”&#x2F;“和”&quot;中的一个，表示标准件的方向。</p><p><strong>输出格式</strong></p><p>对于每组测试数据，在单独的一行输出一个正整数，表示所需的最小旋转次数。</p><p>如果无论怎样都不能使得电源和发动机之间连通，输出 NO SOLUTION。</p><p><strong>数据范围</strong></p><p>1 ≤ R , C ≤ 500,<br>1 ≤ T ≤ 5</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line">\\/\\</span><br><span class="line">\\<span class="comment">///</span></span><br><span class="line">/\\\\</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>样例解释</strong></p><p>样例的输入对应于题目描述中的情况。</p><p>只需要按照下面的方式旋转标准件，就可以使得电源和发动机之间连通。</p><img src="/posts/undefined/2.png" class><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>从左上角走到右下角，只能走斜线，使斜线方向改变需要消耗1，问消耗最少的路径</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>首先转换一些题目语言，我们可以理解为，不需要改变斜线方向时边权是0，需要改变斜线方向时边权是1，那这个问题就转换成了边权是0 &#x2F; 1 的最短路问题，用Dijkstra是可以解决的</p><p>那能不能用BFS解决呢？</p><p>当然也可以，考虑到BFS中队列的二段性，本题我们使用双端队列，每次将边权为0的边放到队头，边权为1的边放到队尾（感觉有点贪心的思想）</p><p>（另外，绝对不会出现一条边未转换时走一次，然后转换了再走一次的情况，因为图中总有一半的点是走不到的</p><p>接下来的难点在于图的存储，需要对点和格子分别作出记录</p><h3 id="代码（加了注释）"><a href="#代码（加了注释）" class="headerlink" title="代码（加了注释）"></a>代码（加了注释）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图上的每条边</span></span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// 存每个点到起点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    deque&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cs[] = <span class="string">&quot;\\/\\/&quot;</span>; <span class="comment">// 分别表示往左上角、右上角、右下角、左下角走</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;; <span class="comment">// 进行这些操作点坐标的改变</span></span><br><span class="line">    <span class="type">int</span> ix[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, iy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 进行这些操作需要踩过哪些格子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[t.ft][t.sd]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t.ft][t.sd] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.ft + dx[i], b = t.sd + dy[i]; <span class="comment">// 点坐标</span></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt; n || b &lt; <span class="number">0</span> || b &gt; m) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> aa = t.ft + ix[i], bb = t.sd + iy[i]; <span class="comment">// 格子坐标</span></span><br><span class="line">            <span class="type">int</span> d = dist[t.ft][t.sd] + (g[aa][bb] != cs[i]); <span class="comment">// 原有距离加上当前格子的边权</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d &lt; dist[a][b]) <span class="comment">// 如果距离更小就更新</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[a][b] = d;</span><br><span class="line">                <span class="comment">// 根据边权情况选择加入队头or队尾</span></span><br><span class="line">                <span class="keyword">if</span> (g[aa][bb] != cs[i]) q.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_front</span>(&#123;a, b&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">&quot;NO SOLUTION\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】最小步数（双向广搜与A*算法）</title>
      <link href="/posts/e9a0dd50.html"/>
      <url>/posts/e9a0dd50.html</url>
      
        <content type="html"><![CDATA[<h1 id="最小步数"><a href="#最小步数" class="headerlink" title="最小步数"></a>最小步数</h1><h2 id="魔板"><a href="#魔板" class="headerlink" title="魔板"></a>魔板</h2><p><a href="https://www.acwing.com/problem/content/1109/">原题链接</a></p><p>Rubik 先生在发明了风靡全球的魔方之后，又发明了它的二维版本——魔板。</p><p>这是一张有 8 个大小相同的格子的魔板：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">8 7 6 5</span><br></pre></td></tr></table></figure><p>我们知道魔板的每一个方格都有一种颜色。</p><p>这 8 种颜色用前 8 个正整数来表示。</p><p>可以用颜色的序列来表示一种魔板状态，规定从魔板的左上角开始，沿顺时针方向依次取出整数，构成一个颜色序列。</p><p>对于上图的魔板状态，我们用序列 (1,2,3,4,5,6,7,8) 来表示，这是基本状态。</p><p>这里提供三种基本操作，分别用大写字母 A，B，C 来表示（可以通过这些操作改变魔板的状态）：</p><p>A：交换上下两行；<br>B：将最右边的一列插入到最左边；<br>C：魔板中央对的4个数作顺时针旋转。</p><p>下面是对基本状态进行操作的示范：</p><p>A：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 7 6 5</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><p>B：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1 2 3</span><br><span class="line">5 8 7 6</span><br></pre></td></tr></table></figure><p>C：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 7 2 4</span><br><span class="line">8 6 3 5</span><br></pre></td></tr></table></figure><p>对于每种可能的状态，这三种基本操作都可以使用。</p><p>你要编程计算用最少的基本操作完成基本状态到特殊状态的转换，输出基本操作序列。</p><p>注意：数据保证一定有解。</p><p><strong>输入格式</strong></p><p>输入仅一行，包括 8 个整数，用空格分开，表示目标状态。</p><p><strong>输出格式</strong></p><p>输出文件的第一行包括一个整数，表示最短操作序列的长度。</p><p>如果操作序列的长度大于0，则在第二行输出字典序最小的操作序列。</p><p><strong>数据范围</strong></p><p>输入数据中的所有数字均为 1 到 8 之间的整数。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line">BCABCCB</span><br></pre></td></tr></table></figure><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个原始状态，问怎么经过最少步骤转换成特殊状态，以及转换步骤是什么</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路比较简单但是代码实现有难度，依然是把原始状态先入队，然后每次更新队头序列可以进行的操作<br>每个操作直接打表更简单</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[<span class="number">10</span>];</span><br><span class="line">string endd;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; dist; <span class="comment">// 存储每一个状态到最终状态的距离</span></span><br><span class="line">map&lt;string, pair&lt;<span class="type">char</span>, string&gt; &gt; pre; <span class="comment">// 存储从后一个状态到前一个状态的具体操作</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">get</span><span class="params">(string t, <span class="type">int</span> op)</span> <span class="comment">// 模拟每个操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string k;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">0</span>) k = &#123;t[<span class="number">4</span>], t[<span class="number">5</span>], t[<span class="number">6</span>], t[<span class="number">7</span>], t[<span class="number">0</span>], t[<span class="number">1</span>], t[<span class="number">2</span>], t[<span class="number">3</span>]&#125;;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) k = &#123;t[<span class="number">3</span>], t[<span class="number">0</span>], t[<span class="number">1</span>], t[<span class="number">2</span>], t[<span class="number">7</span>], t[<span class="number">4</span>], t[<span class="number">5</span>], t[<span class="number">6</span>]&#125;;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">2</span>) k = &#123;t[<span class="number">0</span>], t[<span class="number">5</span>], t[<span class="number">1</span>], t[<span class="number">3</span>], t[<span class="number">4</span>], t[<span class="number">6</span>], t[<span class="number">2</span>], t[<span class="number">7</span>]&#125;;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;12348765&quot;</span>;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t == endd) <span class="keyword">return</span> dist[t];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ ) <span class="comment">// 更新每个操作后的新序列</span></span><br><span class="line">        &#123;</span><br><span class="line">            string s = <span class="built_in">get</span>(t, i);</span><br><span class="line">            <span class="keyword">if</span> (!dist.<span class="built_in">count</span>(s))</span><br><span class="line">            &#123;</span><br><span class="line">                dist[s] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                pre[s] = &#123;<span class="string">&#x27;A&#x27;</span> + i, t&#125;;</span><br><span class="line">                q.<span class="built_in">push</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start = <span class="string">&quot;12348765&quot;</span>, ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">reverse</span>(a + <span class="number">5</span>, a + <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i ++ ) endd.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (endd != start)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += pre[endd].first;</span><br><span class="line">        endd = pre[endd].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双向广搜"><a href="#双向广搜" class="headerlink" title="双向广搜"></a>双向广搜</h1><p>因为BFS越到后面，每一层可以扩展的情况越多（会成指数型增长），为了防止TLE &#x2F; MLE，可以用双向广搜对其进行优化</p><p>从两端开始搜索，到中间相遇，使得搜索次数降低，避免了中间大部分不必要的搜索环节</p><h2 id="字串变换"><a href="#字串变换" class="headerlink" title="字串变换"></a>字串变换</h2><p><a href="https://www.acwing.com/problem/content/192/">原题链接</a></p><p>已知有两个字串 A, B 及一组字串变换的规则（至多 6 个规则）:</p><p>A1→B1<br>A2→B2<br>…</p><p>规则的含义为：在 A 中的子串 A1 可以变换为 B1、A2 可以变换为 B2…。</p><p>例如：A＝abcd B＝xyz</p><p>变换规则为：<br>abc → xu ud → y y → yz</p><p>则此时，A 可以经过一系列的变换变为 B，其变换的过程为：</p><p>abcd → xud → xy → xyz</p><p>共进行了三次变换，使得 A 变换为 B。</p><p>注意，一次变换只能变换一个子串，例如 A＝aa B＝bb</p><p>变换规则为：</p><p>a → b</p><p>此时，不能将两个 a 在一步中全部转换为 b，而应当分两步完成。</p><p><strong>输入格式</strong></p><p>输入格式如下：<br>A B<br>A1 B1<br>A2 B2<br>… …</p><p>第一行是两个给定的字符串 A 和 B。</p><p>接下来若干行，每行描述一组字串变换的规则。</p><p>所有字符串长度的上限为 20。</p><p><strong>输出格式</strong></p><p>若在 10 步（包含 10 步）以内能将 A 变换为 B ，则输出最少的变换步数；否则输出 NO ANSWER!。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">abcd xyz</span><br><span class="line">abc xu</span><br><span class="line">ud y</span><br><span class="line">y yz</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>一个字符串想转变成另一个字符串，现在给出若干个变换规则（某个字串可以转换成另一个字串），问最少的步骤数目是多少</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>从开始和结尾两个字符串同时往中间搜索，搜索过程中相遇就直接输出，具体看代码注释</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string A, B;</span><br><span class="line">string a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(queue&lt;string&gt;&amp; q, unordered_map&lt;string, <span class="type">int</span>&gt;&amp; da, unordered_map&lt;string, <span class="type">int</span>&gt;&amp; db, string a[N], string b[N])</span> <span class="comment">// 要处理da 从a-&gt;b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = da[q.<span class="built_in">front</span>()];</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; da[q.<span class="built_in">front</span>()] == d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 遍历每个规则</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t.<span class="built_in">size</span>(); j ++ ) <span class="comment">// 遍历每个元素作为开头</span></span><br><span class="line">                <span class="keyword">if</span> (t.<span class="built_in">substr</span>(j, a[i].<span class="built_in">size</span>()) == a[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    string r = t.<span class="built_in">substr</span>(<span class="number">0</span>, j) + b[i] + t.<span class="built_in">substr</span>(j + a[i].<span class="built_in">size</span>()); <span class="comment">// 记录新字符串</span></span><br><span class="line">                    <span class="keyword">if</span> (db.<span class="built_in">count</span>(r)) <span class="keyword">return</span> da[t] + db[r] + <span class="number">1</span>; <span class="comment">// 在另一个里找到了，直接输出</span></span><br><span class="line">                    <span class="keyword">if</span> (da.<span class="built_in">count</span>(r)) <span class="keyword">continue</span>; <span class="comment">// 在自己里找到了，说明重复了直接开始下一次循环</span></span><br><span class="line">                    da[r] = da[t] + <span class="number">1</span>; <span class="comment">// 更新距离</span></span><br><span class="line">                    q.<span class="built_in">push</span>(r); <span class="comment">// 新字符串入队</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == B) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    queue&lt;string&gt; qa, qb; <span class="comment">// qa qb两个队列同时搜索</span></span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; da, db; <span class="comment">// 不同字符串到起始字符串的步骤数</span></span><br><span class="line"></span><br><span class="line">    qa.<span class="built_in">push</span>(A), qb.<span class="built_in">push</span>(B); <span class="comment">// 队头入队</span></span><br><span class="line">    da[A] = db[B] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (qa.<span class="built_in">size</span>() &amp;&amp; qb.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="comment">// 每次对队列长的那边进行操作</span></span><br><span class="line">        <span class="keyword">if</span> (qa.<span class="built_in">size</span>() &lt; qb.<span class="built_in">size</span>()) t = <span class="built_in">extend</span>(qa, da, db, a, b);</span><br><span class="line">        <span class="keyword">else</span> t = <span class="built_in">extend</span>(qb, db, da, b, a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t &lt;= <span class="number">10</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">if</span> ( ++ step == <span class="number">10</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a[n] &gt;&gt; b[n]) n ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">-1</span>) cout &lt;&lt; <span class="string">&quot;NO ANSWER!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h1><p>A*与双向广搜解决的问题类似，利用<strong>估价函数</strong>，在非常少的步骤内从一个状态到达另一个状态</p><p>可以解决任何边权的问题，只要没有负权回路</p><p>步骤：</p><ol><li>把BFS中的队列换成优先队列（小根堆），队列中存的是从起点到当前点的真实距离（不一定是最短距离）和从当前点到终点的估计距离（<del>算法的尽头是玄学</del>），优先队列排序的依据是存储的两个距离相加，也就是从起点到终点的估计距离</li><li>取出优先队列队头（也就是估计距离最短的点）</li><li>for循环 t 的所有邻边，能更新的话就更新并将邻边入队</li><li>当终点第一次出队时break</li></ol><p>（和Dijkstra非常像，可以看为Dijkstra中所有从当前点到终点的估计距离都取0（（但本质上没什么关系</p><p><strong>必须要保证当前点到终点的估计距离一定要小于等于真实距离，并且要保证有解（否则效率很低）</strong></p><p>A*只能保证终点距离起点是最优的，不能保证其他点第一次出队时也是最优的，除了终点外，每个点不一定只扩展一次</p><h2 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h2><p><a href="https://www.acwing.com/problem/content/181/">原题链接</a></p><p>在一个 3×3 的网格中，1∼8 这 8 个数字和一个 X 恰好不重不漏地分布在这 3×3 的网格中。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">X 4 6</span><br><span class="line">7 5 8</span><br></pre></td></tr></table></figure><p>在游戏过程中，可以把 X 与其上、下、左、右四个方向之一的数字交换（如果存在）。</p><p>我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 X</span><br></pre></td></tr></table></figure><p>例如，示例中图形就可以通过让 X 先后与右、下、右三个方向的数字交换成功得到正确排列。</p><p>交换过程如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3   1 2 3   1 2 3   1 2 3</span><br><span class="line">X 4 6   4 X 6   4 5 6   4 5 6</span><br><span class="line">7 5 8   7 5 8   7 X 8   7 8 X</span><br></pre></td></tr></table></figure><p>把 X 与上下左右方向数字交换的行动记录为 u、d、l、r。</p><p>现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列。</p><p><strong>输入格式</strong></p><p>输入占一行，将 3×3 的初始网格描绘出来。</p><p>例如，如果初始网格如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">x 4 6 </span><br><span class="line">7 5 8 </span><br></pre></td></tr></table></figure><p>则输入为：<code>1 2 3 x 4 6 7 5 8</code></p><p><strong>输出格式</strong></p><p>输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。</p><p>如果答案不唯一，输出任意一种合法方案即可。</p><p>如果不存在解决方案，则输出 <code>unsolvable</code>。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">5</span>  x  <span class="number">7</span>  <span class="number">6</span>  <span class="number">8</span> </span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ullddrurdllurdruldr</span><br></pre></td></tr></table></figure><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>每次可以修改一个数字上下左右移动，输出一个从给定状态转化到标准状态的最少步骤</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>首先，怎么判断是否有解？</p><p>我们将九宫格中的数字转换成字符串，每次将数字左右移动时，字符串中的逆序对数量不变，上下移动时，逆序对数量总是改变2，所以奇偶性不变<br>我们知道最终要求的状态的逆序对是偶数，所以看初始状态的逆序对数量，是偶数就一定有解，是奇数就一定无解</p><p>然后是最关键的问题：怎么设计估计函数？</p><p>注意到每次移动，最好的情况是将移动的数字向目标位置移动一格，因此估价函数可以取当前的每一个数字和最终目标位置之间的曼哈顿距离之和（这样可以保证估计值一定小于等于真实值）</p><h3 id="代码（＋详细注释）"><a href="#代码（＋详细注释）" class="headerlink" title="代码（＋详细注释）"></a>代码（＋详细注释）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, string&gt; PIS;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(string state)</span> <span class="comment">// 估价函数（曼哈顿距离）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        <span class="keyword">if</span> (state[i] != <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = state[i] - <span class="string">&#x27;1&#x27;</span>; <span class="comment">// 转换成数字</span></span><br><span class="line">            res += <span class="built_in">abs</span>(i / <span class="number">3</span> - t / <span class="number">3</span>) + <span class="built_in">abs</span>(i % <span class="number">3</span> - t % <span class="number">3</span>); <span class="comment">// 计算曼哈顿距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">bfs</span><span class="params">(string start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string end = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">    <span class="type">char</span> op[] = <span class="string">&quot;urdl&quot;</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; dist; <span class="comment">// 记录每个状态距离初始状态的步数</span></span><br><span class="line">    unordered_map&lt;string, pair&lt;<span class="type">char</span>, string&gt; &gt; prev; <span class="comment">// 前一个字符串是由后一个字符串经过什么操作得来的</span></span><br><span class="line">    priority_queue&lt;PIS, vector&lt;PIS&gt;, greater&lt;PIS&gt; &gt; heap; <span class="comment">// 第一个参数是估计距离 第二个参数是当前状态</span></span><br><span class="line"></span><br><span class="line">    dist[start] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="built_in">f</span>(start), start&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>(); <span class="comment">// 取出队头元素</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        string state = t.sd; <span class="comment">// 当前状态</span></span><br><span class="line">        <span class="keyword">if</span> (state == end) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x, y; <span class="comment">// xy表示空位的坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (state[i] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x = i / <span class="number">3</span>, y = i % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        string source = state; <span class="comment">// 记录当前状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) <span class="comment">// 遍历四个操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = x + dx[i], b = y + dy[i]; <span class="comment">// 操作后坐标</span></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= <span class="number">3</span> || b &lt; <span class="number">0</span> || b &gt;= <span class="number">3</span>) <span class="keyword">continue</span>; <span class="comment">// 位置不合法</span></span><br><span class="line">            state = source; <span class="comment">// 将state在每个操作前恢复至初始状态</span></span><br><span class="line">            <span class="built_in">swap</span>(state[x * <span class="number">3</span> + y], state[a * <span class="number">3</span> + b]); <span class="comment">// 修改操作后字符窜</span></span><br><span class="line">            <span class="keyword">if</span> (!dist.<span class="built_in">count</span>(state) || dist[state] &gt; dist[source] + <span class="number">1</span>) <span class="comment">// 没更新过或者有更优解</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[state] = dist[source] + <span class="number">1</span>; <span class="comment">// 更新距离</span></span><br><span class="line">                prev[state] = &#123;op[i], source&#125;; <span class="comment">// 记录操作</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[state] + <span class="built_in">f</span>(state), state&#125;); <span class="comment">// 存进优先队列中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res; <span class="comment">// 记录操作字符串</span></span><br><span class="line">    <span class="keyword">while</span> (end != start)</span><br><span class="line">    &#123;</span><br><span class="line">        res += prev[end].ft;</span><br><span class="line">        end = prev[end].sd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start, seq;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        start += c;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;x&#x27;</span>) seq += c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 逆序对数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; <span class="number">8</span>; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (seq[i] &gt; seq[j]) cnt ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;unsolvable\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">bfs</span>(start) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第K短路"><a href="#第K短路" class="headerlink" title="第K短路"></a>第K短路</h2><p><a href="https://www.acwing.com/problem/content/180/">原题链接</a></p><p>给定一张 N 个点（编号 1,2…N），M 条边的有向图，求从起点 S 到终点 T 的第 K 短路的长度，路径允许重复经过点或边。</p><p>注意： 每条最短路中至少要包含一条边。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 N 和 M。</p><p>接下来 M 行，每行包含三个整数 A,B 和 L，表示点 A 与点 B 之间存在有向边，且边长为 L。</p><p>最后一行包含三个整数 S,T 和 K，分别表示起点 S，终点 T 和第 K 短路。</p><p><strong>输出格式</strong></p><p>输出占一行，包含一个整数，表示第 K 短路的长度，如果第 K 短路不存在，则输出 −1。</p><p><strong>数据范围</strong></p><p>1 ≤ S , T ≤ N ≤ 1000,<br>0 ≤ M ≤ 104,<br>1 ≤ K ≤ 1000,<br>1 ≤ L ≤ 100</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>找到起点到终点第k短的路径</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这一题和之前不同的地方在于，之前只有需要更新距离的时候才将点存进队列，现在不管是否需要更新距离，都要存进队列</p><p>估价函数：从起点到终点的最短路（用Dijkstra求）（这样就可以保证估计距离小于等于真实距离）</p><p>之前求最短路的时候我们认为终点第一次从队列中弹出时是最小值，在这里第k次从队列中弹出时是第k小值（因为每个点最多只能走不超过K次）（可以证明）</p><h3 id="代码（-详细注释）"><a href="#代码（-详细注释）" class="headerlink" title="代码（ + 详细注释）"></a>代码（ + 详细注释）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, PII&gt; PIII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ft first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd second </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, S, T, K;</span><br><span class="line"><span class="type">int</span> h[N], rh[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 判重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap; <span class="comment">// 第二个参数是点 第一个参数是第二个参数到终点的距离</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, T&#125;); <span class="comment">// 终点入队</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[T] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.sd; <span class="comment">// 记录当前遍历的点</span></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = rh[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i]) <span class="comment">// 不是最优解就更新距离并入队</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">astar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt; &gt; heap; <span class="comment">// 第一个参数是估计距离 第二个参数中 ft:到起始点的距离 sd:当前点</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;dist[S], &#123;<span class="number">0</span>, S&#125;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.sd.sd, distance = t.sd.ft; <span class="comment">// distance是到起点的真实距离</span></span><br><span class="line">        cnt[ver] ++ ; <span class="comment">// 第几次遍历该点</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[T] == K) <span class="keyword">return</span> distance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i]) <span class="comment">// 遍历所有邻接点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt[j] &lt; K) <span class="comment">// 没遍历k次以上的就入队</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;distance + w[i] + dist[j], &#123;distance + w[i], j&#125;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(rh, <span class="number">-1</span>, <span class="keyword">sizeof</span> rh);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(h, a, b, c); <span class="comment">// 存正向边</span></span><br><span class="line">        <span class="built_in">add</span>(rh, b, a, c); <span class="comment">// 存反向边（因为dijkstra里需要计算所有点到终点的最短路</span></span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; S &gt;&gt; T &gt;&gt; K;</span><br><span class="line">    <span class="keyword">if</span> (S == T) K ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">astar</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 最小步数 </tag>
            
            <tag> 双向广搜 </tag>
            
            <tag> A* </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】莫队</title>
      <link href="/posts/3dab568c.html"/>
      <url>/posts/3dab568c.html</url>
      
        <content type="html"><![CDATA[<p>这篇博客起源于本人把一道 $pow(2,n)$ 的问题考虑成求组合数前缀和的问题qwq，于是接触到了这个新算法来总结一下</p><p>参考自<a href="https://www.cnblogs.com/WAMonster/p/10118934.html#!comments">这篇文章</a>，写得太好了</p><p>首先是一道<a href="https://www.luogu.com.cn/problem/SP3267">模板题</a></p><p>题目意思是，给出一个数组a，再给出多个区间，问这些区间里分别有多少不一样的数字</p><p>焗个栗子：</p><img src="/posts/3dab568c/1.jpg" class><p>比如给出的是这样一个数组，询问的两个区间是红色和绿色标注的区间</p><p>如果我们分别遍历每一个区间，复杂度就太高了，因此就有大佬提出这样一种算法——</p><p>首先定义双指针 $l$、$r$，初始化为 $l&#x3D;0,r&#x3D;-1$（表示此时区间内没有任何元素），然后用<code>unorderd_map&lt;int, int&gt; map</code>存储当前区间内每个元素的个数</p><p>看我们要求的第一个区间 $[0,5]$</p><p>$l$ 此时等于$0$，和所求区间的左端点相同，因此无需移动</p><p>$r$ 此时等于$-1$，在所求区间右端点的左侧，因此需要向右移</p><p>首先向右移一位变成 $0$，此时区间内添加了一个元素 5,因为<code>map[5] = 0</code>，元素5不存在于原来的区间里，因此元素种类数<code>cnt</code>加一，<code>map[5] ++ </code></p><p>然后 $r$ 再右移一位变成 1，此时区间内添加了一个元素 7,因为<code>map[7] = 0</code>，元素7不存在于原来的区间里，因此元素种类数<code>cnt</code>加一，<code>map[7] ++ </code></p><p>依此类推，直到 $r$ 右移到了 5，此时区间内添加了一个元素 7，但是添加前的<code>map[7] = 1</code>，添加了当前的 7 并不会让区间内元素的个数增多，因此<code>cnt</code>无需改变，<code>map[7] ++</code></p><p>之后从红色区间挪到绿色区间的操作也是类似的</p><p>上文介绍了如何往区间内添加数，当然，删除一个数的操作也是类似的，只不过添加数时，我们要先看被添加的数有没有出现在原来的区间里，也就是<code>map[x]</code>是否等于0，如果等于0说明不存在于原来的区间，区间内元素种类数<code>cnt</code>才能加一，而删除数时，我们要先把当前数删除，也就是<code>map[x]</code>减一，然后再判断当前区间里还有没有x，如果没有x也就是<code>map[x] == 0</code>，那么区间内元素种类数<code>cnt</code>减一</p><p><strong>code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!map[a[pos]]) cnt ++ ; <span class="comment">// 在区间中新出现，总数要+1</span></span><br><span class="line">    map[a[pos]] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map[a[pos]] -- ;</span><br><span class="line">    <span class="keyword">if</span> (!map[a[pos]]) cnt -- ; <span class="comment">// 在区间中不再出现，总数要-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入询问区间的左右端点</span></span><br><span class="line">        <span class="type">int</span> ql, qr;</span><br><span class="line">        cin &gt;&gt; ql &gt;&gt; qr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; ql) <span class="built_in">del</span>(l++); <span class="comment">// 如左指针在查询区间左方，左指针向右移直到与查询区间左端点重合</span></span><br><span class="line">        <span class="keyword">while</span> (l &gt; ql) <span class="built_in">add</span>(--l); <span class="comment">// 如左指针在查询区间左端点右方，左指针左移</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; qr) <span class="built_in">add</span>(++r); <span class="comment">// 右指针在查询区间右端点左方，右指针右移</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; qr) <span class="built_in">del</span>(r--);        <span class="comment">// 否则左移</span></span><br><span class="line">        cout &lt;&lt; cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就 <del>结束啦</del> qwq</p><p>才怪</p><p>还可以对这个算法继续优化</p><p> <strong>莫队算法优化的核心是&#x3D;&#x3D;分块&#x3D;&#x3D;和&#x3D;&#x3D;排序&#x3D;&#x3D;</strong></p><p>把长度为 $n$ 的序列分成 $\sqrt{n}$ 个块，然后按照左端点所在的块排序，如果左端点在同一个块内，则按右端点排序</p><p><strong>优化1</strong><br>这种排序方法也可以接着优化：如果左端点在同一奇数块内，则按右端点从小到大排序，如果左端点在同一偶数块内，则按右端点从大到小排序，这样排序是为了减少右端点移动的次数进而提高效率）</p><p><strong>优化2</strong><br>听说开O2优化能产生奇妙反应，实在没办法了可以考虑考虑这个</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br></pre></td></tr></table></figure><p><strong>优化3</strong><br>某佬把上面的一长串代码简化成了下面这样</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; ql) cnt -= !--map[a[l++]];</span><br><span class="line"><span class="keyword">while</span>(l &gt; ql) cnt += !map[a[--l]]++;</span><br><span class="line"><span class="keyword">while</span>(r &lt; qr) cnt += !map[a[++r]]++;</span><br><span class="line"><span class="keyword">while</span>(r &gt; qr) cnt -= !--map[a[r--]];</span><br></pre></td></tr></table></figure><p>于是模板题的代码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; PPI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="type">int</span> bnum = <span class="built_in">ceil</span>((<span class="type">double</span>)n / size); <span class="comment">// 把序列分成了多少块</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">belong</span><span class="params">(<span class="number">1e6</span> + <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bnum; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = (i - <span class="number">1</span>) * size + <span class="number">1</span>; j &lt;= i * size; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            belong[j] = i; <span class="comment">// 标记每个元素属于哪个块</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;PPI&gt; <span class="title">q</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; q[i].first.first &gt;&gt; q[i].first.second;</span><br><span class="line">        q[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">bool</span>(PPI a, PPI b)&gt; cmp = [&amp;](PPI a, PPI b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// return (belong[a.first.first] ^ belong[b.first.first]) ? belong[a.first.first] &lt; belong[b.first.first] : ((belong[a.first.first] &amp; 1) ? a.first.second &lt; b.first.second : a.first.second &gt; b.first.second);</span></span><br><span class="line">        <span class="keyword">if</span> (belong[a.first.first] != belong[b.first.first]) <span class="keyword">return</span> belong[a.first.first] &lt; belong[b.first.first];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (belong[a.first.first] % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> belong[a.first.second] &lt; belong[b.first.second];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> belong[a.first.second] &gt; belong[b.first.second];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ql = q[i].first.first, qr = q[i].first.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; ql) cnt -= !--map[a[l ++ ]];</span><br><span class="line">        <span class="keyword">while</span>(l &gt; ql) cnt += !map[a[-- l]] ++;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; qr) cnt += !map[a[++ r]] ++;</span><br><span class="line">        <span class="keyword">while</span>(r &gt; qr) cnt -= !--map[a[r -- ]];</span><br><span class="line"></span><br><span class="line">        ans[q[i].second] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的之后更新~~qwq</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】ST表与RMQ算法</title>
      <link href="/posts/7527e30.html"/>
      <url>/posts/7527e30.html</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://zhuanlan.zhihu.com/p/123360481">【朝夕的ACM笔记】数据结构-ST表</a></p><p>在练习线段树的过程中经常会感叹代码怎么这么长啊啊啊懒标记怎么这么难传啊啊啊</p><p>于是在得知有一种代码量远小于线段树的算法时、、、（其实是因为做到了<a href="https://www.luogu.com.cn/problem/P2471">[SCOI2007] 降雨量</a></p><p>就是ST表啦~</p><p>在什么情况下可以用ST表代替线段树呢？</p><p><strong>&#x3D;&#x3D;不需要区间修改&#x3D;&#x3D;的&#x3D;&#x3D;可重复贡献问题&#x3D;&#x3D;</strong></p><p>不需要区间修改很好理解，什么叫做可重复贡献呢？</p><p>我们知道，求一个数组的最大值（比如说长度为10的数组），我们可以先求前六个数的最大值，再求后七个数的最大值，最后求这两个最大值的最大值，虽然这中间有重复的元素，但是对最终的最大值结果不会有影响，这就叫做可重复贡献问题。</p><p>但是如果我们要求一个数组中所有元素的和（还是比如说长度为10的数组），我们就不能用前六个元素的和加上后七个元素的和了，这就叫做不可重复贡献问题。</p><p>常见的可重复贡献问题包括：求<strong>区间最大&#x2F;小值</strong>，<strong>区间按位和&#x2F;或</strong>，<strong>区间gcd</strong>…</p><p><strong>怎么构建ST表呢？</strong></p><p>ST表是一种基于<strong>倍增</strong>算法的数据结构</p><p>我们设<code>f[i][j]</code>表示区间 $[i, i + 2^j - 1]$ 的最大值，因此<code>f[i][0]</code>表示的就是第 i 个元素本身了</p><p>由倍增思想，区间 $[i, i + 2^j - 1]$ 可以被我们拆成两个长度为 $2^{j - 1}$ 的子区间，所以可以的到递推式 $f[i][j]&#x3D;max(f[i][j - 1], f[i + 2^{j-1}][j-1])$，因此先枚举 $j$，再枚举 $i$，就可以得到 $f[i][j]$ 的值了</p><p><strong>怎么查询区间信息呢？–&gt; RMQ算法</strong></p><p>如果我们想知道 $[l, r]$ 的最值，我们可能会输出 $f[l][x]$, $l+2^x-1&#x3D;r$，这样解出x，会发现 $x&#x3D;log_2(r-l+1)$，这样得到的 x 就不一定是个整数了，向下取整的话可能会使区间有所损失</p><p>这时可重复贡献的性质就发挥作用了，我们把要查询的区间 $[l,r]$ 分成长度为 $\lfloor{x}\rfloor$ 两部分，一部分以 l 开头，一部分以 r 结尾，也就是 $[l, l+2^x-1]$ 和 $[r-2^x+1,r]$，只要找到这两个区间的最大值，再取最大值，就可以得到整个区间的最大值了</p><p><strong>时间复杂度</strong></p><p>预处理 $O(nlogn)$<br>查询 $O(1)$</p><p><strong>板子</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">100005</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> logn[<span class="number">100005</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span> <span class="comment">// 预处理log 防止查询时T</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    logn[<span class="number">1</span>] = <span class="number">0</span>, logn[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">        logn[i] = logn[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入数组本身</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; f[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">21</span>; j++) <span class="comment">// 2的21次方满足两百万数据 数据变大上限也要变大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i ++ )</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]); <span class="comment">// 这里根据所求内容不同需要做相应修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RMQ查询</span></span><br><span class="line">        <span class="type">int</span> lg = logn[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(f[l][lg], f[r - (<span class="number">1</span> &lt;&lt; lg) + <span class="number">1</span>][lg]);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> ST表 </tag>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】线段树</title>
      <link href="/posts/63fc9272.html"/>
      <url>/posts/63fc9272.html</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&#x3D;&#x3D;<strong>时间复杂度：O(logn)</strong>&#x3D;&#x3D;</p><p>线段树是一棵二叉树，把一段区间分成多个部分</p><img src="/posts/63fc9272/1.png" class title="This is an test image"><p>类似堆的方式，用一维数组存整棵树</p><p>对于编号x的结点：</p><ul><li>父结点 $\lfloor x \rfloor$，表示为 <code>x &gt;&gt; 1</code></li><li>左子树 $2x$，表示为 <code>x &lt;&lt; 1</code></li><li>右子树 $2x+1$，表示为 <code>x &lt;&lt; 1 | 1</code></li></ul><p>对于长度为n的区间，最坏估计有 $4n-1$ 个结点，因此 &#x3D;&#x3D;<strong>开数组时空间一般开 $4n$</strong>&#x3D;&#x3D;</p><h1 id="pushup"><a href="#pushup" class="headerlink" title="pushup"></a>pushup</h1><p><strong>由子结点计算父结点的信息</strong></p><p>模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u表示当前树中结点编号 lr表示树中结点左右子结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 此处用[l]和[r]的值更新[u] */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="build"><a href="#build" class="headerlink" title="build"></a>build</h1><p><strong>将一段区间初始化为线段树</strong></p><ol><li>首先记录下当前区间的左右端点，如果左端点和右端点相等就直接返回</li><li>如果不相等，取中间值 <code>mid</code>，然后分别递归左右两段</li></ol><p>模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u表示当前树中结点编号 lr表示区间左右端点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="comment">// 左右端点相同表示到达叶子结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;    &#125;; <span class="comment">// 创建该结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r); <span class="comment">// 分别构造左右两棵子树</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 利用pushup更新该点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="modify"><a href="#modify" class="headerlink" title="modify"></a>modify</h1><p><strong>修改单点或区间（需要用到push_down操作）</strong></p><p><strong>修改单点</strong>模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u为当前树中结点编号 要把x位置的值更新为v</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x) <span class="comment">// 到达叶子结点 直接更新</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;     &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v); <span class="comment">// 要更新的位置在左半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v); <span class="comment">// 要更新的位置在右半部分</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 更新此位置结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改区间</strong>模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="comment">// 当前树中结点在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (i64)(tr[u].r - tr[u].l + <span class="number">1</span>) * d; <span class="comment">// 更新区间信息</span></span><br><span class="line">        tr[u].add += d; <span class="comment">// 打上懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 当前树中结点不在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u); <span class="comment">// 将懒标记向下传递</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 由于modify修改了区间结点的信息，所以被修改的结点的祖先结点都需要重算一遍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="query"><a href="#query" class="headerlink" title="query"></a>query</h1><p><strong>查询区间信息</strong></p><p>假设我们要查询某区间的最大值</p><p>定义 <code>[l, r]</code> 为我们要查询的区间，<code>[Tl, Tr]</code> 为树中结点（当前我们正在维护的区间），这两个区间会有如下两种关系：</p><ul><li>$[Tl, Tr]\subset[l, r]$，树中结点完全包含在要查询的区间内部<br>这种情况直接返回当前区间最大值即可</li><li>$[l, r]\bigcap[Tl, Tr]\not&#x3D;\emptyset$，二者有交集<br>和左边有交集就递归到左边做一遍，和右边有交集就递归到右边做一遍<br>即<code>l &gt; mid</code>只递归右边，<code>r &lt;= mid</code>只递归左边，否则左右都递归</li></ul><p>模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u]; <span class="comment">// 当前区间在被查询区间之内 直接返回</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r); <span class="comment">// 被查询区间在当前区间左半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r); <span class="comment">// 被查询区间在当前区间右半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 被查询区间横跨当前区间的左右两部分</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r); <span class="comment">// 计算出左半部分值</span></span><br><span class="line">            <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r); <span class="comment">// 计算出右半部分值</span></span><br><span class="line">            Node res;</span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right); <span class="comment">// 更新结果</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="pushdown（懒标记-延迟标记）"><a href="#pushdown（懒标记-延迟标记）" class="headerlink" title="pushdown（懒标记 &#x2F; 延迟标记）"></a>pushdown（懒标记 &#x2F; 延迟标记）</h1><p><strong>将父结点的修改更新到子结点</strong></p><p>单点修改可以只用pushup，涉及到区间修改就需要使用pushdown</p><p><strong>懒标记</strong> ：在当前树中结点上打上懒标记，就表示对<strong>以当前树中结点为根结点</strong>的<strong>每一个子树</strong>都进行操作（根结点自己不用操作）</p><p>那么懒标记怎么进行传递呢？</p><p>焗个栗子：比如我们在蓝色的这一段区间上打上懒标记</p><p>每当我们需要遍历蓝色区间结点下方的子结点时，我们就把懒标记传递给下一层结点，同时把根结点的懒标记删除，就像这样：</p><p>当然，除了传递标记，我们还需要对线段树中记录的值进行更新，比如说这个线段树记录的是区间和，打上懒标记表示这一段区间每一个数都要加上<code>a</code>，那么我们在传递懒标记的同时，还需要让下方结点的区间和加上<code>(r - l + 1) * a</code>，其中<code>(l - r + 1)</code>表示下方被更新结点的区间长度</p><p>以此类推，每当我们需要遍历下方结点时，就把懒标记向下传，并更新下方结点的值</p><p>以上就是pushdown操作的基本内容</p><p>模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (root.add) <span class="comment">// 当前结点有懒标记 向下传递</span></span><br><span class="line">    &#123;</span><br><span class="line">        left.add += root.add, left.sum += (i64)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (i64)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题：一个简单的整数问题2"><a href="#例题：一个简单的整数问题2" class="headerlink" title="例题：一个简单的整数问题2"></a>例题：一个简单的整数问题2</h1><p><a href="https://www.acwing.com/problem/content/244/">原题链接</a></p><p>给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p><p><code>C l r d</code>，表示把 A[l],A[l+1],…,A[r] 都加上 d。<br><code>Q l r</code>，表示询问数列中第 l∼r 个数的和。<br>对于每个询问，输出一个整数表示答案。</p><p><strong>输入格式</strong></p><p>第一行两个整数 N,M。</p><p>第二行 N 个整数 A[i]。</p><p>接下来 M 行表示 M 条指令，每条指令的格式如题目描述所示。</p><p><strong>输出格式</strong></p><p>对于每个询问，输出一个整数表示答案。</p><p>每个答案占一行。</p><p><strong>数据范围</strong></p><p>$1≤N,M≤105,$<br>$|d|≤10000,$<br>$|A[i]|≤109$</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">Q <span class="number">4</span> <span class="number">4</span></span><br><span class="line">Q <span class="number">1</span> <span class="number">10</span></span><br><span class="line">Q <span class="number">2</span> <span class="number">4</span></span><br><span class="line">C <span class="number">3</span> <span class="number">6</span> <span class="number">3</span></span><br><span class="line">Q <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><p><strong>code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    i64 sum, add; <span class="comment">// 区间和和懒标记</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (root.add) <span class="comment">// 当前结点有懒标记 向下传递</span></span><br><span class="line">    &#123;</span><br><span class="line">        left.add += root.add, left.sum += (i64)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (i64)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="comment">// 当前树中结点在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (i64)(tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[u].add += d; <span class="comment">// 打上懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 当前树中结点不在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u); <span class="comment">// 将懒标记向下传递</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 由于modify修改了区间结点的信息，所以被修改的结点的祖先结点都需要重算一遍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u); <span class="comment">// 为了让查询到的最小结点都已计算过祖先结点的懒标记</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    i64 sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> l, r, d;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; d;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扫描线法"><a href="#扫描线法" class="headerlink" title="扫描线法"></a>扫描线法</h1><p>放一道例题</p><h2 id="亚特兰蒂斯"><a href="#亚特兰蒂斯" class="headerlink" title="亚特兰蒂斯"></a>亚特兰蒂斯</h2><p><a href="https://www.acwing.com/problem/content/249/">原题链接</a></p><p>有几个古希腊书籍中包含了对传说中的亚特兰蒂斯岛的描述。</p><p>其中一些甚至包括岛屿部分地图。</p><p>但不幸的是，这些地图描述了亚特兰蒂斯的不同区域。</p><p>您的朋友 Bill 必须知道地图的总面积。</p><p>你自告奋勇写了一个计算这个总面积的程序。</p><p><strong>输入格式</strong></p><p>输入包含多组测试用例。</p><p>对于每组测试用例，第一行包含整数 n，表示总的地图数量。</p><p>接下来 n 行，描绘了每张地图，每行包含四个数字 x1,y1,x2,y2（不一定是整数），(x1,y1) 和 (x2,y2) 分别是地图的左上角位置和右下角位置。</p><p>注意，坐标轴 x 轴从上向下延伸，y 轴从左向右延伸。</p><p>当输入用例 n&#x3D;0 时，表示输入终止，该用例无需处理。</p><p><strong>输出格式</strong></p><p>每组测试用例输出两行。</p><p>第一行输出 Test case #k，其中 k 是测试用例的编号，从 1 开始。</p><p>第二行输出 Total explored area: a，其中 a 是总地图面积（即此测试用例中所有矩形的面积并，注意如果一片区域被多个地图包含，则在计算总面积时只计算一次），精确到小数点后两位数。</p><p>在每个测试用例后输出一个空行。</p><p><strong>数据范围</strong></p><p>$1≤n≤10000,$<br>$0≤x1&lt;x2≤100000,$<br>$0≤y1&lt;y2≤100000$</p><p>注意，本题 n 的范围上限加强至 10000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span> <span class="number">20</span> <span class="number">20</span></span><br><span class="line"><span class="number">15</span> <span class="number">15</span> <span class="number">25</span> <span class="number">25.5</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Test <span class="keyword">case</span> #<span class="number">1</span></span><br><span class="line">Total explored area: <span class="number">180.00</span> </span><br></pre></td></tr></table></figure><p><strong>code</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x, y1, y2;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Segment &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">double</span> len;</span><br><span class="line">&#125;tr[N * <span class="number">8</span>]; <span class="comment">// 线段树</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; ys; <span class="comment">// 存储纵坐标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), y) - ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].cnt) tr[u].len = ys[tr[u].r + <span class="number">1</span>] - ys[tr[u].l]; <span class="comment">// 这一段被完全覆盖 所以直接算长度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[u].l != tr[u].r) <span class="comment">// 没有被完全覆盖 分成左右两段分别来看</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = <span class="number">0</span>; <span class="comment">// 叶子结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l != r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// cnt和len都是0所以不需要pushdown</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="comment">// 完全覆盖</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].cnt += k;</span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 更新该节点的len</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        ys.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> x1, x2, y1, y2;</span><br><span class="line">            cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            <span class="comment">// 把所有竖着的线段存进segment</span></span><br><span class="line">            seg[j ++ ] = &#123;x1, y1, y2, <span class="number">1</span>&#125;;</span><br><span class="line">            seg[j ++ ] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">            ys.<span class="built_in">push_back</span>(y1), ys.<span class="built_in">push_back</span>(y2); <span class="comment">// 把所有纵坐标存进ys</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 纵坐标去重</span></span><br><span class="line">        <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>());</span><br><span class="line">        ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>()), ys.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, ys.<span class="built_in">size</span>() - <span class="number">2</span>); <span class="comment">// 纵坐标点的数量到ys-1 线段数量就是ys-2</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(seg, seg + n * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i) res += tr[<span class="number">1</span>].len * (seg[i].x - seg[i - <span class="number">1</span>].x);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test case #&quot;</span> &lt;&lt; T &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        T ++ ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】树状数组</title>
      <link href="/posts/b289bb13.html"/>
      <url>/posts/b289bb13.html</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/574739597">https://zhuanlan.zhihu.com/p/574739597</a></p><p>树状数组主要是支持两种操作：</p><ul><li><strong>单点修改</strong></li><li><strong>区间查询</strong></li></ul><p>这两个操作的时间复杂度都是 <em>O(logn)</em><br>根据前缀和的原理，任意一段区间求和都可以转换成两个前缀和的差，因此区间求和问题转换成求前缀和问题</p><h1 id="前提准备：计算-lowbit"><a href="#前提准备：计算-lowbit" class="headerlink" title="前提准备：计算 lowbit"></a>前提准备：计算 lowbit</h1><p>在此我们定义一个 <code>lowbit(x)</code> ，表示 x 的最末尾一个 1 与这个 1 后面的所有 0 组成的二进制数<br><code>lowbit(x)</code> 应该怎么实现呢？<br>很简单，这里直接给出结论 <code>lowbit(x) = x &amp; -x</code><br>还是通过例子来说明</p><blockquote><p>现有二进制数 101100<br>x &#x3D; 101100<br>反码：010011<br>补码：010100</p></blockquote><p>可以注意到，-x 是 x 末尾的一个 1 到结束的 0 不动，前面全部取反的结果<br>那么 <code>x &amp; -x</code> 就只保留了末尾的 1 和后面的 0<br>因此得到我们的 lowbit 函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树状数组的含义"><a href="#树状数组的含义" class="headerlink" title="树状数组的含义"></a>树状数组的含义</h1><p>我们定义原数组为<code>a</code>，用一个数组 <code>tree</code> 维护若干个小区间，<code>tree[i]</code> 表示<strong>以<code>a[i]</code>为结尾、长度为<code>lowbit(i)</code>的区间的和，也就是<code>(i-lowbit(i), i]</code>（左开右闭）这一区间的和</strong>（这一点很重要，请务必记住）<br>举个栗子吧</p><blockquote><p>i &#x3D; 5 &#x3D; 101<del>(2)</del><br>lowbit(i) &#x3D; lowbit(101) &#x3D; 001<del>(2)</del> &#x3D; 1         i - lowbit(i) &#x3D; 100<del>(2)</del> &#x3D; 4<br>i &#x3D; i - lowbit(i) &#x3D; 4 &#x3D; 100<del>(2)</del><br>lowbit(i) &#x3D; lowbit(100) &#x3D; 100<del>(2)</del>         i - lowbit(i) &#x3D; 0<br>因此 lowbit(5) 就等于以 a[5] 结尾，长度为 lowbit(5) &#x3D; 1 的区间的和，也就是等于 a[5]</p></blockquote><ul><li>单点修改时，只更新<strong>包含这一元素的区间</strong></li><li>求前 n 项和时，通过将区间进行<strong>组合</strong>，得到从 1 到 n 的区间，然后对所有用到的区间求和。<br>将 n 转换为二进制，任意一个数都可以看作是几个二进制数表示区间的和<br>举个栗子<blockquote><p>11<del>(10)</del> &#x3D; 1011<del>(2)</del><br>求前 11 项的和，可以转换成求 1010 - 1011、1000 - 1010、0000 - 1000 这几个区间的和</p></blockquote></li></ul><p>这个步骤就是在不断地删去最末尾的一个 1<br>而我们刚刚在前提准备里提到，lowbit 运算，就是不断删去末尾的 1 的过程</p><p>因此单点修改时，我们只需要从<code>tree[1]</code>开始，每次将<code>i</code> 更新成<code>i + lowbit(i)</code>，修改当前的<code>tree[i]</code>，直到<code>i</code>被更新为 N<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= N)</span><br><span class="line">&#123;</span><br><span class="line">tree[i] += x;</span><br><span class="line">i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求 <code>a[i]</code> 的前缀和时，可以利用循环来求解，每次将 <code>i</code> 更新为 <code>i - lowbit(i)</code>，加上修改后的 <code>i</code> 的 <code>tree[i]</code> 即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefix_sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">presum += tree[i];</span><br><span class="line">i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> presum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，区间求和的代码也显而易见了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">prefix_sum</span>(r) - <span class="built_in">prefix_sum</span>(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓展应用"><a href="#拓展应用" class="headerlink" title="拓展应用"></a>拓展应用</h1><h2 id="拓展一：区间修改、单点查询"><a href="#拓展一：区间修改、单点查询" class="headerlink" title="拓展一：区间修改、单点查询"></a>拓展一：区间修改、单点查询</h2><p>区间修改，我们需要给区间内的每个数加上同一个给定值 x，很容易想到利用差分来降低复杂度，记原数组为<code>a[i]</code>，差分数组为<code>b[i]</code>，<code>b[i] = a[i] - a[i - 1]</code><br>在<code>b[i]</code>上建立树状数组<code>tree[i]</code>，每次对<code>a</code>中<code>[l, r]</code>区间上的修改，就相当于<code>b[l] += x</code>和<code>b[r + 1] -= x</code>，这样我们也可以对<code>tree[i]</code>做出相应的两次单点修改，于是区间修改也被我们转换成单点修改得到解决了</p><p>单点查询，根据差分数组的性质，<code>a[i] = b[1] + b[2] + … + b[i]</code>，即可将单点查询转换成求<code>b</code>的前缀和，进而利用树状数组进行计算</p><h2 id="拓展二：区间查询、区间修改"><a href="#拓展二：区间查询、区间修改" class="headerlink" title="拓展二：区间查询、区间修改"></a>拓展二：区间查询、区间修改</h2><p>计算<code>a[i]</code>时，需要计算<code>b[i]</code>的前缀和<br>所以计算<code>a[i]</code>的前缀和时，我们就需要计算<code>b[i]</code>的前缀和的前缀和<br>用数学公式表达如下：（计算<code>a[p]</code>的前缀和）</p><p>$\sum_{i &#x3D; 1}^{p} a[i] &#x3D; \sum_{i &#x3D; 1}^{p}(\sum_{j &#x3D; 1}^{i} b[j])$</p><p>等号右侧中，<code>b[1]</code>出现了 p 次，<code>b[2]</code>出现了 p - 1 次，<code>b[j]</code>出现了 p + 1 - j 次。因此可知：</p><p>$\sum_{i &#x3D; 1}^{p} a[i] &#x3D; (p + 1)\sum_{j &#x3D; i  -1}^{p}b[j] - \sum_{j &#x3D; 1}^{p}b[j] * j$</p><p>可以理解为：我们先把每个<code>b[j]</code>都算作出现了<code>p + 1</code>次，然后再把多算的 <code>j</code> 次减去。</p><p>因此——</p><ul><li><code>b[i] = a[i] - a[i - 1]</code></li><li><code>c[i] = b[i] * i</code></li></ul><p>对于<code>b[i]</code>和<code>c[i]</code>都建立树状数组，这样就可以很容易求出<code>b[i]</code>和<code>c[i]</code>的前缀和，也就得到了<code>a[i]</code>的前缀和，区间查询完成</p><p>对于区间修改，我们将<code>a</code>的<code>[l, r]</code>每个元素加上 x，<code>b</code>的变化方式为<code>b[l] += x</code>和<code>b[r + 1] -= x</code>，相应的，<code>c</code>的变化方式为<code>c[l] += x * l ，c[r + 1] -= x * (r + 1)</code>，也就是对 b 和 c 进行两次单点修改，这个步骤已经在上面写过就不重复了</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】并查集</title>
      <link href="/posts/2e7813af.html"/>
      <url>/posts/2e7813af.html</url>
      
        <content type="html"><![CDATA[<p>今天补题遇到了这个知识点，能想到这个方法但是自己没办法实现，所以来复习一下相关知识做个总结~</p><p>并查集，简单来说，就是合并两个集合，然后能迅速判断两个元素是否在同一集合中<br><strong>板子</strong><br>返回 x 的祖先结点，同时进行路径压缩，让 p[x] 直接指向祖先结点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现方法：</strong><br>首先所有元素各为一个集合，创建数组 p[i]，意为 i 的父结点，起初，p[i] 全部等于 i </p><ul><li>当两个元素 a b 进行合并时（实际上就是两个集合进行合并），让 a 的祖先结点的父结点等于 b 的祖先结点，a 的祖先结点直接指向 b 的祖先结点<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure></li><li>当询问两个元素 a b 是否在同一个集合中时，只需要看 a b 的祖先结点是不是同一个，也就是判断 find(a) &#x3D;&#x3D; find(b) 是否成立</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】位运算</title>
      <link href="/posts/4befabc3.html"/>
      <url>/posts/4befabc3.html</url>
      
        <content type="html"><![CDATA[<p>因为对位运算实在是太太太太太不熟悉了！所以每次遇到位运算相关的题都要卡好久才能把题目意思转化成容易理解的样子，今晚又被卡了所以一怒之下总结一篇等下次被卡就来翻翻qwq</p><h1 id="与"><a href="#与" class="headerlink" title="与 &amp;"></a>与 &amp;</h1><p>翻译：同为1取1，只要有0就取0</p><ul><li>可以用&amp;来取每一位上的数，如果要判断n的第三位是否为1，就进行 $n$ &amp; $2^{3-1}$ 运算，如果结果为 $2^{3-1}$ ，就说明当前判断的位数上是1，结果是0，就说明当前判断的位数上是0</li><li><strong>判断奇偶</strong><br><code>a &amp; 1 == 1</code> a为奇数<br><code>a &amp; 1 == 0</code> a为偶数</li></ul><h1 id="或-（OR）"><a href="#或-（OR）" class="headerlink" title="或 | （OR）"></a>或 | （OR）</h1><p>翻译：有1取1，无1取0</p><ul><li>一个数对另一个数进行 | 操作，当前位上是0将不产生任何影响，<strong>当前位上是1将会把对应位上变成1</strong></li><li><strong>把一个数变成最接近的偶数</strong>：<code>a = a | 1 - 1</code></li></ul><h1 id="异或-（XOR）"><a href="#异或-（XOR）" class="headerlink" title="异或 ^ （XOR）"></a>异或 ^ （XOR）</h1><p>翻译：相同为0，不同为1</p><ul><li>一个数和本身进行异或运算得到结果为0</li><li>一个数和0进行异或运算得到结果为本身</li><li>上两条推出：<strong>奇数个相同的数异或运算得到结果为本身，偶数个相同的数异或运算得到结果为0</strong></li></ul><h1 id="左移"><a href="#左移" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h1><p>翻译：<code>a &lt;&lt; b = a x 2^b</code></p><h1 id="右移"><a href="#右移" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h1><p>翻译：<code>a &gt;&gt; b = a / 2^b</code></p><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>按位反（~）&gt; 位移运算（&lt;&lt;,&gt;&gt;）&gt; 按位与（&amp;）&gt; 按位异或（^）&gt; 按位或（|）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> C++ </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基础算法】逆序对</title>
      <link href="/posts/5ccba1a0.html"/>
      <url>/posts/5ccba1a0.html</url>
      
        <content type="html"><![CDATA[<p><strong>逆序对</strong>，简单来说，就是<code>i &gt; j</code>*，但<code>a[i] &lt; a[j]</code>，那么<code>a[i] 和 a[j]</code>就是一组逆序对</p><p>求逆序对有三种方式——</p><ul><li>暴力 复杂度 O(n^2^) 谁用谁T 不多赘述了</li><li>归并排序 复杂度 O(nlogn)</li><li>树状数组 复杂度 O(nlogn)</li></ul><p><strong>归并排序</strong></p><p>首先看一下归并排序的原理，就是将一个序列无限二分，直到每一部分都只有一个元素，这时每一部分都有序，然后逐次合并相邻部分，让合并后的各个部分有序<br>举个栗子<br>现在我们要合并两个部分：1 3 5 7 9 | 2 4 6 8 10<br>先比较 1、2，发现 1 &lt; 2，所以把 1 先放到合并后的数组里<br>现在剩下的两部分是：3 5 7 9 | 2 4 6 8 10<br>现在比较3、2，发现 3 &gt; 2，所以把 2 放到合并后的数组，由于左半部分是有序的，所以 2 小于左半部分剩下的所有数，但 2 又在左半边剩下的所有数后面，所以 2 和这些数都构成逆序对，逆序对的数量就是<code>mid - i</code><br>每一次右半部分的第一个数小于左半部分的第一个数时，右半部分的第一个数和左半部分剩下的所有数都构成逆序对，因此在原来的基础上加上<code>mid - i</code>即可</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> a[N], temp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_pai</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = l, j = mid, p = l;</span><br><span class="line"><span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; a[j]) temp[p ++ ] = a[i ++ ];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp[p ++ ] = a[j ++ ];</span><br><span class="line">ans += mid - i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; mid) temp[p ++ ] = a[i ++ ];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r) temp[p ++ ] = a[j ++ ];</span><br><span class="line">p = l;</span><br><span class="line"><span class="keyword">while</span> (p &lt; mid) a[p ++ ] = temp[p ++ ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(l, mid);</span><br><span class="line"><span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">merge_pai</span>(l, r, mid + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">merge_sort</span>(<span class="number">1</span>, n);</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>树状数组</strong></p><p>树状数组的原理在这里就不多说啦，如果有不懂的同学可以去看看<a href="https://blog.csdn.net/dhxbshbdjzxy/article/details/131718607?spm=1001.2014.3001.5502">这篇</a></p><p>建立一个数组<code>c[i]</code>，表示元素 i 出现的次数，起初每一项都为0<br>同时我们也可以得到<code>c[i]</code>的树状数组<code>tree[i]</code><br>每次插入一个数 x ，我们都将利用树状数组单点修改的性质更新<code>tree[i]</code>的值，此时区间查询<code>c[i - 1]</code>的前缀和，我们就可以得到在 x 前输出，比 x 的值小的元素个数，用总共输入的元素个数和它相减，就可以得到<strong>在 x 前输出，且比 x 大的元素个数</strong>，这也就是逆序对的个数了<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= N)</span><br><span class="line">&#123;</span><br><span class="line">tree[i] += x;</span><br><span class="line">i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefix_sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">presum += tree[i];</span><br><span class="line">i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> presum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> a[n + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">add</span>(a[i], <span class="number">1</span>);</span><br><span class="line">ans += (i - <span class="built_in">prefix_sum</span>(a[i]));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> 逆序对 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基础算法】前缀和与差分</title>
      <link href="/posts/470a5ef6.html"/>
      <url>/posts/470a5ef6.html</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><p>一维数组中，计算出所有前 n 个数的和，存储在一个单独的数组里，便于后续计算</p><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>s[i] 计算的就是前 i 个数的和<br>当我们需要计算第 l 个数到第 r 个数的和时，只需要用 s[r] - s[l - 1] 即可</p><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><p>二维数组中，计算出长为 0 - l， 宽为 0 - r 的矩阵和<br>这个值等于长为 0 - (l - 1) 宽为 0 - r 的矩阵加上 长为 0 - l 宽为 0 - (r - 1) 的矩阵减去 长为 0 - (l - 1) 宽为 0 - (r - 1)的矩阵 最后加上该位置的值</p><h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要计算左上角坐标为 (x1, y1)， 右下角坐标为 (x2, y2) 的矩阵时，只需要用 s[x2][y2] - s[x1 - 1][y1] - s[x1][y1 - 1] + s[x1 - 1][y1 - 1] 即可</p><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>差分与前缀和是逆运算，数组 a 是数组 b 的前缀和，数组 b 就是数组 a 的差分<br>即<br>a[i] &#x3D; b[0] + b[1] + … + b[i]<br>b[i] &#x3D; a[i] - a[i - 1]</p><h2 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h2><p>在一维数组中，将从 l 到 r 的每一个数都加上给定值 c<br>因为在给定区间内的每一个数都加了 c ，所以它们之间的差值不变，只有第 l - 1 与第 i 个数、第 r 与第 r + 1 个数的差值发生了改变，因此修改差分数组时只需要修改两个值，极大提高计算速度<br>适用于需要多次修改数组的情况</p><h3 id="板子-2"><a href="#板子-2" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">insert</span>(i, i, a[i]); <span class="comment">// 差分数组的建立</span></span><br><span class="line"><span class="type">int</span> l, r, c;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="built_in">insert</span>(l, r, c); <span class="comment">// 差分数组的修改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) b[i] += b[i - <span class="number">1</span>]; <span class="comment">// 将差分数组恢复成原数组</span></span><br></pre></td></tr></table></figure><h2 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h2><p>二维数组中，将长为 0 - l， 宽为 0 - r 的矩阵中每一个元素都加上一个给定值 c<br>对于差分矩阵，需要进行如下操作：</p><ul><li>b[x1][y1] +&#x3D; c</li><li>b[x2 + 1][y2 + 1] +&#x3D; c</li><li>b[x2 + 1][y1] -&#x3D; c</li><li>b[x1][y2 + 1] -&#x3D; c</li></ul><h3 id="板子-3"><a href="#板子-3" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        cin &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        <span class="built_in">insert</span>(i, j, i, j, a[i][j]); <span class="comment">// 构造差分数组</span></span><br><span class="line"><span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line"><span class="built_in">insert</span>(x1, y1, x2, y2, c); <span class="comment">// 修改差分数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 恢复原数组</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基础算法】高精度</title>
      <link href="/posts/40a4a6dc.html"/>
      <url>/posts/40a4a6dc.html</url>
      
        <content type="html"><![CDATA[<p>当比赛中给定数字位数过多，无法直接进行加减乘除运算时，使用高精度计算</p><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p>高精度加法相当于一个列竖式计算的过程，从最低位开始（因此所有数都要倒着存），遇十进位</p><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">//记录进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i ++ ) <span class="comment">// 就是一个竖式计算的过程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="comment">// 将a、b倒着存进去，便于从低位开始进行运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B); <span class="comment">// C 也是倒着存储的 所以下面倒着输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><p>高精度减法也是相当于一个列竖式计算的过程，用大数减小数，从最低位开始（因此所有数都要倒着存），不够减就借位</p><h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较AB大小 用大数减小数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 位数不等，位数多的大</span></span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 位数相等，从高位开始判断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- )</span><br><span class="line">    <span class="keyword">if</span> (A[i] != B[i]) <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 存储计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t; <span class="comment">// 先处理借位情况</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i]; <span class="comment">// B还没减完时</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>); <span class="comment">// 防止t小于0</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>; <span class="comment">// 说明不够减要借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>; <span class="comment">// 无需借位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 除去前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先判断AB大小，确保大数减小数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B, A);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><p>高精度乘法要求其中的一个数是 int 类型，同样是列竖式计算的过程</p><h3 id="板子-2"><a href="#板子-2" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 存储计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 低位开始，每次取结果的个位存进C中</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 删去前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><p>同样是竖式计算的过程，要求除数是 int 类型</p><h3 id="板子-3"><a href="#板子-3" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>; <span class="comment">// 记录余数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i]; <span class="comment">// 余数乘10加新一位</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b; <span class="comment">// 更新余数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>()); <span class="comment">// 翻转C便于删去前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> r; <span class="comment">// 余数</span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基础算法】二分</title>
      <link href="/posts/91181467.html"/>
      <url>/posts/91181467.html</url>
      
        <content type="html"><![CDATA[<p>二分适用于满足二段性的序列，当一个序列中一段满足条件，另一段不满足条件时可以考虑使用二分来加快查找速度</p><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x 是需要查找的数</span></span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q[mid] &gt;= x) r = mid; <span class="comment">// 符号按需要更改</span></span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure><h2 id="符号判断"><a href="#符号判断" class="headerlink" title="符号判断"></a>符号判断</h2><p>二分中使用什么符号曾经困扰了我很久，现总结如下：<br>大原则：<strong>搞不清就带等号</strong>，带等号的时候和字面理解意思相同<br>其中，以下两个式子表示含义相同：</p><ul><li><strong>&gt;&#x3D;</strong> 会输出满足大于等于条件的第一个数</li><li><strong>&lt;</strong> 会输出从后往前看不满足小于条件的第一个数</li></ul><p>以下两个式子表示含义相同：</p><ul><li><strong>&lt;&#x3D;</strong> 会输出从后往前看满足小于等于条件的第一个数</li><li><strong>&gt;</strong>  会输出不满足条件的最后一个数</li></ul><p>举个栗子</p><blockquote><p>现有如下序列：1 2 3 4 5 5 5 6 7 8 9</p></blockquote><p>现需查找 “5” ——</p><ul><li>当使用 <strong>&gt;&#x3D;</strong> 时，找到的是第 1 个 5</li><li>当使用 <strong>&lt;&#x3D;</strong> 时，找到的是第 3 个 5</li><li>当使用 <strong>&gt;</strong> 时，找到的是第 1 个 5</li><li>当使用 <strong>&lt;</strong> 时，找到的是第 3 个 5</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在前面的话</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 Texcavator 的 Blog！</p><p>这里将记录下我学习过程中的笔记和心得</p><p>没想好这里还要写什么，之后再来补充啦~</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
