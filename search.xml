<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在前面的话</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<p>欢迎来到 Texcavator 的 Blog！</p>
<p>这里将记录下我学习过程中的笔记和心得</p>
<p>没想好这里还要写什么，之后再来补充啦~</p>
]]></content>
  </entry>
  <entry>
    <title>【C++】位运算</title>
    <url>/posts/4befabc3.html</url>
    <content><![CDATA[<p>因为对位运算实在是太太太太太不熟悉了！所以每次遇到位运算相关的题都要卡好久才能把题目意思转化成容易理解的样子，今晚又被卡了所以一怒之下总结一篇等下次被卡就来翻翻qwq</p>
<h1 id="与"><a href="#与" class="headerlink" title="与 &amp;"></a>与 &amp;</h1><p>翻译：同为1取1，只要有0就取0</p>
<ul>
<li>可以用&amp;来取每一位上的数，如果要判断n的第三位是否为1，就进行 $n$ &amp; $2^{3-1}$ 运算，如果结果为 $2^{3-1}$ ，就说明当前判断的位数上是1，结果是0，就说明当前判断的位数上是0</li>
<li><strong>判断奇偶</strong><br><code>a &amp; 1 == 1</code> a为奇数<br><code>a &amp; 1 == 0</code> a为偶数</li>
</ul>
<h1 id="或-（OR）"><a href="#或-（OR）" class="headerlink" title="或 | （OR）"></a>或 | （OR）</h1><p>翻译：有1取1，无1取0</p>
<ul>
<li>一个数对另一个数进行 | 操作，当前位上是0将不产生任何影响，<strong>当前位上是1将会把对应位上变成1</strong></li>
<li><strong>把一个数变成最接近的偶数</strong>：<code>a = a | 1 - 1</code></li>
</ul>
<h1 id="异或-（XOR）"><a href="#异或-（XOR）" class="headerlink" title="异或 ^ （XOR）"></a>异或 ^ （XOR）</h1><p>翻译：相同为0，不同为1</p>
<ul>
<li>一个数和本身进行异或运算得到结果为0</li>
<li>一个数和0进行异或运算得到结果为本身</li>
<li>上两条推出：<strong>奇数个相同的数异或运算得到结果为本身，偶数个相同的数异或运算得到结果为0</strong></li>
</ul>
<h1 id="左移"><a href="#左移" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h1><p>翻译：<code>a &lt;&lt; b = a x 2^b</code></p>
<h1 id="右移"><a href="#右移" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h1><p>翻译：<code>a &gt;&gt; b = a / 2^b</code></p>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>按位反（~）&gt; 位移运算（&lt;&lt;,&gt;&gt;）&gt; 按位与（&amp;）&gt; 按位异或（^）&gt; 按位或（|）</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>C++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础算法】二分</title>
    <url>/posts/91181467.html</url>
    <content><![CDATA[<p>二分适用于满足二段性的序列，当一个序列中一段满足条件，另一段不满足条件时可以考虑使用二分来加快查找速度</p>
<h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x 是需要查找的数</span></span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q[mid] &gt;= x) r = mid; <span class="comment">// 符号按需要更改</span></span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure>
<h2 id="符号判断"><a href="#符号判断" class="headerlink" title="符号判断"></a>符号判断</h2><p>二分中使用什么符号曾经困扰了我很久，现总结如下：<br>大原则：<strong>搞不清就带等号</strong>，带等号的时候和字面理解意思相同<br>其中，以下两个式子表示含义相同：</p>
<ul>
<li><strong>&gt;&#x3D;</strong> 会输出满足大于等于条件的第一个数</li>
<li><strong>&lt;</strong> 会输出从后往前看不满足小于条件的第一个数</li>
</ul>
<p>以下两个式子表示含义相同：</p>
<ul>
<li><strong>&lt;&#x3D;</strong> 会输出从后往前看满足小于等于条件的第一个数</li>
<li><strong>&gt;</strong>  会输出不满足条件的最后一个数</li>
</ul>
<p>举个栗子</p>
<blockquote>
<p>现有如下序列：1 2 3 4 5 5 5 6 7 8 9</p>
</blockquote>
<p>现需查找 “5” ——</p>
<ul>
<li>当使用 <strong>&gt;&#x3D;</strong> 时，找到的是第 1 个 5</li>
<li>当使用 <strong>&lt;&#x3D;</strong> 时，找到的是第 3 个 5</li>
<li>当使用 <strong>&gt;</strong> 时，找到的是第 1 个 5</li>
<li>当使用 <strong>&lt;</strong> 时，找到的是第 3 个 5</li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础算法】前缀和与差分</title>
    <url>/posts/470a5ef6.html</url>
    <content><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><p>一维数组中，计算出所有前 n 个数的和，存储在一个单独的数组里，便于后续计算</p>
<h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s[i] 计算的就是前 i 个数的和<br>当我们需要计算第 l 个数到第 r 个数的和时，只需要用 s[r] - s[l - 1] 即可</p>
<h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><p>二维数组中，计算出长为 0 - l， 宽为 0 - r 的矩阵和<br>这个值等于长为 0 - (l - 1) 宽为 0 - r 的矩阵加上 长为 0 - l 宽为 0 - (r - 1) 的矩阵减去 长为 0 - (l - 1) 宽为 0 - (r - 1)的矩阵 最后加上该位置的值</p>
<h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们需要计算左上角坐标为 (x1, y1)， 右下角坐标为 (x2, y2) 的矩阵时，只需要用 s[x2][y2] - s[x1 - 1][y1] - s[x1][y1 - 1] + s[x1 - 1][y1 - 1] 即可</p>
<h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>差分与前缀和是逆运算，数组 a 是数组 b 的前缀和，数组 b 就是数组 a 的差分<br>即<br>a[i] &#x3D; b[0] + b[1] + … + b[i]<br>b[i] &#x3D; a[i] - a[i - 1]</p>
<h2 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h2><p>在一维数组中，将从 l 到 r 的每一个数都加上给定值 c<br>因为在给定区间内的每一个数都加了 c ，所以它们之间的差值不变，只有第 l - 1 与第 i 个数、第 r 与第 r + 1 个数的差值发生了改变，因此修改差分数组时只需要修改两个值，极大提高计算速度<br>适用于需要多次修改数组的情况</p>
<h3 id="板子-2"><a href="#板子-2" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">insert</span>(i, i, a[i]); <span class="comment">// 差分数组的建立</span></span><br><span class="line"><span class="type">int</span> l, r, c;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="built_in">insert</span>(l, r, c); <span class="comment">// 差分数组的修改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) b[i] += b[i - <span class="number">1</span>]; <span class="comment">// 将差分数组恢复成原数组</span></span><br></pre></td></tr></table></figure>
<h2 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h2><p>二维数组中，将长为 0 - l， 宽为 0 - r 的矩阵中每一个元素都加上一个给定值 c<br>对于差分矩阵，需要进行如下操作：</p>
<ul>
<li>b[x1][y1] +&#x3D; c</li>
<li>b[x2 + 1][y2 + 1] +&#x3D; c</li>
<li>b[x2 + 1][y1] -&#x3D; c</li>
<li>b[x1][y2 + 1] -&#x3D; c</li>
</ul>
<h3 id="板子-3"><a href="#板子-3" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        cin &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        <span class="built_in">insert</span>(i, j, i, j, a[i][j]); <span class="comment">// 构造差分数组</span></span><br><span class="line"><span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line"><span class="built_in">insert</span>(x1, y1, x2, y2, c); <span class="comment">// 修改差分数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 恢复原数组</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>前缀和</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础算法】逆序对</title>
    <url>/posts/5ccba1a0.html</url>
    <content><![CDATA[<p><strong>逆序对</strong>，简单来说，就是<code>i &gt; j</code>*，但<code>a[i] &lt; a[j]</code>，那么<code>a[i] 和 a[j]</code>就是一组逆序对</p>
<p>求逆序对有三种方式——</p>
<ul>
<li>暴力 复杂度 O(n^2^) 谁用谁T 不多赘述了</li>
<li>归并排序 复杂度 O(nlogn)</li>
<li>树状数组 复杂度 O(nlogn)</li>
</ul>
<p><strong>归并排序</strong></p>
<p>首先看一下归并排序的原理，就是将一个序列无限二分，直到每一部分都只有一个元素，这时每一部分都有序，然后逐次合并相邻部分，让合并后的各个部分有序<br>举个栗子<br>现在我们要合并两个部分：1 3 5 7 9 | 2 4 6 8 10<br>先比较 1、2，发现 1 &lt; 2，所以把 1 先放到合并后的数组里<br>现在剩下的两部分是：3 5 7 9 | 2 4 6 8 10<br>现在比较3、2，发现 3 &gt; 2，所以把 2 放到合并后的数组，由于左半部分是有序的，所以 2 小于左半部分剩下的所有数，但 2 又在左半边剩下的所有数后面，所以 2 和这些数都构成逆序对，逆序对的数量就是<code>mid - i</code><br>每一次右半部分的第一个数小于左半部分的第一个数时，右半部分的第一个数和左半部分剩下的所有数都构成逆序对，因此在原来的基础上加上<code>mid - i</code>即可</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> a[N], temp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_pai</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = l, j = mid, p = l;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; a[j]) temp[p ++ ] = a[i ++ ];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			temp[p ++ ] = a[j ++ ];</span><br><span class="line">			ans += mid - i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; mid) temp[p ++ ] = a[i ++ ];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r) temp[p ++ ] = a[j ++ ];</span><br><span class="line">	p = l;</span><br><span class="line">	<span class="keyword">while</span> (p &lt; mid) a[p ++ ] = temp[p ++ ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">merge_sort</span>(l, mid);</span><br><span class="line">		<span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">		<span class="built_in">merge_pai</span>(l, r, mid + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">merge_sort</span>(<span class="number">1</span>, n);</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>树状数组</strong></p>
<p>树状数组的原理在这里就不多说啦，如果有不懂的同学可以去看看<a href="https://blog.csdn.net/dhxbshbdjzxy/article/details/131718607?spm=1001.2014.3001.5502">这篇</a></p>
<p>建立一个数组<code>c[i]</code>，表示元素 i 出现的次数，起初每一项都为0<br>同时我们也可以得到<code>c[i]</code>的树状数组<code>tree[i]</code><br>每次插入一个数 x ，我们都将利用树状数组单点修改的性质更新<code>tree[i]</code>的值，此时区间查询<code>c[i - 1]</code>的前缀和，我们就可以得到在 x 前输出，比 x 的值小的元素个数，用总共输入的元素个数和它相减，就可以得到<strong>在 x 前输出，且比 x 大的元素个数</strong>，这也就是逆序对的个数了<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= N)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[i] += x;</span><br><span class="line">		i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefix_sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		presum += tree[i];</span><br><span class="line">		i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> presum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> a[n + <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		<span class="built_in">add</span>(a[i], <span class="number">1</span>);</span><br><span class="line">		ans += (i - <span class="built_in">prefix_sum</span>(a[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>【基础算法】高精度</title>
    <url>/posts/40a4a6dc.html</url>
    <content><![CDATA[<p>当比赛中给定数字位数过多，无法直接进行加减乘除运算时，使用高精度计算</p>
<h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p>高精度加法相当于一个列竖式计算的过程，从最低位开始（因此所有数都要倒着存），遇十进位</p>
<h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">//记录进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i ++ ) <span class="comment">// 就是一个竖式计算的过程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="comment">// 将a、b倒着存进去，便于从低位开始进行运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B); <span class="comment">// C 也是倒着存储的 所以下面倒着输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><p>高精度减法也是相当于一个列竖式计算的过程，用大数减小数，从最低位开始（因此所有数都要倒着存），不够减就借位</p>
<h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较AB大小 用大数减小数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 位数不等，位数多的大</span></span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 位数相等，从高位开始判断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- )</span><br><span class="line">    	<span class="keyword">if</span> (A[i] != B[i]) <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 存储计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t; <span class="comment">// 先处理借位情况</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i]; <span class="comment">// B还没减完时</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>); <span class="comment">// 防止t小于0</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>; <span class="comment">// 说明不够减要借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>; <span class="comment">// 无需借位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 除去前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先判断AB大小，确保大数减小数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B, A);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><p>高精度乘法要求其中的一个数是 int 类型，同样是列竖式计算的过程</p>
<h3 id="板子-2"><a href="#板子-2" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 存储计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">// 低位开始，每次取结果的个位存进C中</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 删去前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><p>同样是竖式计算的过程，要求除数是 int 类型</p>
<h3 id="板子-3"><a href="#板子-3" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>; <span class="comment">// 记录余数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i]; <span class="comment">// 余数乘10加新一位</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b; <span class="comment">// 更新余数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>()); <span class="comment">// 翻转C便于删去前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> r; <span class="comment">// 余数</span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】ST表与RMQ算法</title>
    <url>/posts/7527e30.html</url>
    <content><![CDATA[<p>本文参考<a href="https://zhuanlan.zhihu.com/p/123360481">【朝夕的ACM笔记】数据结构-ST表</a></p>
<p>在练习线段树的过程中经常会感叹代码怎么这么长啊啊啊懒标记怎么这么难传啊啊啊</p>
<p>于是在得知有一种代码量远小于线段树的算法时、、、（其实是因为做到了<a href="https://www.luogu.com.cn/problem/P2471">[SCOI2007] 降雨量</a></p>
<p>就是ST表啦~</p>
<p>在什么情况下可以用ST表代替线段树呢？</p>
<p><strong>&#x3D;&#x3D;不需要区间修改&#x3D;&#x3D;的&#x3D;&#x3D;可重复贡献问题&#x3D;&#x3D;</strong></p>
<p>不需要区间修改很好理解，什么叫做可重复贡献呢？</p>
<p>我们知道，求一个数组的最大值（比如说长度为10的数组），我们可以先求前六个数的最大值，再求后七个数的最大值，最后求这两个最大值的最大值，虽然这中间有重复的元素，但是对最终的最大值结果不会有影响，这就叫做可重复贡献问题。</p>
<p>但是如果我们要求一个数组中所有元素的和（还是比如说长度为10的数组），我们就不能用前六个元素的和加上后七个元素的和了，这就叫做不可重复贡献问题。</p>
<p>常见的可重复贡献问题包括：求<strong>区间最大&#x2F;小值</strong>，<strong>区间按位和&#x2F;或</strong>，<strong>区间gcd</strong>…</p>
<p><strong>怎么构建ST表呢？</strong></p>
<p>ST表是一种基于<strong>倍增</strong>算法的数据结构</p>
<p>我们设<code>f[i][j]</code>表示区间 $[i, i + 2^j - 1]$ 的最大值，因此<code>f[i][0]</code>表示的就是第 i 个元素本身了</p>
<p>由倍增思想，区间 $[i, i + 2^j - 1]$ 可以被我们拆成两个长度为 $2^{j - 1}$ 的子区间，所以可以的到递推式 $f[i][j]&#x3D;max(f[i][j - 1], f[i + 2^{j-1}][j-1])$，因此先枚举 $j$，再枚举 $i$，就可以得到 $f[i][j]$ 的值了</p>
<p><strong>怎么查询区间信息呢？–&gt; RMQ算法</strong></p>
<p>如果我们想知道 $[l, r]$ 的最值，我们可能会输出 $f[l][x]$, $l+2^x-1&#x3D;r$，这样解出x，会发现 $x&#x3D;log_2(r-l+1)$，这样得到的 x 就不一定是个整数了，向下取整的话可能会使区间有所损失</p>
<p>这时可重复贡献的性质就发挥作用了，我们把要查询的区间 $[l,r]$ 分成长度为 $\lfloor{x}\rfloor$ 两部分，一部分以 l 开头，一部分以 r 结尾，也就是 $[l, l+2^x-1]$ 和 $[r-2^x+1,r]$，只要找到这两个区间的最大值，再取最大值，就可以得到整个区间的最大值了</p>
<p><strong>时间复杂度</strong></p>
<p>预处理 $O(nlogn)$<br>查询 $O(1)$</p>
<p><strong>板子</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">100005</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> logn[<span class="number">100005</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span> <span class="comment">// 预处理log 防止查询时T</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    logn[<span class="number">1</span>] = <span class="number">0</span>, logn[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">        logn[i] = logn[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入数组本身</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; f[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">21</span>; j++) <span class="comment">// 2的21次方满足两百万数据 数据变大上限也要变大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i ++ )</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]); <span class="comment">// 这里根据所求内容不同需要做相应修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// RMQ查询</span></span><br><span class="line">        <span class="type">int</span> lg = logn[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(f[l][lg], f[r - (<span class="number">1</span> &lt;&lt; lg) + <span class="number">1</span>][lg]);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>ST表</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】并查集</title>
    <url>/posts/2e7813af.html</url>
    <content><![CDATA[<p>今天补题遇到了这个知识点，能想到这个方法但是自己没办法实现，所以来复习一下相关知识做个总结~</p>
<p>并查集，简单来说，就是合并两个集合，然后能迅速判断两个元素是否在同一集合中<br><strong>板子</strong><br>返回 x 的祖先结点，同时进行路径压缩，让 p[x] 直接指向祖先结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现方法：</strong><br>首先所有元素各为一个集合，创建数组 p[i]，意为 i 的父结点，起初，p[i] 全部等于 i </p>
<ul>
<li>当两个元素 a b 进行合并时（实际上就是两个集合进行合并），让 a 的祖先结点的父结点等于 b 的祖先结点，a 的祖先结点直接指向 b 的祖先结点<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure></li>
<li>当询问两个元素 a b 是否在同一个集合中时，只需要看 a b 的祖先结点是不是同一个，也就是判断 find(a) &#x3D;&#x3D; find(b) 是否成立</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】树状数组</title>
    <url>/posts/b289bb13.html</url>
    <content><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/574739597">https://zhuanlan.zhihu.com/p/574739597</a></p>
<p>树状数组主要是支持两种操作：</p>
<ul>
<li><strong>单点修改</strong></li>
<li><strong>区间查询</strong></li>
</ul>
<p>这两个操作的时间复杂度都是 <em>O(logn)</em><br>根据前缀和的原理，任意一段区间求和都可以转换成两个前缀和的差，因此区间求和问题转换成求前缀和问题</p>
<h1 id="前提准备：计算-lowbit"><a href="#前提准备：计算-lowbit" class="headerlink" title="前提准备：计算 lowbit"></a>前提准备：计算 lowbit</h1><p>在此我们定义一个 <code>lowbit(x)</code> ，表示 x 的最末尾一个 1 与这个 1 后面的所有 0 组成的二进制数<br><code>lowbit(x)</code> 应该怎么实现呢？<br>很简单，这里直接给出结论 <code>lowbit(x) = x &amp; -x</code><br>还是通过例子来说明</p>
<blockquote>
<p>现有二进制数 101100<br>x &#x3D; 101100<br>反码：010011<br>补码：010100</p>
</blockquote>
<p>可以注意到，-x 是 x 末尾的一个 1 到结束的 0 不动，前面全部取反的结果<br>那么 <code>x &amp; -x</code> 就只保留了末尾的 1 和后面的 0<br>因此得到我们的 lowbit 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="树状数组的含义"><a href="#树状数组的含义" class="headerlink" title="树状数组的含义"></a>树状数组的含义</h1><p>我们定义原数组为<code>a</code>，用一个数组 <code>tree</code> 维护若干个小区间，<code>tree[i]</code> 表示<strong>以<code>a[i]</code>为结尾、长度为<code>lowbit(i)</code>的区间的和，也就是<code>(i-lowbit(i), i]</code>（左开右闭）这一区间的和</strong>（这一点很重要，请务必记住）<br>举个栗子吧</p>
<blockquote>
<p>i &#x3D; 5 &#x3D; 101<del>(2)</del><br>lowbit(i) &#x3D; lowbit(101) &#x3D; 001<del>(2)</del> &#x3D; 1         i - lowbit(i) &#x3D; 100<del>(2)</del> &#x3D; 4<br>i &#x3D; i - lowbit(i) &#x3D; 4 &#x3D; 100<del>(2)</del><br>lowbit(i) &#x3D; lowbit(100) &#x3D; 100<del>(2)</del>         i - lowbit(i) &#x3D; 0<br>因此 lowbit(5) 就等于以 a[5] 结尾，长度为 lowbit(5) &#x3D; 1 的区间的和，也就是等于 a[5]</p>
</blockquote>
<ul>
<li>单点修改时，只更新<strong>包含这一元素的区间</strong></li>
<li>求前 n 项和时，通过将区间进行<strong>组合</strong>，得到从 1 到 n 的区间，然后对所有用到的区间求和。<br>将 n 转换为二进制，任意一个数都可以看作是几个二进制数表示区间的和<br>举个栗子<blockquote>
<p>11<del>(10)</del> &#x3D; 1011<del>(2)</del><br>求前 11 项的和，可以转换成求 1010 - 1011、1000 - 1010、0000 - 1000 这几个区间的和</p>
</blockquote>
</li>
</ul>
<p>这个步骤就是在不断地删去最末尾的一个 1<br>而我们刚刚在前提准备里提到，lowbit 运算，就是不断删去末尾的 1 的过程</p>
<p>因此单点修改时，我们只需要从<code>tree[1]</code>开始，每次将<code>i</code> 更新成<code>i + lowbit(i)</code>，修改当前的<code>tree[i]</code>，直到<code>i</code>被更新为 N<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= N)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[i] += x;</span><br><span class="line">		i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求 <code>a[i]</code> 的前缀和时，可以利用循环来求解，每次将 <code>i</code> 更新为 <code>i - lowbit(i)</code>，加上修改后的 <code>i</code> 的 <code>tree[i]</code> 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefix_sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		presum += tree[i];</span><br><span class="line">		i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> presum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，区间求和的代码也显而易见了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">prefix_sum</span>(r) - <span class="built_in">prefix_sum</span>(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拓展应用"><a href="#拓展应用" class="headerlink" title="拓展应用"></a>拓展应用</h1><h2 id="拓展一：区间修改、单点查询"><a href="#拓展一：区间修改、单点查询" class="headerlink" title="拓展一：区间修改、单点查询"></a>拓展一：区间修改、单点查询</h2><p>区间修改，我们需要给区间内的每个数加上同一个给定值 x，很容易想到利用差分来降低复杂度，记原数组为<code>a[i]</code>，差分数组为<code>b[i]</code>，<code>b[i] = a[i] - a[i - 1]</code><br>在<code>b[i]</code>上建立树状数组<code>tree[i]</code>，每次对<code>a</code>中<code>[l, r]</code>区间上的修改，就相当于<code>b[l] += x</code>和<code>b[r + 1] -= x</code>，这样我们也可以对<code>tree[i]</code>做出相应的两次单点修改，于是区间修改也被我们转换成单点修改得到解决了</p>
<p>单点查询，根据差分数组的性质，<code>a[i] = b[1] + b[2] + … + b[i]</code>，即可将单点查询转换成求<code>b</code>的前缀和，进而利用树状数组进行计算</p>
<h2 id="拓展二：区间查询、区间修改"><a href="#拓展二：区间查询、区间修改" class="headerlink" title="拓展二：区间查询、区间修改"></a>拓展二：区间查询、区间修改</h2><p>计算<code>a[i]</code>时，需要计算<code>b[i]</code>的前缀和<br>所以计算<code>a[i]</code>的前缀和时，我们就需要计算<code>b[i]</code>的前缀和的前缀和<br>用数学公式表达如下：（计算<code>a[p]</code>的前缀和）</p>
<p>$\sum_{i &#x3D; 1}^{p} a[i] &#x3D; \sum_{i &#x3D; 1}^{p}(\sum_{j &#x3D; 1}^{i} b[j])$</p>
<p>等号右侧中，<code>b[1]</code>出现了 p 次，<code>b[2]</code>出现了 p - 1 次，<code>b[j]</code>出现了 p + 1 - j 次。因此可知：</p>
<p>$\sum_{i &#x3D; 1}^{p} a[i] &#x3D; (p + 1)\sum_{j &#x3D; i  -1}^{p}b[j] - \sum_{j &#x3D; 1}^{p}b[j] * j$</p>
<p>可以理解为：我们先把每个<code>b[j]</code>都算作出现了<code>p + 1</code>次，然后再把多算的 <code>j</code> 次减去。</p>
<p>因此——</p>
<ul>
<li><code>b[i] = a[i] - a[i - 1]</code></li>
<li><code>c[i] = b[i] * i</code></li>
</ul>
<p>对于<code>b[i]</code>和<code>c[i]</code>都建立树状数组，这样就可以很容易求出<code>b[i]</code>和<code>c[i]</code>的前缀和，也就得到了<code>a[i]</code>的前缀和，区间查询完成</p>
<p>对于区间修改，我们将<code>a</code>的<code>[l, r]</code>每个元素加上 x，<code>b</code>的变化方式为<code>b[l] += x</code>和<code>b[r + 1] -= x</code>，相应的，<code>c</code>的变化方式为<code>c[l] += x * l ，c[r + 1] -= x * (r + 1)</code>，也就是对 b 和 c 进行两次单点修改，这个步骤已经在上面写过就不重复了</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线段树</title>
    <url>/posts/63fc9272.html</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&#x3D;&#x3D;<strong>时间复杂度：O(logn)</strong>&#x3D;&#x3D;</p>
<p>线段树是一棵二叉树，把一段区间分成多个部分</p>
<img src="/posts/63fc9272/1.png" class title="This is an test image">
<p>类似堆的方式，用一维数组存整棵树</p>
<p>对于编号x的结点：</p>
<ul>
<li>父结点 $\lfloor x \rfloor$，表示为 <code>x &gt;&gt; 1</code></li>
<li>左子树 $2x$，表示为 <code>x &lt;&lt; 1</code></li>
<li>右子树 $2x+1$，表示为 <code>x &lt;&lt; 1 | 1</code></li>
</ul>
<p>对于长度为n的区间，最坏估计有 $4n-1$ 个结点，因此 &#x3D;&#x3D;<strong>开数组时空间一般开 $4n$</strong>&#x3D;&#x3D;</p>
<h1 id="pushup"><a href="#pushup" class="headerlink" title="pushup"></a>pushup</h1><p><strong>由子结点计算父结点的信息</strong></p>
<p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u表示当前树中结点编号 lr表示树中结点左右子结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 此处用[l]和[r]的值更新[u] */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="build"><a href="#build" class="headerlink" title="build"></a>build</h1><p><strong>将一段区间初始化为线段树</strong></p>
<ol>
<li>首先记录下当前区间的左右端点，如果左端点和右端点相等就直接返回</li>
<li>如果不相等，取中间值 <code>mid</code>，然后分别递归左右两段</li>
</ol>
<p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u表示当前树中结点编号 lr表示区间左右端点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="comment">// 左右端点相同表示到达叶子结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;    &#125;; <span class="comment">// 创建该结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r); <span class="comment">// 分别构造左右两棵子树</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 利用pushup更新该点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="modify"><a href="#modify" class="headerlink" title="modify"></a>modify</h1><p><strong>修改单点或区间（需要用到push_down操作）</strong></p>
<p><strong>修改单点</strong>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u为当前树中结点编号 要把x位置的值更新为v</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x) <span class="comment">// 到达叶子结点 直接更新</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;     &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v); <span class="comment">// 要更新的位置在左半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v); <span class="comment">// 要更新的位置在右半部分</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 更新此位置结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改区间</strong>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="comment">// 当前树中结点在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (i64)(tr[u].r - tr[u].l + <span class="number">1</span>) * d; <span class="comment">// 更新区间信息</span></span><br><span class="line">        tr[u].add += d; <span class="comment">// 打上懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 当前树中结点不在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u); <span class="comment">// 将懒标记向下传递</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 由于modify修改了区间结点的信息，所以被修改的结点的祖先结点都需要重算一遍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="query"><a href="#query" class="headerlink" title="query"></a>query</h1><p><strong>查询区间信息</strong></p>
<p>假设我们要查询某区间的最大值</p>
<p>定义 <code>[l, r]</code> 为我们要查询的区间，<code>[Tl, Tr]</code> 为树中结点（当前我们正在维护的区间），这两个区间会有如下两种关系：</p>
<ul>
<li>$[Tl, Tr]\subset[l, r]$，树中结点完全包含在要查询的区间内部<br>这种情况直接返回当前区间最大值即可</li>
<li>$[l, r]\bigcap[Tl, Tr]\not&#x3D;\emptyset$，二者有交集<br>和左边有交集就递归到左边做一遍，和右边有交集就递归到右边做一遍<br>即<code>l &gt; mid</code>只递归右边，<code>r &lt;= mid</code>只递归左边，否则左右都递归</li>
</ul>
<p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u]; <span class="comment">// 当前区间在被查询区间之内 直接返回</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 取中间值</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r); <span class="comment">// 被查询区间在当前区间左半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r); <span class="comment">// 被查询区间在当前区间右半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 被查询区间横跨当前区间的左右两部分</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r); <span class="comment">// 计算出左半部分值</span></span><br><span class="line">            <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r); <span class="comment">// 计算出右半部分值</span></span><br><span class="line">            Node res;</span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right); <span class="comment">// 更新结果</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="pushdown（懒标记-延迟标记）"><a href="#pushdown（懒标记-延迟标记）" class="headerlink" title="pushdown（懒标记 &#x2F; 延迟标记）"></a>pushdown（懒标记 &#x2F; 延迟标记）</h1><p><strong>将父结点的修改更新到子结点</strong></p>
<p>单点修改可以只用pushup，涉及到区间修改就需要使用pushdown</p>
<p><strong>懒标记</strong> ：在当前树中结点上打上懒标记，就表示对<strong>以当前树中结点为根结点</strong>的<strong>每一个子树</strong>都进行操作（根结点自己不用操作）</p>
<p>那么懒标记怎么进行传递呢？</p>
<p>焗个栗子：比如我们在蓝色的这一段区间上打上懒标记</p>

<p>每当我们需要遍历蓝色区间结点下方的子结点时，我们就把懒标记传递给下一层结点，同时把根结点的懒标记删除，就像这样：</p>

<p>当然，除了传递标记，我们还需要对线段树中记录的值进行更新，比如说这个线段树记录的是区间和，打上懒标记表示这一段区间每一个数都要加上<code>a</code>，那么我们在传递懒标记的同时，还需要让下方结点的区间和加上<code>(r - l + 1) * a</code>，其中<code>(l - r + 1)</code>表示下方被更新结点的区间长度</p>
<p>以此类推，每当我们需要遍历下方结点时，就把懒标记向下传，并更新下方结点的值</p>
<p>以上就是pushdown操作的基本内容</p>
<p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (root.add) <span class="comment">// 当前结点有懒标记 向下传递</span></span><br><span class="line">    &#123;</span><br><span class="line">        left.add += root.add, left.sum += (i64)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (i64)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例题：一个简单的整数问题2"><a href="#例题：一个简单的整数问题2" class="headerlink" title="例题：一个简单的整数问题2"></a>例题：一个简单的整数问题2</h1><p><a href="https://www.acwing.com/problem/content/244/">原题链接</a></p>
<p>给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p>
<p><code>C l r d</code>，表示把 A[l],A[l+1],…,A[r] 都加上 d。<br><code>Q l r</code>，表示询问数列中第 l∼r 个数的和。<br>对于每个询问，输出一个整数表示答案。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数 N,M。</p>
<p>第二行 N 个整数 A[i]。</p>
<p>接下来 M 行表示 M 条指令，每条指令的格式如题目描述所示。</p>
<p><strong>输出格式</strong></p>
<p>对于每个询问，输出一个整数表示答案。</p>
<p>每个答案占一行。</p>
<p><strong>数据范围</strong></p>
<p>$1≤N,M≤105,$<br>$|d|≤10000,$<br>$|A[i]|≤109$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">Q <span class="number">4</span> <span class="number">4</span></span><br><span class="line">Q <span class="number">1</span> <span class="number">10</span></span><br><span class="line">Q <span class="number">2</span> <span class="number">4</span></span><br><span class="line">C <span class="number">3</span> <span class="number">6</span> <span class="number">3</span></span><br><span class="line">Q <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    i64 sum, add; <span class="comment">// 区间和和懒标记</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (root.add) <span class="comment">// 当前结点有懒标记 向下传递</span></span><br><span class="line">    &#123;</span><br><span class="line">        left.add += root.add, left.sum += (i64)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (i64)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="comment">// 当前树中结点在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (i64)(tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[u].add += d; <span class="comment">// 打上懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 当前树中结点不在所求区间之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u); <span class="comment">// 将懒标记向下传递</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d); <span class="comment">// 与左半段有重合部分就更新左半段</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 由于modify修改了区间结点的信息，所以被修改的结点的祖先结点都需要重算一遍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u); <span class="comment">// 为了让查询到的最小结点都已计算过祖先结点的懒标记</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    i64 sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> l, r, d;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; d;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="扫描线法"><a href="#扫描线法" class="headerlink" title="扫描线法"></a>扫描线法</h1><p>放一道例题</p>
<h2 id="亚特兰蒂斯"><a href="#亚特兰蒂斯" class="headerlink" title="亚特兰蒂斯"></a>亚特兰蒂斯</h2><p><a href="https://www.acwing.com/problem/content/249/">原题链接</a></p>
<p>有几个古希腊书籍中包含了对传说中的亚特兰蒂斯岛的描述。</p>
<p>其中一些甚至包括岛屿部分地图。</p>
<p>但不幸的是，这些地图描述了亚特兰蒂斯的不同区域。</p>
<p>您的朋友 Bill 必须知道地图的总面积。</p>
<p>你自告奋勇写了一个计算这个总面积的程序。</p>
<p><strong>输入格式</strong></p>
<p>输入包含多组测试用例。</p>
<p>对于每组测试用例，第一行包含整数 n，表示总的地图数量。</p>
<p>接下来 n 行，描绘了每张地图，每行包含四个数字 x1,y1,x2,y2（不一定是整数），(x1,y1) 和 (x2,y2) 分别是地图的左上角位置和右下角位置。</p>
<p>注意，坐标轴 x 轴从上向下延伸，y 轴从左向右延伸。</p>
<p>当输入用例 n&#x3D;0 时，表示输入终止，该用例无需处理。</p>
<p><strong>输出格式</strong></p>
<p>每组测试用例输出两行。</p>
<p>第一行输出 Test case #k，其中 k 是测试用例的编号，从 1 开始。</p>
<p>第二行输出 Total explored area: a，其中 a 是总地图面积（即此测试用例中所有矩形的面积并，注意如果一片区域被多个地图包含，则在计算总面积时只计算一次），精确到小数点后两位数。</p>
<p>在每个测试用例后输出一个空行。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤10000,$<br>$0≤x1&lt;x2≤100000,$<br>$0≤y1&lt;y2≤100000$</p>
<p>注意，本题 n 的范围上限加强至 10000。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span> <span class="number">20</span> <span class="number">20</span></span><br><span class="line"><span class="number">15</span> <span class="number">15</span> <span class="number">25</span> <span class="number">25.5</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Test <span class="keyword">case</span> #<span class="number">1</span></span><br><span class="line">Total explored area: <span class="number">180.00</span> </span><br></pre></td></tr></table></figure>

<p><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x, y1, y2;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Segment &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">double</span> len;</span><br><span class="line">&#125;tr[N * <span class="number">8</span>]; <span class="comment">// 线段树</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; ys; <span class="comment">// 存储纵坐标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), y) - ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].cnt) tr[u].len = ys[tr[u].r + <span class="number">1</span>] - ys[tr[u].l]; <span class="comment">// 这一段被完全覆盖 所以直接算长度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[u].l != tr[u].r) <span class="comment">// 没有被完全覆盖 分成左右两段分别来看</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = <span class="number">0</span>; <span class="comment">// 叶子结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l != r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// cnt和len都是0所以不需要pushdown</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="comment">// 完全覆盖</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].cnt += k;</span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 更新该节点的len</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        ys.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> x1, x2, y1, y2;</span><br><span class="line">            cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            <span class="comment">// 把所有竖着的线段存进segment</span></span><br><span class="line">            seg[j ++ ] = &#123;x1, y1, y2, <span class="number">1</span>&#125;;</span><br><span class="line">            seg[j ++ ] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">            ys.<span class="built_in">push_back</span>(y1), ys.<span class="built_in">push_back</span>(y2); <span class="comment">// 把所有纵坐标存进ys</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 纵坐标去重</span></span><br><span class="line">        <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>());</span><br><span class="line">        ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>()), ys.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, ys.<span class="built_in">size</span>() - <span class="number">2</span>); <span class="comment">// 纵坐标点的数量到ys-1 线段数量就是ys-2</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(seg, seg + n * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i) res += tr[<span class="number">1</span>].len * (seg[i].x - seg[i - <span class="number">1</span>].x);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test case #&quot;</span> &lt;&lt; T &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        T ++ ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】莫队</title>
    <url>/posts/3dab568c.html</url>
    <content><![CDATA[<p>这篇博客起源于本人把一道 $pow(2,n)$ 的问题考虑成求组合数前缀和的问题qwq，于是接触到了这个新算法来总结一下</p>
<p>参考自<a href="https://www.cnblogs.com/WAMonster/p/10118934.html#!comments">这篇文章</a>，写得太好了</p>
<p>首先是一道<a href="https://www.luogu.com.cn/problem/SP3267">模板题</a></p>
<p>题目意思是，给出一个数组a，再给出多个区间，问这些区间里分别有多少不一样的数字</p>
<p>焗个栗子：</p>
<img src="/posts/undefined/1.jpg" class>
<p>比如给出的是这样一个数组，询问的两个区间是红色和绿色标注的区间</p>
<p>如果我们分别遍历每一个区间，复杂度就太高了，因此就有大佬提出这样一种算法——</p>
<p>首先定义双指针 $l$、$r$，初始化为 $l&#x3D;0,r&#x3D;-1$（表示此时区间内没有任何元素），然后用<code>unorderd_map&lt;int, int&gt; map</code>存储当前区间内每个元素的个数</p>
<p>看我们要求的第一个区间 $[0,5]$</p>
<p>$l$ 此时等于$0$，和所求区间的左端点相同，因此无需移动</p>
<p>$r$ 此时等于$-1$，在所求区间右端点的左侧，因此需要向右移</p>
<p>首先向右移一位变成 $0$，此时区间内添加了一个元素 5,因为<code>map[5] = 0</code>，元素5不存在于原来的区间里，因此元素种类数<code>cnt</code>加一，<code>map[5] ++ </code></p>
<p>然后 $r$ 再右移一位变成 1，此时区间内添加了一个元素 7,因为<code>map[7] = 0</code>，元素7不存在于原来的区间里，因此元素种类数<code>cnt</code>加一，<code>map[7] ++ </code></p>
<p>依此类推，直到 $r$ 右移到了 5，此时区间内添加了一个元素 7，但是添加前的<code>map[7] = 1</code>，添加了当前的 7 并不会让区间内元素的个数增多，因此<code>cnt</code>无需改变，<code>map[7] ++</code></p>
<p>之后从红色区间挪到绿色区间的操作也是类似的</p>
<p>上文介绍了如何往区间内添加数，当然，删除一个数的操作也是类似的，只不过添加数时，我们要先看被添加的数有没有出现在原来的区间里，也就是<code>map[x]</code>是否等于0，如果等于0说明不存在于原来的区间，区间内元素种类数<code>cnt</code>才能加一，而删除数时，我们要先把当前数删除，也就是<code>map[x]</code>减一，然后再判断当前区间里还有没有x，如果没有x也就是<code>map[x] == 0</code>，那么区间内元素种类数<code>cnt</code>减一</p>
<p><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!map[a[pos]]) cnt ++ ; <span class="comment">// 在区间中新出现，总数要+1</span></span><br><span class="line">    map[a[pos]] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map[a[pos]] -- ;</span><br><span class="line">    <span class="keyword">if</span> (!map[a[pos]]) cnt -- ; <span class="comment">// 在区间中不再出现，总数要-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入询问区间的左右端点</span></span><br><span class="line">        <span class="type">int</span> ql, qr;</span><br><span class="line">        cin &gt;&gt; ql &gt;&gt; qr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; ql) <span class="built_in">del</span>(l++); <span class="comment">// 如左指针在查询区间左方，左指针向右移直到与查询区间左端点重合</span></span><br><span class="line">        <span class="keyword">while</span> (l &gt; ql) <span class="built_in">add</span>(--l); <span class="comment">// 如左指针在查询区间左端点右方，左指针左移</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; qr) <span class="built_in">add</span>(++r); <span class="comment">// 右指针在查询区间右端点左方，右指针右移</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; qr) <span class="built_in">del</span>(r--);        <span class="comment">// 否则左移</span></span><br><span class="line">        cout &lt;&lt; cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就 <del>结束啦</del> qwq</p>
<p>才怪</p>
<p>还可以对这个算法继续优化</p>
<p> <strong>莫队算法优化的核心是&#x3D;&#x3D;分块&#x3D;&#x3D;和&#x3D;&#x3D;排序&#x3D;&#x3D;</strong></p>
<p>把长度为 $n$ 的序列分成 $\sqrt{n}$ 个块，然后按照左端点所在的块排序，如果左端点在同一个块内，则按右端点排序</p>
<p><strong>优化1</strong><br>这种排序方法也可以接着优化：如果左端点在同一奇数块内，则按右端点从小到大排序，如果左端点在同一偶数块内，则按右端点从大到小排序，这样排序是为了减少右端点移动的次数进而提高效率）</p>
<p><strong>优化2</strong><br>听说开O2优化能产生奇妙反应，实在没办法了可以考虑考虑这个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br></pre></td></tr></table></figure>

<p><strong>优化3</strong><br>某佬把上面的一长串代码简化成了下面这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; ql) cnt -= !--map[a[l++]];</span><br><span class="line"><span class="keyword">while</span>(l &gt; ql) cnt += !map[a[--l]]++;</span><br><span class="line"><span class="keyword">while</span>(r &lt; qr) cnt += !map[a[++r]]++;</span><br><span class="line"><span class="keyword">while</span>(r &gt; qr) cnt -= !--map[a[r--]];</span><br></pre></td></tr></table></figure>
<p>于是模板题的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; PPI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="type">int</span> bnum = <span class="built_in">ceil</span>((<span class="type">double</span>)n / size); <span class="comment">// 把序列分成了多少块</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">belong</span><span class="params">(<span class="number">1e6</span> + <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bnum; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = (i - <span class="number">1</span>) * size + <span class="number">1</span>; j &lt;= i * size; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            belong[j] = i; <span class="comment">// 标记每个元素属于哪个块</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;PPI&gt; <span class="title">q</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; q[i].first.first &gt;&gt; q[i].first.second;</span><br><span class="line">        q[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">bool</span>(PPI a, PPI b)&gt; cmp = [&amp;](PPI a, PPI b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// return (belong[a.first.first] ^ belong[b.first.first]) ? belong[a.first.first] &lt; belong[b.first.first] : ((belong[a.first.first] &amp; 1) ? a.first.second &lt; b.first.second : a.first.second &gt; b.first.second);</span></span><br><span class="line">        <span class="keyword">if</span> (belong[a.first.first] != belong[b.first.first]) <span class="keyword">return</span> belong[a.first.first] &lt; belong[b.first.first];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (belong[a.first.first] % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> belong[a.first.second] &lt; belong[b.first.second];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> belong[a.first.second] &gt; belong[b.first.second];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ql = q[i].first.first, qr = q[i].first.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; ql) cnt -= !--map[a[l ++ ]];</span><br><span class="line">        <span class="keyword">while</span>(l &gt; ql) cnt += !map[a[-- l]] ++;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; qr) cnt += !map[a[++ r]] ++;</span><br><span class="line">        <span class="keyword">while</span>(r &gt; qr) cnt -= !--map[a[r -- ]];</span><br><span class="line"></span><br><span class="line">        ans[q[i].second] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的之后更新~~qwq</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
</search>
